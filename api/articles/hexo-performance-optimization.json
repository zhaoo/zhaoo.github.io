{"title":"Hexo - 性能优化之旅","slug":"hexo-performance-optimization","date":"2020-08-08T04:54:43.000Z","updated":"2020-09-07T07:30:10.000Z","comments":true,"path":"api/articles/hexo-performance-optimization.json","realPath":"/2020/08/08/hexo-performance-optimization/","excerpt":"看不见的地方一样重要，主题性能优化相关专题。","covers":["https://pic.izhaoo.com/20200809144612.png","https://pic.izhaoo.com/20200828111132.jpg","https://pic.izhaoo.com/20200828111143.jpg","https://pic.izhaoo.com/20200828112220.png","https://pic.izhaoo.com/20200828112255.png","https://pic.izhaoo.com/20200809135101.png","https://pic.izhaoo.com/20200809150928.png","https://pic.izhaoo.com/20200809145713.jpg","https://pic.izhaoo.com/20200809152145.jpg","https://pic.izhaoo.com/20200811163325.png","https://pic.izhaoo.com/20200811163117.png","https://pic.izhaoo.com/20200811164119.png","https://pic.izhaoo.com/20200811164005.png","https://pic.izhaoo.com/20200809160254.png","https://pic.izhaoo.com/20200809161341.png"],"cover":"https://pic.izhaoo.com/20200228081642.jpg","content":"<p>看不见的地方一样重要，主题性能优化相关专题。</p>\n<span id=\"more\"></span>\n\n<p>前几天面试问了性能优化，好久没关注这块了，许多操作就想不起来，很尴尬……</p>\n<p>所以本文总结一下 <code>hexo-theme-zhaoo</code> 主题中做的一些性能优化，主要从 <strong>用户体验</strong> 、<strong>网络请求</strong> 、<strong>视图渲染</strong> 三方面入手，作者借此复习一下，逃。</p>\n<h2 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h2><p>在做性能优化的时候，我们总是会关注各种指标：请求速度、渲染速度、白屏时间……这些优化固然重要，但是我们往往会忽略 <strong>用户体验</strong>，从用户角度来看可能体验才是最重要的。</p>\n<p>试想：你的网站刚上线，并没有做任何优化，此时首屏加载时间需要 <em>8s</em> 。很遗憾，大多数用户没有这个耐心等待，会选择点击右上角的 <strong>X</strong> ，并且拉入了“黑名单”。这样可不行，然后你就做了一些常规优化，轻轻松松就将首屏加载时间拉到了 <em>2s</em> ，用户粘性就上来了。这时候你还不满足，执着于各种性能指标，通过一套“牛X”的算法把加载时间优化到了 <em>1.5s</em> 。过程可能很艰辛，但是结果却不是很理想，因为对于大多数用户来说可能根本感受不到这 <em>0.5s</em> 之间的差别。当你绝望的时候，UI小姐姐甩过来一张 <code>Loading</code> 图，你随手一加，结果用户量猛增。</p>\n<p>从用户心理角度来说，从按下回车到首屏展示这段时间（白屏），他是最不安的，觉得这个网站随时可能挂掉。你甩出一个 <code>Loading</code> 动画让他“欣赏”，他起码会觉得这个网站还在动，大不了多看会儿嘛。</p>\n<p>所以我们做优化的时候要兼顾 <strong>用户体验</strong> ，而不是一昧的追求速度。</p>\n<h3 id=\"Loading\"><a href=\"#Loading\" class=\"headerlink\" title=\"Loading\"></a>Loading</h3><p>思路很简单，页面头部首先加载 <code>Loading</code> 遮罩图（HTML + CSS），在页面底部加载 <code>JS</code> 后，通过 <code>JS</code> 把 <code>Loading</code> 遮罩移除即可。</p>\n<p>考虑到用户体验，提供一个较为稳定的动画时间，而不是一闪而过，所以给了 <em>0.5s</em> 延时。同时埋了个点，可以在 <code>_config.yml</code> 中配置自己的 <code>Loading</code> 效果。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200809144612.png\"  ><span class=\"image-caption\">loading</span></p>\n<h3 id=\"渐进动画\"><a href=\"#渐进动画\" class=\"headerlink\" title=\"渐进动画\"></a>渐进动画</h3><h2 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h2><h3 id=\"Promise-并发控制\"><a href=\"#Promise-并发控制\" class=\"headerlink\" title=\"Promise 并发控制\"></a>Promise 并发控制</h3><p>这是一道“字节”必考题，面经背了学以致用吧。</p>\n<p>主题使用 <code>leancloud</code> 来存储浏览量（PV），在进入页面的时候会并发请求获取浏览量。会产生以下问题：1. 并发请求会被服务器阻塞，返回 <code>429</code> 错误。2. 由于请求被阻塞了，页面渲染也被JS引擎阻塞了，产生 <em>1s</em> 左右的延迟。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200828111132.jpg\"  ><span class=\"image-caption\">429</span></p>\n<p><img  src=\"https://pic.izhaoo.com/20200828111143.jpg\"  ><span class=\"image-caption\">429</span></p>\n<p>为了解决这一问题，我们可以引入 <code>Promise</code> 并发控制请求流量，控制一次性不会涌入大量请求。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200828112220.png\"  ><span class=\"image-caption\">并发控制</span></p>\n<p><img  src=\"https://pic.izhaoo.com/20200828112255.png\"  ><span class=\"image-caption\">调用方式</span></p>\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>静态资源从服务器下载到用户主机，需要经过许多路由，一般距离越远，速度越慢。<strong>CDN（内容分发网络）</strong> 就是将资源部署到空间分布于各地的服务器上，用户访问时从就近的服务器拉取资源，起到加速作用。还可充当 <strong>负载均衡</strong> 、 <strong>缓存备份</strong> 功能。<del>（以上是官方说法，我们哪来那么大的流量，纯粹是因为学生服务器太渣了，上行速度实在是太慢，架不住资源）</del></p>\n<p><code>CDN</code> 直接用云服务商的就好了，阿里云、腾讯云、七牛云、又拍云…… 好，我选择免费的七牛云，<code>HTTPS</code> 每个月也就五毛钱。</p>\n<p>部署方式很简单，创个账号，建个空间，绑个域名，传个文件，网上一堆教程。</p>\n<p>推荐一个图床工具：<a href=\"https://github.com/Molunerfinn/PicGo\">PicGo</a>、<a href=\"https://github.com/PicGo/vs-picgo\">vs-picgo</a></p>\n<p><code>VSCode</code> 版很方便。众所周知：<code>VSCode</code> 除了码代码啥都可以干。</p>\n<p>另外，<code>JS</code> 和 <code>CSS</code> 等静态资源，我们就不用存自己的 <code>CDN</code> 空间了，<a href=\"https://www.bootcdn.cn/\">BootCDN</a> 更方便。我在主题埋了个点，直接填写链接即可，不填默认从本地获取。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200809135101.png\"  ><span class=\"image-caption\">BootCDN</span></p>\n<h3 id=\"Gzip\"><a href=\"#Gzip\" class=\"headerlink\" title=\"Gzip\"></a>Gzip</h3><p>服务器层面，应该开启 <code>Gzip</code> 压缩，能将文件资源体积压缩到原来的 <strong>1/4</strong> 。注意不要对图片资源进行压缩，适得其反，所以在配置项 <code>gzip_types</code> 中进行选择。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200809150928.png\"  ><span class=\"image-caption\">gzip</span></p>\n<p><img  src=\"https://pic.izhaoo.com/20200809145713.jpg\"  ><span class=\"image-caption\">gzip</span><br>  <div align=\"center\"><p>（宝塔面板偷个懒）</p></div></p>\n<h3 id=\"async-defer\"><a href=\"#async-defer\" class=\"headerlink\" title=\"async / defer\"></a>async / defer</h3><p>【亲测效果很好】</p>\n<p>我们知道，<strong>GUI渲染线程</strong> 和 <strong>JS引擎线程</strong> 是互斥的，同时执行会导致渲染混乱，所以默认将他们分离执行。运行到 <code>&lt;script&gt;</code> 标签（包括加载脚本）时会暂停渲染，浪费了一些性能。（这也是我们提倡将 <code>&lt;style&gt;</code> 放在头部，将 <code>&lt;script&gt;</code> 放在底部的原因之一）</p>\n<p>为了压榨性能呢，<code>w3c</code> 为我们提供了两个属性：<code>async</code> 、 <code>defer</code>，可以帮助我们异步加载脚本。（周立齐：执行异步是不可能，这辈子都不可能的）</p>\n<ul>\n<li>default：同步加载脚本</li>\n<li>aysnc：异步加载脚本，加载完马上执行</li>\n<li>defer：异步加载脚本，页面渲染后执行</li>\n</ul>\n<p>盗了张图，一图胜千言：</p>\n<p><img  src=\"https://pic.izhaoo.com/20200809152145.jpg\"  ><span class=\"image-caption\">async/defer</span></p>\n<p>优化思路：</p>\n<ol>\n<li>把一些渲染过程中用不到的第三方脚本打上 <code>defer</code> ，拖到渲染后执行。</li>\n<li>把渲染中需要使用的脚本打上 <code>async</code> ，异步加载。（需要注意顺序，不要打乱执行流程）</li>\n</ol>\n<p><img  src=\"https://pic.izhaoo.com/20200811163325.png\"  ><span class=\"image-caption\">async/defer</span></p>\n<p>优雅一点嘛~</p>\n<p><img  src=\"https://pic.izhaoo.com/20200811163117.png\"  ><span class=\"image-caption\">async/defer</span></p>\n<p>像 <strong>评论</strong> 、 <strong>请求统计</strong> 、 <strong>DaoVoice</strong> 这些第三方脚本加载巨慢，特别是 <code>leancloud</code> ，延迟大约 <em>1s</em> 多，严重拖慢了渲染速度。套上 <code>async/defer</code> 之后感觉棒棒哒~</p>\n<h3 id=\"loadScript\"><a href=\"#loadScript\" class=\"headerlink\" title=\"loadScript\"></a>loadScript</h3><p>一些例如 <strong>实例化</strong> 、 <strong>挂载</strong> 等执行逻辑，需要依赖前置脚本加载完后才能执行。这时候如果给它俩都套上了 <code>async/defer</code> ，异步执行顺序就会不可控，会报一些 <code>underfined</code> 之类的错。</p>\n<p>所以我们需要改造一下，让它们链式触发。最简单的思路就是借助回调函数了，可以直接使用 <code>jQuery</code> 的 <code>$.ajax()</code> 实现。但是我后期考虑移除 <code>jQuery</code>，还是自己封装一下吧。</p>\n<p>最简单的加载方式是 <code>loadScript</code> ，通过操纵 <code>DOM</code> ， <code>append</code> 一个 <code>&lt;script&gt;</code> 标签来加载资源。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200811164119.png\"  ><span class=\"image-caption\">loadScript</span></p>\n<p>食用方式：</p>\n<p><img  src=\"https://pic.izhaoo.com/20200811164005.png\"  ><span class=\"image-caption\">loadScript</span></p>\n<h3 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h3><p>阿贾克斯年代了， <code>loadScript</code> 也太逊了吧…… </p>\n<p>之后可能会考虑移除 <code>jQuery</code>， 那就先封装一个 <code>Ajax</code>吧：</p>\n<h3 id=\"PJAX\"><a href=\"#PJAX\" class=\"headerlink\" title=\"PJAX\"></a>PJAX</h3><p>这是个反面教材……</p>\n<p><code>PJAX</code> 可以理解为 <code>AJAX</code> 的升级版。<code>AJAX</code> 只是简单的异步请求资源，一般用于局部无刷新加载，如果用于整页加载会造成 <code>URL</code> 无法更新，从而影响 <code>SEO</code> 和 回退操作。而 <code>PJAX</code> 基于 <code>AJAX</code> 和 <code>pushState</code> （其实就是前端路由那两套方案），可以改变 <code>URL</code>，可以提供了整页无刷新加载。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h3 id=\"PWA\"><a href=\"#PWA\" class=\"headerlink\" title=\"PWA\"></a>PWA</h3><h2 id=\"视图渲染\"><a href=\"#视图渲染\" class=\"headerlink\" title=\"视图渲染\"></a>视图渲染</h2><h3 id=\"静态脚本移到编译阶段\"><a href=\"#静态脚本移到编译阶段\" class=\"headerlink\" title=\"静态脚本移到编译阶段\"></a>静态脚本移到编译阶段</h3><h3 id=\"减少重绘回流\"><a href=\"#减少重绘回流\" class=\"headerlink\" title=\"减少重绘回流\"></a>减少重绘回流</h3><h3 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h3><p>懒加载就是图片延迟加载，先套个占位图，等图片 <em>进入视口后</em> 或者 <em>快进入时候时（通过加一定高度预判，预加载）</em> 才加载并渲染图片。</p>\n<p>实现思路：</p>\n<ol>\n<li>在编译阶段进行劫持，将 <code>HTML</code> 中的 <code>img</code> 标签中的 <code>src</code> 图片地址保存到 <code>data-src</code> 进行缓存，同时替换为占位图（Loading）。<br><img  src=\"https://pic.izhaoo.com/20200809160254.png\"  ><span class=\"image-caption\">编译替换</span></li>\n<li>运行阶段，图片进入视口后，再将 <code>src</code> 替换为 <code>data-src</code> 加载图片。<div align=\"center\">\n <img  src=\"https://pic.izhaoo.com/20200809161341.png\"  ><span class=\"image-caption\">懒加载</span>\n <p>（暂时用了第三方懒加载库，立个Flag，日后定要造个轮子）</p>\n</div>\n\n</li>\n</ol>\n<h3 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3>","more":"<p>前几天面试问了性能优化，好久没关注这块了，许多操作就想不起来，很尴尬……</p>\n<p>所以本文总结一下 <code>hexo-theme-zhaoo</code> 主题中做的一些性能优化，主要从 <strong>用户体验</strong> 、<strong>网络请求</strong> 、<strong>视图渲染</strong> 三方面入手，作者借此复习一下，逃。</p>\n<h2 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h2><p>在做性能优化的时候，我们总是会关注各种指标：请求速度、渲染速度、白屏时间……这些优化固然重要，但是我们往往会忽略 <strong>用户体验</strong>，从用户角度来看可能体验才是最重要的。</p>\n<p>试想：你的网站刚上线，并没有做任何优化，此时首屏加载时间需要 <em>8s</em> 。很遗憾，大多数用户没有这个耐心等待，会选择点击右上角的 <strong>X</strong> ，并且拉入了“黑名单”。这样可不行，然后你就做了一些常规优化，轻轻松松就将首屏加载时间拉到了 <em>2s</em> ，用户粘性就上来了。这时候你还不满足，执着于各种性能指标，通过一套“牛X”的算法把加载时间优化到了 <em>1.5s</em> 。过程可能很艰辛，但是结果却不是很理想，因为对于大多数用户来说可能根本感受不到这 <em>0.5s</em> 之间的差别。当你绝望的时候，UI小姐姐甩过来一张 <code>Loading</code> 图，你随手一加，结果用户量猛增。</p>\n<p>从用户心理角度来说，从按下回车到首屏展示这段时间（白屏），他是最不安的，觉得这个网站随时可能挂掉。你甩出一个 <code>Loading</code> 动画让他“欣赏”，他起码会觉得这个网站还在动，大不了多看会儿嘛。</p>\n<p>所以我们做优化的时候要兼顾 <strong>用户体验</strong> ，而不是一昧的追求速度。</p>\n<h3 id=\"Loading\"><a href=\"#Loading\" class=\"headerlink\" title=\"Loading\"></a>Loading</h3><p>思路很简单，页面头部首先加载 <code>Loading</code> 遮罩图（HTML + CSS），在页面底部加载 <code>JS</code> 后，通过 <code>JS</code> 把 <code>Loading</code> 遮罩移除即可。</p>\n<p>考虑到用户体验，提供一个较为稳定的动画时间，而不是一闪而过，所以给了 <em>0.5s</em> 延时。同时埋了个点，可以在 <code>_config.yml</code> 中配置自己的 <code>Loading</code> 效果。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200809144612.png\"  ><span class=\"image-caption\">loading</span></p>\n<h3 id=\"渐进动画\"><a href=\"#渐进动画\" class=\"headerlink\" title=\"渐进动画\"></a>渐进动画</h3><h2 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h2><h3 id=\"Promise-并发控制\"><a href=\"#Promise-并发控制\" class=\"headerlink\" title=\"Promise 并发控制\"></a>Promise 并发控制</h3><p>这是一道“字节”必考题，面经背了学以致用吧。</p>\n<p>主题使用 <code>leancloud</code> 来存储浏览量（PV），在进入页面的时候会并发请求获取浏览量。会产生以下问题：1. 并发请求会被服务器阻塞，返回 <code>429</code> 错误。2. 由于请求被阻塞了，页面渲染也被JS引擎阻塞了，产生 <em>1s</em> 左右的延迟。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200828111132.jpg\"  ><span class=\"image-caption\">429</span></p>\n<p><img  src=\"https://pic.izhaoo.com/20200828111143.jpg\"  ><span class=\"image-caption\">429</span></p>\n<p>为了解决这一问题，我们可以引入 <code>Promise</code> 并发控制请求流量，控制一次性不会涌入大量请求。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200828112220.png\"  ><span class=\"image-caption\">并发控制</span></p>\n<p><img  src=\"https://pic.izhaoo.com/20200828112255.png\"  ><span class=\"image-caption\">调用方式</span></p>\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>静态资源从服务器下载到用户主机，需要经过许多路由，一般距离越远，速度越慢。<strong>CDN（内容分发网络）</strong> 就是将资源部署到空间分布于各地的服务器上，用户访问时从就近的服务器拉取资源，起到加速作用。还可充当 <strong>负载均衡</strong> 、 <strong>缓存备份</strong> 功能。<del>（以上是官方说法，我们哪来那么大的流量，纯粹是因为学生服务器太渣了，上行速度实在是太慢，架不住资源）</del></p>\n<p><code>CDN</code> 直接用云服务商的就好了，阿里云、腾讯云、七牛云、又拍云…… 好，我选择免费的七牛云，<code>HTTPS</code> 每个月也就五毛钱。</p>\n<p>部署方式很简单，创个账号，建个空间，绑个域名，传个文件，网上一堆教程。</p>\n<p>推荐一个图床工具：<a href=\"https://github.com/Molunerfinn/PicGo\">PicGo</a>、<a href=\"https://github.com/PicGo/vs-picgo\">vs-picgo</a></p>\n<p><code>VSCode</code> 版很方便。众所周知：<code>VSCode</code> 除了码代码啥都可以干。</p>\n<p>另外，<code>JS</code> 和 <code>CSS</code> 等静态资源，我们就不用存自己的 <code>CDN</code> 空间了，<a href=\"https://www.bootcdn.cn/\">BootCDN</a> 更方便。我在主题埋了个点，直接填写链接即可，不填默认从本地获取。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200809135101.png\"  ><span class=\"image-caption\">BootCDN</span></p>\n<h3 id=\"Gzip\"><a href=\"#Gzip\" class=\"headerlink\" title=\"Gzip\"></a>Gzip</h3><p>服务器层面，应该开启 <code>Gzip</code> 压缩，能将文件资源体积压缩到原来的 <strong>1/4</strong> 。注意不要对图片资源进行压缩，适得其反，所以在配置项 <code>gzip_types</code> 中进行选择。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200809150928.png\"  ><span class=\"image-caption\">gzip</span></p>\n<p><img  src=\"https://pic.izhaoo.com/20200809145713.jpg\"  ><span class=\"image-caption\">gzip</span><br>  <div align=\"center\"><p>（宝塔面板偷个懒）</p></div></p>\n<h3 id=\"async-defer\"><a href=\"#async-defer\" class=\"headerlink\" title=\"async / defer\"></a>async / defer</h3><p>【亲测效果很好】</p>\n<p>我们知道，<strong>GUI渲染线程</strong> 和 <strong>JS引擎线程</strong> 是互斥的，同时执行会导致渲染混乱，所以默认将他们分离执行。运行到 <code>&lt;script&gt;</code> 标签（包括加载脚本）时会暂停渲染，浪费了一些性能。（这也是我们提倡将 <code>&lt;style&gt;</code> 放在头部，将 <code>&lt;script&gt;</code> 放在底部的原因之一）</p>\n<p>为了压榨性能呢，<code>w3c</code> 为我们提供了两个属性：<code>async</code> 、 <code>defer</code>，可以帮助我们异步加载脚本。（周立齐：执行异步是不可能，这辈子都不可能的）</p>\n<ul>\n<li>default：同步加载脚本</li>\n<li>aysnc：异步加载脚本，加载完马上执行</li>\n<li>defer：异步加载脚本，页面渲染后执行</li>\n</ul>\n<p>盗了张图，一图胜千言：</p>\n<p><img  src=\"https://pic.izhaoo.com/20200809152145.jpg\"  ><span class=\"image-caption\">async/defer</span></p>\n<p>优化思路：</p>\n<ol>\n<li>把一些渲染过程中用不到的第三方脚本打上 <code>defer</code> ，拖到渲染后执行。</li>\n<li>把渲染中需要使用的脚本打上 <code>async</code> ，异步加载。（需要注意顺序，不要打乱执行流程）</li>\n</ol>\n<p><img  src=\"https://pic.izhaoo.com/20200811163325.png\"  ><span class=\"image-caption\">async/defer</span></p>\n<p>优雅一点嘛~</p>\n<p><img  src=\"https://pic.izhaoo.com/20200811163117.png\"  ><span class=\"image-caption\">async/defer</span></p>\n<p>像 <strong>评论</strong> 、 <strong>请求统计</strong> 、 <strong>DaoVoice</strong> 这些第三方脚本加载巨慢，特别是 <code>leancloud</code> ，延迟大约 <em>1s</em> 多，严重拖慢了渲染速度。套上 <code>async/defer</code> 之后感觉棒棒哒~</p>\n<h3 id=\"loadScript\"><a href=\"#loadScript\" class=\"headerlink\" title=\"loadScript\"></a>loadScript</h3><p>一些例如 <strong>实例化</strong> 、 <strong>挂载</strong> 等执行逻辑，需要依赖前置脚本加载完后才能执行。这时候如果给它俩都套上了 <code>async/defer</code> ，异步执行顺序就会不可控，会报一些 <code>underfined</code> 之类的错。</p>\n<p>所以我们需要改造一下，让它们链式触发。最简单的思路就是借助回调函数了，可以直接使用 <code>jQuery</code> 的 <code>$.ajax()</code> 实现。但是我后期考虑移除 <code>jQuery</code>，还是自己封装一下吧。</p>\n<p>最简单的加载方式是 <code>loadScript</code> ，通过操纵 <code>DOM</code> ， <code>append</code> 一个 <code>&lt;script&gt;</code> 标签来加载资源。</p>\n<p><img  src=\"https://pic.izhaoo.com/20200811164119.png\"  ><span class=\"image-caption\">loadScript</span></p>\n<p>食用方式：</p>\n<p><img  src=\"https://pic.izhaoo.com/20200811164005.png\"  ><span class=\"image-caption\">loadScript</span></p>\n<h3 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h3><p>阿贾克斯年代了， <code>loadScript</code> 也太逊了吧…… </p>\n<p>之后可能会考虑移除 <code>jQuery</code>， 那就先封装一个 <code>Ajax</code>吧：</p>\n<h3 id=\"PJAX\"><a href=\"#PJAX\" class=\"headerlink\" title=\"PJAX\"></a>PJAX</h3><p>这是个反面教材……</p>\n<p><code>PJAX</code> 可以理解为 <code>AJAX</code> 的升级版。<code>AJAX</code> 只是简单的异步请求资源，一般用于局部无刷新加载，如果用于整页加载会造成 <code>URL</code> 无法更新，从而影响 <code>SEO</code> 和 回退操作。而 <code>PJAX</code> 基于 <code>AJAX</code> 和 <code>pushState</code> （其实就是前端路由那两套方案），可以改变 <code>URL</code>，可以提供了整页无刷新加载。</p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h3 id=\"PWA\"><a href=\"#PWA\" class=\"headerlink\" title=\"PWA\"></a>PWA</h3><h2 id=\"视图渲染\"><a href=\"#视图渲染\" class=\"headerlink\" title=\"视图渲染\"></a>视图渲染</h2><h3 id=\"静态脚本移到编译阶段\"><a href=\"#静态脚本移到编译阶段\" class=\"headerlink\" title=\"静态脚本移到编译阶段\"></a>静态脚本移到编译阶段</h3><h3 id=\"减少重绘回流\"><a href=\"#减少重绘回流\" class=\"headerlink\" title=\"减少重绘回流\"></a>减少重绘回流</h3><h3 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h3><p>懒加载就是图片延迟加载，先套个占位图，等图片 <em>进入视口后</em> 或者 <em>快进入时候时（通过加一定高度预判，预加载）</em> 才加载并渲染图片。</p>\n<p>实现思路：</p>\n<ol>\n<li>在编译阶段进行劫持，将 <code>HTML</code> 中的 <code>img</code> 标签中的 <code>src</code> 图片地址保存到 <code>data-src</code> 进行缓存，同时替换为占位图（Loading）。<br><img  src=\"https://pic.izhaoo.com/20200809160254.png\"  ><span class=\"image-caption\">编译替换</span></li>\n<li>运行阶段，图片进入视口后，再将 <code>src</code> 替换为 <code>data-src</code> 加载图片。<div align=\"center\">\n <img  src=\"https://pic.izhaoo.com/20200809161341.png\"  ><span class=\"image-caption\">懒加载</span>\n <p>（暂时用了第三方懒加载库，立个Flag，日后定要造个轮子）</p>\n</div>\n\n</li>\n</ol>\n<h3 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h3>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"Hexo","path":"api/tags/Hexo.json"},{"name":"主题","path":"api/tags/主题.json"},{"name":"前端","path":"api/tags/前端.json"}]}