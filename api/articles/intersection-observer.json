{"title":"IntersectionObserver","slug":"intersection-observer","date":"2021-08-03T14:34:43.000Z","updated":"2021-08-03T14:34:44.129Z","comments":true,"path":"api/articles/intersection-observer.json","realPath":"/2021/08/03/intersection-observer/","excerpt":"IntersectionObserver API 用于监听元素与父元素或视口的可视状态，分享一些日常开发中的实际应用案例。","covers":["https://pic.izhaoo.com/20210801222344gif.gif","https://pic.izhaoo.com/20210801222344.gif","https://pic.izhaoo.com/20210803223246.gif"],"cover":"https://pic.izhaoo.com/20210628212734.jpg","content":"<p>IntersectionObserver API 用于监听元素与父元素或视口的可视状态，分享一些日常开发中的实际应用案例。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\">IntersectionObserver</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry\">IntersectionObserver Entry</a></p>\n<blockquote>\n<p><em>IntersectionObserver</em> 用于异步观察目标元素与父元素可视状态。</p>\n</blockquote>\n<p>polyfill: tnpm install intersection-observer</p>\n<p><strong>base</strong></p>\n<pre><code class=\"javascript\">const observer = new IntersectionObserver(callback, options);\n\nobserver.observe();  //开始监听目标元素\nobserver.unobserve();  //取消监听目标元素\nobserver.takeRecords();  //返回所以观察目标的entries对象数组\nobserver.disconnect();  //停止所有监听</code></pre>\n<p><strong>callback</strong></p>\n<pre><code class=\"javascript\">const observer = new IntersectionObserver((entries) =&gt; &#123;\n  entries.forEach((entry) =&gt; &#123; \n    console.log(entry.isIntersecting);  //目标元素进入可见区域或离开可见区域\n  &#125;);\n&#125;);</code></pre>\n<ul>\n<li>isIntersecting: 目标元素进入可视区域或离开可见区域</li>\n<li>intersectionRatio: 目标元素在可视区域的比例</li>\n<li>intersectionRect: 目标元素与根元素的相交区域</li>\n<li>boundingClientRect: 目标元素的边界区域，同 <em>getBoundingClientRect()</em></li>\n<li>rootBounds: 返回交叉区域观察者中的根</li>\n<li>target: 触发时的目标元素</li>\n<li>time: 触发时的时间戳</li>\n</ul>\n<p><strong>options</strong></p>\n<pre><code class=\"javascript\">const observer = new IntersectionObserver(callback, &#123;\n  root: document.getElementById(&quot;container&quot;),  //父容器为container\n  rootMargin: &quot;10px, 10px, 10px, 10px&quot;,  //父容器内缩10px为计算边界\n  threshold: 1  //较差比例为100%时触发\n&#125;);</code></pre>\n<ul>\n<li>root: 监听对象的父元素，未指定则默认为根元素（root）</li>\n<li>rootMargin: 计算时的边界偏移量，可以放大/缩小计算容器</li>\n<li>threshold: 监听对象与父元素交叉比例触发阈值（0~1）</li>\n</ul>\n<h3 id=\"吸顶吸底\"><a href=\"#吸顶吸底\" class=\"headerlink\" title=\"吸顶吸底\"></a>吸顶吸底</h3><p><img  src=\"https://pic.izhaoo.com/20210801222344gif.gif\"  ><span class=\"image-caption\">吸顶效果</span></p>\n<p>最近的一个业务需求中需要实现 TabBar 吸顶能力。对于简单的吸顶，我们直接用 <code>position: sticky;</code> 即可。但是视觉同学要求在吸顶的时候 TabBar 的样式也做相应的变化，这就需要我们去监听吸顶状态。通过监听滚动事件，计算父子元素的相对距离，从而判读是否吸顶，代码如下：</p>\n<pre><code class=\"jsx\">export default function Tabbar() &#123;\n  const [isFixed, setIsFixed] = useState(false);\n\n  useEffect(() =&gt; &#123;\n    window.addEventListener(\n      &quot;scroll&quot;, () =&gt; &#123;\n        const rect = document.getElementById(&quot;tabbar&quot;) &amp;&amp; document.getElementById(&quot;tabbar&quot;).getBoundingClientRect();  //获取元素高度\n        setIsFixed(rect.top &lt;= 0 ? true : false);  //吸顶状态更新\n      &#125;, true  //Rax中屏蔽了冒泡事件，需要在捕获阶段监听事件\n    );\n  &#125;, []);  \n\n  return (\n    &lt;View className=&quot;container&quot;&gt;\n      &lt;Tabbar className=`tabbar $&#123;isFixed ? &quot;tabbar--fixed&quot; : null&#125;` id=&quot;tabbar&quot; /&gt;\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<pre><code class=\"css\">.tabbar &#123;\n  position: sticky;  /* 粘性定位 */\n  left: 0;\n  top: 0;\n  ...  /* 未吸顶样式 */\n&#125;\n\n.abbar--fixed &#123;\n  ...  /* 吸顶样式 */\n&#125;</code></pre>\n<p>虽然完美还原了视觉效果，但是一个简单的吸附判断需要添加滚动监听和状态机，对页面性能影响不小。并且还遇到了小坑：沉浸式 <em>TitleBar</em> 通过监听页面滚动切换效果，给了页面一个滚动层级，导致无法监听到元素的 <em>scrollTop</em> 属性，需要 Hack 处理。复盘的时候使用 <em>IntersectionObserver</em> 重构了一下，通过监听 Tabbar 元素与容器元素之间的交叉状态判断是否吸顶。看起来逼格提升了一个档次，代码如下：</p>\n<pre><code class=\"jsx\">export default function Tabbar() &#123;\n  useEffect(() =&gt; &#123;\n    if (containerRef.current &amp;&amp; tabbarRef.current) &#123;\n      handleFixed(containerRef.current, tabbarRef.current);\n    &#125;\n  &#125;, []);\n\n  const handleFixed = (containerEle, tabbarEle) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt; &#123;\n      entries.forEach((entry) =&gt; &#123;\n        if (entry.isIntersecting) &#123;\n          tabbarEle.setAttribute(&#39;class&#39;, &#39;tabbar--fixed&#39;);\n        &#125; else &#123;\n          tabbarEle.setAttribute(&#39;class&#39;, &#39;tabbar--unfixed&#39;);\n        &#125;\n      &#125;)\n    &#125;, &#123;\n      threshold: 1, //元素完全可见时触发回调函数\n    &#125;);\n    observer.observe(containerEle); //开始观察\n  &#125;\n\n  return (\n    &lt;View ref=&#123;containerRef&#125; className=&quot;container&quot; &gt;\n      &lt;Tabbar ref=&#123;tabbarRef&#125; /&gt;\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<pre><code class=\"css\">.container &#123;\n  position: fixed;\n  top: 0;\n  left: 0;\n&#125;\n\n.tabbar--fixed &#123;\n  position: fixed;\n  top: 0;\n  left: 0;\n  ...  /* 吸顶样式 */\n&#125;\n\n.tabbar--unfixed &#123;\n  position: relative;\n  ...  /* 未吸顶样式 */\n&#125;</code></pre>\n<p>看起来代码更烦了，但实际上可操作性更好。不用通过命令式地计算父子元素间的相对距离判断是否相交，而是声明式地把判断依据交给底层 API 实现。从 scroll 到 IntersectionObserver，性能也提升了不少。由于监听 scroll 事件密集发生，计算量很大，容易造成性能问题（套个节流函数 →_→）；而 IntersectionObserver 则是通过回调实现，只在临界计算一次，所以性能比较好。</p>\n<h3 id=\"电梯导航\"><a href=\"#电梯导航\" class=\"headerlink\" title=\"电梯导航\"></a>电梯导航</h3><p><img  src=\"https://pic.izhaoo.com/20210801222344.gif\"  ><span class=\"image-caption\">电梯效果</span></p>\n<p>不久，视觉同学提议将导航改成电梯导航，没问题……</p>\n<p>电梯导航可以拆成两块逻辑：1、点击导航项滑动至对应模块顶部。2、页面滚动时判断视口内的模块并切换导航。</p>\n<p>滑动模块：点击事件发生时调用 <code>window.scrollTo()</code> 方法平滑页面，平滑高度通过 <code>getElementById(id).offsetTop</code> 获取。</p>\n<p>切换导航：切入正题，使用 <strong>IntersectionObserver</strong> 监听模块元素和根元素（root）的可视状态，组合 <strong>isIntersecting</strong>（是否进入视口）和<strong>intersectionRatio</strong>（进入视口的比例）判断模块全部进入视口时切换 Tab。</p>\n<pre><code class=\"jsx\">const tabMap = [&#39;raider&#39;, &#39;show&#39;, &#39;poi&#39;];\n\nexport default function Main() &#123;\n  const [tab, setTab] = useState(&#39;raider&#39;);\n\n  useEffect(() =&gt; &#123;\n    const tabEle = tabMap.map(item =&gt; document.getElementById(item));  //获取DOM\n    handleElevator(tabEle);\n  &#125;, [])\n\n  const handleElevator = (tabEle) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt; &#123;\n      entries.forEach((entry) =&gt; &#123;\n        if (entry.isIntersecting &amp;&amp; entry.intersectionRatio === 1) &#123;  //当模块全部滑入页面时\n          setTab(entry.target.id);  //切换Tab\n        &#125;\n      &#125;);\n    &#125;)\n    tabEle.forEach(item =&gt; observer.observe(item));  //遍历Tab设置监听\n  &#125;\n\n  const handleClick = (id) =&gt; &#123;\n    setTab(id)\n    window.scrollTo(&#123;\n      top: document.getElementById(id).offsetTop,  //点击Tab项滑动至对应模块顶部\n      behavior: &#39;smooth&#39;  //平滑效果\n    &#125;);\n  &#125;\n\n  return (\n    &lt;View className=&quot;container&quot;&gt;\n      &lt;Tabbar tab=&#123;tab&#125; onClick=&#123;() =&gt; handleClick(id)&#125; /&gt;\n      &lt;RaiderGroup id=&quot;raider&quot; /&gt;\n      &lt;ShowGroup id=&quot;show&quot; /&gt;\n      &lt;PoiGroup id=&quot;poi&quot; /&gt;\n    &lt;/View&gt;\n  );\n&#125;</code></pre>\n<h3 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h3><p>同理，判断图片进入可视区后将 <em>src</em> 中的占位图替换为 <em>data-src</em> 中的真实地址即可。</p>\n<pre><code class=\"jsx\">export default function Lazyload() &#123;\n  useEffect(() =&gt; &#123;\n    const imagesEle = document.getElementsByClassName(&quot;image-lazyload&quot;);\n    const containerEle = getElementById(&quot;container&quot;);\n    handleLazyload(imagesEle, containerEle);\n  &#125;, [])\n\n  const handleLazyload = (imagesEle, containerEle) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt;&#123;\n      entries.forEach(item =&gt; &#123;\n        if (item.isIntersecting) &#123;\n          item.target.src = item.target.getAttribute(&quot;data-src&quot;);  //替换真实图片\n          observer.unobserve(item.target);  //取消监听\n        &#125;\n      &#125;)\n    &#125;, &#123;\n      root: containerEle\n    &#125;);\n    imagesEle.forEach(item =&gt; observer.observe(item));  //遍历图片设置监听\n  &#125;\n\n  return (\n    &lt;View id=&quot;container&quot;&gt;\n      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;\n      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;\n      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;\n      ...\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<h3 id=\"无限加载\"><a href=\"#无限加载\" class=\"headerlink\" title=\"无限加载\"></a>无限加载</h3><p>同理，判断页面划到底部时（Loading 进入视口时），获取数据并插入，可以设置预加载高度提前加载。</p>\n<pre><code class=\"jsx\">export default function LoadMore() &#123;\n  const [data, setData] = useState([])\n\n  useEffect(() =&gt; &#123;\n    const loadingEle = document.getElementById(&quot;loading&quot;);\n    handleLoadMore(loadingEle);\n  &#125;, [])\n\n  const handleLoadMore = (loadingEle, preload) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt;&#123;\n      entries.forEach((entry) =&gt; &#123;\n        if (entry.isIntersecting) &#123;  //Loading进入视口时，即划到底部时\n          fetchData();  //获取数据\n        &#125;\n      &#125;)\n    &#125;, &#123;\n      rootMargin: `0px 0px $&#123;preload&#125;px 0px`, // 提前加载高度\n    &#125;);\n    observer.observe(loadingEle);  //设置监听\n  &#125;\n\n  const fetchData = async () =&gt; &#123;\n    const res = await get(...);\n    if (res.isSuccess) &#123;\n      setData(data.concat(res.data));  //插入数据\n    &#125;\n  &#125;\n\n  return (\n    &lt;View id=&quot;container&quot;&gt;\n      &#123;data &amp;&amp; data.length &gt; 0 &amp;&amp; data.map(item =&gt; &lt;View /&gt;)&#125;  &#123;/* 渲染元素 */&#125;\n      &lt;Loading className=&quot;loading&quot; /&gt;\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<h3 id=\"曝光埋点\"><a href=\"#曝光埋点\" class=\"headerlink\" title=\"曝光埋点\"></a>曝光埋点</h3><p>同理，需要判断元素全部进入可视区域时触发。</p>\n<pre><code class=\"jsx\">export default function Exposure() &#123;\n  useEffect(() =&gt; &#123;\n    const expEle = document.getElementsByClassName(&quot;need-exp&quot;);\n    handleExposure(expEle);\n  &#125;, [])\n\n  const handleExposure = (expEle) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt;&#123;\n      entries.forEach(item =&gt; &#123;\n        if (item.intersectionRatio === 1) &#123;  //元素全部进入可视区域时\n          ...  //曝光逻辑\n          observer.unobserve(item.target);  //取消监听\n        &#125;\n      &#125;)\n    &#125;, &#123;\n      threshold: 1  //当元素全部进入可视区时触发\n    &#125;);\n    expEle.forEach(item =&gt; observer.observe(item));  //遍历元素设置监听\n  &#125;\n\n  return (\n    &lt;View id=&quot;container&quot;&gt;\n      &lt;View className=&quot;need-exp&quot; /&gt;\n      &lt;View className=&quot;need-exp&quot; /&gt;\n      &lt;View className=&quot;need-exp&quot; /&gt;\n      ...\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<h3 id=\"滚动动画\"><a href=\"#滚动动画\" class=\"headerlink\" title=\"滚动动画\"></a>滚动动画</h3><p><img  src=\"https://pic.izhaoo.com/20210803223246.gif\"  ><span class=\"image-caption\">滚动效果</span></p>\n<p>之前业务需要轮播图自适应图片高度，勉强还原了视觉效果。但是可以看到效果并不是最佳，自适应动画是在图片切换完成后才触发的，并没有实现跟手。</p>\n","more":"<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\">IntersectionObserver</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry\">IntersectionObserver Entry</a></p>\n<blockquote>\n<p><em>IntersectionObserver</em> 用于异步观察目标元素与父元素可视状态。</p>\n</blockquote>\n<p>polyfill: tnpm install intersection-observer</p>\n<p><strong>base</strong></p>\n<pre><code class=\"javascript\">const observer = new IntersectionObserver(callback, options);\n\nobserver.observe();  //开始监听目标元素\nobserver.unobserve();  //取消监听目标元素\nobserver.takeRecords();  //返回所以观察目标的entries对象数组\nobserver.disconnect();  //停止所有监听</code></pre>\n<p><strong>callback</strong></p>\n<pre><code class=\"javascript\">const observer = new IntersectionObserver((entries) =&gt; &#123;\n  entries.forEach((entry) =&gt; &#123; \n    console.log(entry.isIntersecting);  //目标元素进入可见区域或离开可见区域\n  &#125;);\n&#125;);</code></pre>\n<ul>\n<li>isIntersecting: 目标元素进入可视区域或离开可见区域</li>\n<li>intersectionRatio: 目标元素在可视区域的比例</li>\n<li>intersectionRect: 目标元素与根元素的相交区域</li>\n<li>boundingClientRect: 目标元素的边界区域，同 <em>getBoundingClientRect()</em></li>\n<li>rootBounds: 返回交叉区域观察者中的根</li>\n<li>target: 触发时的目标元素</li>\n<li>time: 触发时的时间戳</li>\n</ul>\n<p><strong>options</strong></p>\n<pre><code class=\"javascript\">const observer = new IntersectionObserver(callback, &#123;\n  root: document.getElementById(&quot;container&quot;),  //父容器为container\n  rootMargin: &quot;10px, 10px, 10px, 10px&quot;,  //父容器内缩10px为计算边界\n  threshold: 1  //较差比例为100%时触发\n&#125;);</code></pre>\n<ul>\n<li>root: 监听对象的父元素，未指定则默认为根元素（root）</li>\n<li>rootMargin: 计算时的边界偏移量，可以放大/缩小计算容器</li>\n<li>threshold: 监听对象与父元素交叉比例触发阈值（0~1）</li>\n</ul>\n<h3 id=\"吸顶吸底\"><a href=\"#吸顶吸底\" class=\"headerlink\" title=\"吸顶吸底\"></a>吸顶吸底</h3><p><img  src=\"https://pic.izhaoo.com/20210801222344gif.gif\"  ><span class=\"image-caption\">吸顶效果</span></p>\n<p>最近的一个业务需求中需要实现 TabBar 吸顶能力。对于简单的吸顶，我们直接用 <code>position: sticky;</code> 即可。但是视觉同学要求在吸顶的时候 TabBar 的样式也做相应的变化，这就需要我们去监听吸顶状态。通过监听滚动事件，计算父子元素的相对距离，从而判读是否吸顶，代码如下：</p>\n<pre><code class=\"jsx\">export default function Tabbar() &#123;\n  const [isFixed, setIsFixed] = useState(false);\n\n  useEffect(() =&gt; &#123;\n    window.addEventListener(\n      &quot;scroll&quot;, () =&gt; &#123;\n        const rect = document.getElementById(&quot;tabbar&quot;) &amp;&amp; document.getElementById(&quot;tabbar&quot;).getBoundingClientRect();  //获取元素高度\n        setIsFixed(rect.top &lt;= 0 ? true : false);  //吸顶状态更新\n      &#125;, true  //Rax中屏蔽了冒泡事件，需要在捕获阶段监听事件\n    );\n  &#125;, []);  \n\n  return (\n    &lt;View className=&quot;container&quot;&gt;\n      &lt;Tabbar className=`tabbar $&#123;isFixed ? &quot;tabbar--fixed&quot; : null&#125;` id=&quot;tabbar&quot; /&gt;\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<pre><code class=\"css\">.tabbar &#123;\n  position: sticky;  /* 粘性定位 */\n  left: 0;\n  top: 0;\n  ...  /* 未吸顶样式 */\n&#125;\n\n.abbar--fixed &#123;\n  ...  /* 吸顶样式 */\n&#125;</code></pre>\n<p>虽然完美还原了视觉效果，但是一个简单的吸附判断需要添加滚动监听和状态机，对页面性能影响不小。并且还遇到了小坑：沉浸式 <em>TitleBar</em> 通过监听页面滚动切换效果，给了页面一个滚动层级，导致无法监听到元素的 <em>scrollTop</em> 属性，需要 Hack 处理。复盘的时候使用 <em>IntersectionObserver</em> 重构了一下，通过监听 Tabbar 元素与容器元素之间的交叉状态判断是否吸顶。看起来逼格提升了一个档次，代码如下：</p>\n<pre><code class=\"jsx\">export default function Tabbar() &#123;\n  useEffect(() =&gt; &#123;\n    if (containerRef.current &amp;&amp; tabbarRef.current) &#123;\n      handleFixed(containerRef.current, tabbarRef.current);\n    &#125;\n  &#125;, []);\n\n  const handleFixed = (containerEle, tabbarEle) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt; &#123;\n      entries.forEach((entry) =&gt; &#123;\n        if (entry.isIntersecting) &#123;\n          tabbarEle.setAttribute(&#39;class&#39;, &#39;tabbar--fixed&#39;);\n        &#125; else &#123;\n          tabbarEle.setAttribute(&#39;class&#39;, &#39;tabbar--unfixed&#39;);\n        &#125;\n      &#125;)\n    &#125;, &#123;\n      threshold: 1, //元素完全可见时触发回调函数\n    &#125;);\n    observer.observe(containerEle); //开始观察\n  &#125;\n\n  return (\n    &lt;View ref=&#123;containerRef&#125; className=&quot;container&quot; &gt;\n      &lt;Tabbar ref=&#123;tabbarRef&#125; /&gt;\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<pre><code class=\"css\">.container &#123;\n  position: fixed;\n  top: 0;\n  left: 0;\n&#125;\n\n.tabbar--fixed &#123;\n  position: fixed;\n  top: 0;\n  left: 0;\n  ...  /* 吸顶样式 */\n&#125;\n\n.tabbar--unfixed &#123;\n  position: relative;\n  ...  /* 未吸顶样式 */\n&#125;</code></pre>\n<p>看起来代码更烦了，但实际上可操作性更好。不用通过命令式地计算父子元素间的相对距离判断是否相交，而是声明式地把判断依据交给底层 API 实现。从 scroll 到 IntersectionObserver，性能也提升了不少。由于监听 scroll 事件密集发生，计算量很大，容易造成性能问题（套个节流函数 →_→）；而 IntersectionObserver 则是通过回调实现，只在临界计算一次，所以性能比较好。</p>\n<h3 id=\"电梯导航\"><a href=\"#电梯导航\" class=\"headerlink\" title=\"电梯导航\"></a>电梯导航</h3><p><img  src=\"https://pic.izhaoo.com/20210801222344.gif\"  ><span class=\"image-caption\">电梯效果</span></p>\n<p>不久，视觉同学提议将导航改成电梯导航，没问题……</p>\n<p>电梯导航可以拆成两块逻辑：1、点击导航项滑动至对应模块顶部。2、页面滚动时判断视口内的模块并切换导航。</p>\n<p>滑动模块：点击事件发生时调用 <code>window.scrollTo()</code> 方法平滑页面，平滑高度通过 <code>getElementById(id).offsetTop</code> 获取。</p>\n<p>切换导航：切入正题，使用 <strong>IntersectionObserver</strong> 监听模块元素和根元素（root）的可视状态，组合 <strong>isIntersecting</strong>（是否进入视口）和<strong>intersectionRatio</strong>（进入视口的比例）判断模块全部进入视口时切换 Tab。</p>\n<pre><code class=\"jsx\">const tabMap = [&#39;raider&#39;, &#39;show&#39;, &#39;poi&#39;];\n\nexport default function Main() &#123;\n  const [tab, setTab] = useState(&#39;raider&#39;);\n\n  useEffect(() =&gt; &#123;\n    const tabEle = tabMap.map(item =&gt; document.getElementById(item));  //获取DOM\n    handleElevator(tabEle);\n  &#125;, [])\n\n  const handleElevator = (tabEle) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt; &#123;\n      entries.forEach((entry) =&gt; &#123;\n        if (entry.isIntersecting &amp;&amp; entry.intersectionRatio === 1) &#123;  //当模块全部滑入页面时\n          setTab(entry.target.id);  //切换Tab\n        &#125;\n      &#125;);\n    &#125;)\n    tabEle.forEach(item =&gt; observer.observe(item));  //遍历Tab设置监听\n  &#125;\n\n  const handleClick = (id) =&gt; &#123;\n    setTab(id)\n    window.scrollTo(&#123;\n      top: document.getElementById(id).offsetTop,  //点击Tab项滑动至对应模块顶部\n      behavior: &#39;smooth&#39;  //平滑效果\n    &#125;);\n  &#125;\n\n  return (\n    &lt;View className=&quot;container&quot;&gt;\n      &lt;Tabbar tab=&#123;tab&#125; onClick=&#123;() =&gt; handleClick(id)&#125; /&gt;\n      &lt;RaiderGroup id=&quot;raider&quot; /&gt;\n      &lt;ShowGroup id=&quot;show&quot; /&gt;\n      &lt;PoiGroup id=&quot;poi&quot; /&gt;\n    &lt;/View&gt;\n  );\n&#125;</code></pre>\n<h3 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h3><p>同理，判断图片进入可视区后将 <em>src</em> 中的占位图替换为 <em>data-src</em> 中的真实地址即可。</p>\n<pre><code class=\"jsx\">export default function Lazyload() &#123;\n  useEffect(() =&gt; &#123;\n    const imagesEle = document.getElementsByClassName(&quot;image-lazyload&quot;);\n    const containerEle = getElementById(&quot;container&quot;);\n    handleLazyload(imagesEle, containerEle);\n  &#125;, [])\n\n  const handleLazyload = (imagesEle, containerEle) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt;&#123;\n      entries.forEach(item =&gt; &#123;\n        if (item.isIntersecting) &#123;\n          item.target.src = item.target.getAttribute(&quot;data-src&quot;);  //替换真实图片\n          observer.unobserve(item.target);  //取消监听\n        &#125;\n      &#125;)\n    &#125;, &#123;\n      root: containerEle\n    &#125;);\n    imagesEle.forEach(item =&gt; observer.observe(item));  //遍历图片设置监听\n  &#125;\n\n  return (\n    &lt;View id=&quot;container&quot;&gt;\n      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;\n      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;\n      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;\n      ...\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<h3 id=\"无限加载\"><a href=\"#无限加载\" class=\"headerlink\" title=\"无限加载\"></a>无限加载</h3><p>同理，判断页面划到底部时（Loading 进入视口时），获取数据并插入，可以设置预加载高度提前加载。</p>\n<pre><code class=\"jsx\">export default function LoadMore() &#123;\n  const [data, setData] = useState([])\n\n  useEffect(() =&gt; &#123;\n    const loadingEle = document.getElementById(&quot;loading&quot;);\n    handleLoadMore(loadingEle);\n  &#125;, [])\n\n  const handleLoadMore = (loadingEle, preload) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt;&#123;\n      entries.forEach((entry) =&gt; &#123;\n        if (entry.isIntersecting) &#123;  //Loading进入视口时，即划到底部时\n          fetchData();  //获取数据\n        &#125;\n      &#125;)\n    &#125;, &#123;\n      rootMargin: `0px 0px $&#123;preload&#125;px 0px`, // 提前加载高度\n    &#125;);\n    observer.observe(loadingEle);  //设置监听\n  &#125;\n\n  const fetchData = async () =&gt; &#123;\n    const res = await get(...);\n    if (res.isSuccess) &#123;\n      setData(data.concat(res.data));  //插入数据\n    &#125;\n  &#125;\n\n  return (\n    &lt;View id=&quot;container&quot;&gt;\n      &#123;data &amp;&amp; data.length &gt; 0 &amp;&amp; data.map(item =&gt; &lt;View /&gt;)&#125;  &#123;/* 渲染元素 */&#125;\n      &lt;Loading className=&quot;loading&quot; /&gt;\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<h3 id=\"曝光埋点\"><a href=\"#曝光埋点\" class=\"headerlink\" title=\"曝光埋点\"></a>曝光埋点</h3><p>同理，需要判断元素全部进入可视区域时触发。</p>\n<pre><code class=\"jsx\">export default function Exposure() &#123;\n  useEffect(() =&gt; &#123;\n    const expEle = document.getElementsByClassName(&quot;need-exp&quot;);\n    handleExposure(expEle);\n  &#125;, [])\n\n  const handleExposure = (expEle) =&gt; &#123;\n    const observer = new IntersectionObserver((entries) =&gt;&#123;\n      entries.forEach(item =&gt; &#123;\n        if (item.intersectionRatio === 1) &#123;  //元素全部进入可视区域时\n          ...  //曝光逻辑\n          observer.unobserve(item.target);  //取消监听\n        &#125;\n      &#125;)\n    &#125;, &#123;\n      threshold: 1  //当元素全部进入可视区时触发\n    &#125;);\n    expEle.forEach(item =&gt; observer.observe(item));  //遍历元素设置监听\n  &#125;\n\n  return (\n    &lt;View id=&quot;container&quot;&gt;\n      &lt;View className=&quot;need-exp&quot; /&gt;\n      &lt;View className=&quot;need-exp&quot; /&gt;\n      &lt;View className=&quot;need-exp&quot; /&gt;\n      ...\n    &lt;/View&gt;\n  )\n&#125;</code></pre>\n<h3 id=\"滚动动画\"><a href=\"#滚动动画\" class=\"headerlink\" title=\"滚动动画\"></a>滚动动画</h3><p><img  src=\"https://pic.izhaoo.com/20210803223246.gif\"  ><span class=\"image-caption\">滚动效果</span></p>\n<p>之前业务需要轮播图自适应图片高度，勉强还原了视觉效果。但是可以看到效果并不是最佳，自适应动画是在图片切换完成后才触发的，并没有实现跟手。</p>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"js","path":"api/tags/js.json"}]}