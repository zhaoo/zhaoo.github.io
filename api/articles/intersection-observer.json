{"title":"IntersectionObserver","slug":"intersection-observer","date":"2021-08-03T14:34:43.000Z","updated":"2021-08-03T14:34:44.129Z","comments":true,"path":"api/articles/intersection-observer.json","realPath":"/2021/08/03/intersection-observer/","excerpt":"IntersectionObserver API 用于监听元素与父元素或视口的可视状态，分享一些日常开发中的实际应用案例。","covers":["https://pic.izhaoo.com/20210801222344gif.gif","https://pic.izhaoo.com/20210801222344.gif","https://pic.izhaoo.com/20210803223246.gif"],"cover":"https://pic.izhaoo.com/20210628212734.jpg","content":"<p>IntersectionObserver API 用于监听元素与父元素或视口的可视状态，分享一些日常开发中的实际应用案例。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\">IntersectionObserver</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry\">IntersectionObserver Entry</a></p>\n<blockquote>\n<p><em>IntersectionObserver</em> 用于异步观察目标元素与父元素可视状态。</p>\n</blockquote>\n<p>polyfill: tnpm install intersection-observer</p>\n<p><strong>base</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(callback, options);<br><br>observer.observe();  <span class=\"hljs-comment\">//开始监听目标元素</span><br>observer.unobserve();  <span class=\"hljs-comment\">//取消监听目标元素</span><br>observer.takeRecords();  <span class=\"hljs-comment\">//返回所以观察目标的entries对象数组</span><br>observer.disconnect();  <span class=\"hljs-comment\">//停止所有监听</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>callback</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span> &#123;<br>  entries.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =&gt;</span> &#123; <br>    <span class=\"hljs-built_in\">console</span>.log(entry.isIntersecting);  <span class=\"hljs-comment\">//目标元素进入可见区域或离开可见区域</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>isIntersecting: 目标元素进入可视区域或离开可见区域</li>\n<li>intersectionRatio: 目标元素在可视区域的比例</li>\n<li>intersectionRect: 目标元素与根元素的相交区域</li>\n<li>boundingClientRect: 目标元素的边界区域，同 <em>getBoundingClientRect()</em></li>\n<li>rootBounds: 返回交叉区域观察者中的根</li>\n<li>target: 触发时的目标元素</li>\n<li>time: 触发时的时间戳</li>\n</ul>\n<p><strong>options</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(callback, &#123;<br>  <span class=\"hljs-attr\">root</span>: <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;container&quot;</span>),  <span class=\"hljs-comment\">//父容器为container</span><br>  <span class=\"hljs-attr\">rootMargin</span>: <span class=\"hljs-string\">&quot;10px, 10px, 10px, 10px&quot;</span>,  <span class=\"hljs-comment\">//父容器内缩10px为计算边界</span><br>  <span class=\"hljs-attr\">threshold</span>: <span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\">//较差比例为100%时触发</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>root: 监听对象的父元素，未指定则默认为根元素（root）</li>\n<li>rootMargin: 计算时的边界偏移量，可以放大/缩小计算容器</li>\n<li>threshold: 监听对象与父元素交叉比例触发阈值（0~1）</li>\n</ul>\n<h3 id=\"吸顶吸底\"><a href=\"#吸顶吸底\" class=\"headerlink\" title=\"吸顶吸底\"></a>吸顶吸底</h3><p><img  src=\"https://pic.izhaoo.com/20210801222344gif.gif\"  ><span class=\"image-caption\">吸顶效果</span></p>\n<p>最近的一个业务需求中需要实现 TabBar 吸顶能力。对于简单的吸顶，我们直接用 <code>position: sticky;</code> 即可。但是视觉同学要求在吸顶的时候 TabBar 的样式也做相应的变化，这就需要我们去监听吸顶状态。通过监听滚动事件，计算父子元素的相对距离，从而判读是否吸顶，代码如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Tabbar</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [isFixed, setIsFixed] = useState(<span class=\"hljs-literal\">false</span>);<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<br>      <span class=\"hljs-string\">&quot;scroll&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">const</span> rect = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;tabbar&quot;</span>) &amp;&amp; <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;tabbar&quot;</span>).getBoundingClientRect();  <span class=\"hljs-comment\">//获取元素高度</span><br>        setIsFixed(rect.top &lt;= <span class=\"hljs-number\">0</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>);  <span class=\"hljs-comment\">//吸顶状态更新</span><br>      &#125;, <span class=\"hljs-literal\">true</span>  <span class=\"hljs-comment\">//Rax中屏蔽了冒泡事件，需要在捕获阶段监听事件</span><br>    );<br>  &#125;, []);  <br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabbar</span> <span class=\"hljs-attr\">className</span>=`<span class=\"hljs-attr\">tabbar</span> $&#123;<span class=\"hljs-attr\">isFixed</span> ? &quot;<span class=\"hljs-attr\">tabbar--fixed</span>&quot; <span class=\"hljs-attr\">:</span> <span class=\"hljs-attr\">null</span>&#125;` <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;tabbar&quot;</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.tabbar</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: sticky;  <span class=\"hljs-comment\">/* 粘性定位 */</span><br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>  ...  <span class=\"hljs-comment\">/* 未吸顶样式 */</span><br>&#125;<br><br><span class=\"hljs-selector-class\">.abbar--fixed</span> &#123;<br>  ...  <span class=\"hljs-comment\">/* 吸顶样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>虽然完美还原了视觉效果，但是一个简单的吸附判断需要添加滚动监听和状态机，对页面性能影响不小。并且还遇到了小坑：沉浸式 <em>TitleBar</em> 通过监听页面滚动切换效果，给了页面一个滚动层级，导致无法监听到元素的 <em>scrollTop</em> 属性，需要 Hack 处理。复盘的时候使用 <em>IntersectionObserver</em> 重构了一下，通过监听 Tabbar 元素与容器元素之间的交叉状态判断是否吸顶。看起来逼格提升了一个档次，代码如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Tabbar</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (containerRef.current &amp;&amp; tabbarRef.current) &#123;<br>      handleFixed(containerRef.current, tabbarRef.current);<br>    &#125;<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">const</span> handleFixed = <span class=\"hljs-function\">(<span class=\"hljs-params\">containerEle, tabbarEle</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span> &#123;<br>      entries.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (entry.isIntersecting) &#123;<br>          tabbarEle.setAttribute(<span class=\"hljs-string\">&#x27;class&#x27;</span>, <span class=\"hljs-string\">&#x27;tabbar--fixed&#x27;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          tabbarEle.setAttribute(<span class=\"hljs-string\">&#x27;class&#x27;</span>, <span class=\"hljs-string\">&#x27;tabbar--unfixed&#x27;</span>);<br>        &#125;<br>      &#125;)<br>    &#125;, &#123;<br>      <span class=\"hljs-attr\">threshold</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">//元素完全可见时触发回调函数</span><br>    &#125;);<br>    observer.observe(containerEle); <span class=\"hljs-comment\">//开始观察</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;containerRef&#125;</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;container&quot;</span> &gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabbar</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;tabbarRef&#125;</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.container</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: fixed;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.tabbar--fixed</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: fixed;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>  ...  <span class=\"hljs-comment\">/* 吸顶样式 */</span><br>&#125;<br><br><span class=\"hljs-selector-class\">.tabbar--unfixed</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: relative;<br>  ...  <span class=\"hljs-comment\">/* 未吸顶样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>看起来代码更烦了，但实际上可操作性更好。不用通过命令式地计算父子元素间的相对距离判断是否相交，而是声明式地把判断依据交给底层 API 实现。从 scroll 到 IntersectionObserver，性能也提升了不少。由于监听 scroll 事件密集发生，计算量很大，容易造成性能问题（套个节流函数 →_→）；而 IntersectionObserver 则是通过回调实现，只在临界计算一次，所以性能比较好。</p>\n<h3 id=\"电梯导航\"><a href=\"#电梯导航\" class=\"headerlink\" title=\"电梯导航\"></a>电梯导航</h3><p><img  src=\"https://pic.izhaoo.com/20210801222344.gif\"  ><span class=\"image-caption\">电梯效果</span></p>\n<p>不久，视觉同学提议将导航改成电梯导航，没问题……</p>\n<p>电梯导航可以拆成两块逻辑：1、点击导航项滑动至对应模块顶部。2、页面滚动时判断视口内的模块并切换导航。</p>\n<p>滑动模块：点击事件发生时调用 <code>window.scrollTo()</code> 方法平滑页面，平滑高度通过 <code>getElementById(id).offsetTop</code> 获取。</p>\n<p>切换导航：切入正题，使用 <strong>IntersectionObserver</strong> 监听模块元素和根元素（root）的可视状态，组合 <strong>isIntersecting</strong>（是否进入视口）和<strong>intersectionRatio</strong>（进入视口的比例）判断模块全部进入视口时切换 Tab。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> tabMap = [<span class=\"hljs-string\">&#x27;raider&#x27;</span>, <span class=\"hljs-string\">&#x27;show&#x27;</span>, <span class=\"hljs-string\">&#x27;poi&#x27;</span>];<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Main</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [tab, setTab] = useState(<span class=\"hljs-string\">&#x27;raider&#x27;</span>);<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> tabEle = tabMap.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> <span class=\"hljs-built_in\">document</span>.getElementById(item));  <span class=\"hljs-comment\">//获取DOM</span><br>    handleElevator(tabEle);<br>  &#125;, [])<br><br>  <span class=\"hljs-keyword\">const</span> handleElevator = <span class=\"hljs-function\">(<span class=\"hljs-params\">tabEle</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span> &#123;<br>      entries.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (entry.isIntersecting &amp;&amp; entry.intersectionRatio === <span class=\"hljs-number\">1</span>) &#123;  <span class=\"hljs-comment\">//当模块全部滑入页面时</span><br>          setTab(entry.target.id);  <span class=\"hljs-comment\">//切换Tab</span><br>        &#125;<br>      &#125;);<br>    &#125;)<br>    tabEle.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> observer.observe(item));  <span class=\"hljs-comment\">//遍历Tab设置监听</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">const</span> handleClick = <span class=\"hljs-function\">(<span class=\"hljs-params\">id</span>) =&gt;</span> &#123;<br>    setTab(id)<br>    <span class=\"hljs-built_in\">window</span>.scrollTo(&#123;<br>      <span class=\"hljs-attr\">top</span>: <span class=\"hljs-built_in\">document</span>.getElementById(id).offsetTop,  <span class=\"hljs-comment\">//点击Tab项滑动至对应模块顶部</span><br>      <span class=\"hljs-attr\">behavior</span>: <span class=\"hljs-string\">&#x27;smooth&#x27;</span>  <span class=\"hljs-comment\">//平滑效果</span><br>    &#125;);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabbar</span> <span class=\"hljs-attr\">tab</span>=<span class=\"hljs-string\">&#123;tab&#125;</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> handleClick(id)&#125; /&gt;</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RaiderGroup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;raider&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ShowGroup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;show&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">PoiGroup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;poi&quot;</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h3><p>同理，判断图片进入可视区后将 <em>src</em> 中的占位图替换为 <em>data-src</em> 中的真实地址即可。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Lazyload</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> imagesEle = <span class=\"hljs-built_in\">document</span>.getElementsByClassName(<span class=\"hljs-string\">&quot;image-lazyload&quot;</span>);<br>    <span class=\"hljs-keyword\">const</span> containerEle = getElementById(<span class=\"hljs-string\">&quot;container&quot;</span>);<br>    handleLazyload(imagesEle, containerEle);<br>  &#125;, [])<br><br>  <span class=\"hljs-keyword\">const</span> handleLazyload = <span class=\"hljs-function\">(<span class=\"hljs-params\">imagesEle, containerEle</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span>&#123;<br>      entries.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (item.isIntersecting) &#123;<br>          item.target.src = item.target.getAttribute(<span class=\"hljs-string\">&quot;data-src&quot;</span>);  <span class=\"hljs-comment\">//替换真实图片</span><br>          observer.unobserve(item.target);  <span class=\"hljs-comment\">//取消监听</span><br>        &#125;<br>      &#125;)<br>    &#125;, &#123;<br>      <span class=\"hljs-attr\">root</span>: containerEle<br>    &#125;);<br>    imagesEle.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> observer.observe(item));  <span class=\"hljs-comment\">//遍历图片设置监听</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;image-lazyload&quot;</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;image-lazyload&quot;</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;image-lazyload&quot;</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span></span><br><span class=\"xml\">      ...</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"无限加载\"><a href=\"#无限加载\" class=\"headerlink\" title=\"无限加载\"></a>无限加载</h3><p>同理，判断页面划到底部时（Loading 进入视口时），获取数据并插入，可以设置预加载高度提前加载。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">LoadMore</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [data, setData] = useState([])<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> loadingEle = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;loading&quot;</span>);<br>    handleLoadMore(loadingEle);<br>  &#125;, [])<br><br>  <span class=\"hljs-keyword\">const</span> handleLoadMore = <span class=\"hljs-function\">(<span class=\"hljs-params\">loadingEle, preload</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span>&#123;<br>      entries.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (entry.isIntersecting) &#123;  <span class=\"hljs-comment\">//Loading进入视口时，即划到底部时</span><br>          fetchData();  <span class=\"hljs-comment\">//获取数据</span><br>        &#125;<br>      &#125;)<br>    &#125;, &#123;<br>      <span class=\"hljs-attr\">rootMargin</span>: <span class=\"hljs-string\">`0px 0px <span class=\"hljs-subst\">$&#123;preload&#125;</span>px 0px`</span>, <span class=\"hljs-comment\">// 提前加载高度</span><br>    &#125;);<br>    observer.observe(loadingEle);  <span class=\"hljs-comment\">//设置监听</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">const</span> fetchData = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> get(...);<br>    <span class=\"hljs-keyword\">if</span> (res.isSuccess) &#123;<br>      setData(data.concat(res.data));  <span class=\"hljs-comment\">//插入数据</span><br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123;data &amp;&amp; data.length &gt; 0 &amp;&amp; data.map(item =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> /&gt;</span>)&#125;  &#123;/* 渲染元素 */&#125;</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Loading</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;loading&quot;</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"曝光埋点\"><a href=\"#曝光埋点\" class=\"headerlink\" title=\"曝光埋点\"></a>曝光埋点</h3><p>同理，需要判断元素全部进入可视区域时触发。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Exposure</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> expEle = <span class=\"hljs-built_in\">document</span>.getElementsByClassName(<span class=\"hljs-string\">&quot;need-exp&quot;</span>);<br>    handleExposure(expEle);<br>  &#125;, [])<br><br>  <span class=\"hljs-keyword\">const</span> handleExposure = <span class=\"hljs-function\">(<span class=\"hljs-params\">expEle</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span>&#123;<br>      entries.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (item.intersectionRatio === <span class=\"hljs-number\">1</span>) &#123;  <span class=\"hljs-comment\">//元素全部进入可视区域时</span><br>          ...  <span class=\"hljs-comment\">//曝光逻辑</span><br>          observer.unobserve(item.target);  <span class=\"hljs-comment\">//取消监听</span><br>        &#125;<br>      &#125;)<br>    &#125;, &#123;<br>      <span class=\"hljs-attr\">threshold</span>: <span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\">//当元素全部进入可视区时触发</span><br>    &#125;);<br>    expEle.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> observer.observe(item));  <span class=\"hljs-comment\">//遍历元素设置监听</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;need-exp&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;need-exp&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;need-exp&quot;</span> /&gt;</span></span><br><span class=\"xml\">      ...</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"滚动动画\"><a href=\"#滚动动画\" class=\"headerlink\" title=\"滚动动画\"></a>滚动动画</h3><p><img  src=\"https://pic.izhaoo.com/20210803223246.gif\"  ><span class=\"image-caption\">滚动效果</span></p>\n<p>之前业务需要轮播图自适应图片高度，勉强还原了视觉效果。但是可以看到效果并不是最佳，自适应动画是在图片切换完成后才触发的，并没有实现跟手。</p>\n","more":"<h3 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\">IntersectionObserver</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry\">IntersectionObserver Entry</a></p>\n<blockquote>\n<p><em>IntersectionObserver</em> 用于异步观察目标元素与父元素可视状态。</p>\n</blockquote>\n<p>polyfill: tnpm install intersection-observer</p>\n<p><strong>base</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(callback, options);<br><br>observer.observe();  <span class=\"hljs-comment\">//开始监听目标元素</span><br>observer.unobserve();  <span class=\"hljs-comment\">//取消监听目标元素</span><br>observer.takeRecords();  <span class=\"hljs-comment\">//返回所以观察目标的entries对象数组</span><br>observer.disconnect();  <span class=\"hljs-comment\">//停止所有监听</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>callback</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span> &#123;<br>  entries.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =&gt;</span> &#123; <br>    <span class=\"hljs-built_in\">console</span>.log(entry.isIntersecting);  <span class=\"hljs-comment\">//目标元素进入可见区域或离开可见区域</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>isIntersecting: 目标元素进入可视区域或离开可见区域</li>\n<li>intersectionRatio: 目标元素在可视区域的比例</li>\n<li>intersectionRect: 目标元素与根元素的相交区域</li>\n<li>boundingClientRect: 目标元素的边界区域，同 <em>getBoundingClientRect()</em></li>\n<li>rootBounds: 返回交叉区域观察者中的根</li>\n<li>target: 触发时的目标元素</li>\n<li>time: 触发时的时间戳</li>\n</ul>\n<p><strong>options</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(callback, &#123;<br>  <span class=\"hljs-attr\">root</span>: <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;container&quot;</span>),  <span class=\"hljs-comment\">//父容器为container</span><br>  <span class=\"hljs-attr\">rootMargin</span>: <span class=\"hljs-string\">&quot;10px, 10px, 10px, 10px&quot;</span>,  <span class=\"hljs-comment\">//父容器内缩10px为计算边界</span><br>  <span class=\"hljs-attr\">threshold</span>: <span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\">//较差比例为100%时触发</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>root: 监听对象的父元素，未指定则默认为根元素（root）</li>\n<li>rootMargin: 计算时的边界偏移量，可以放大/缩小计算容器</li>\n<li>threshold: 监听对象与父元素交叉比例触发阈值（0~1）</li>\n</ul>\n<h3 id=\"吸顶吸底\"><a href=\"#吸顶吸底\" class=\"headerlink\" title=\"吸顶吸底\"></a>吸顶吸底</h3><p><img  src=\"https://pic.izhaoo.com/20210801222344gif.gif\"  ><span class=\"image-caption\">吸顶效果</span></p>\n<p>最近的一个业务需求中需要实现 TabBar 吸顶能力。对于简单的吸顶，我们直接用 <code>position: sticky;</code> 即可。但是视觉同学要求在吸顶的时候 TabBar 的样式也做相应的变化，这就需要我们去监听吸顶状态。通过监听滚动事件，计算父子元素的相对距离，从而判读是否吸顶，代码如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Tabbar</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [isFixed, setIsFixed] = useState(<span class=\"hljs-literal\">false</span>);<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<br>      <span class=\"hljs-string\">&quot;scroll&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">const</span> rect = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;tabbar&quot;</span>) &amp;&amp; <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;tabbar&quot;</span>).getBoundingClientRect();  <span class=\"hljs-comment\">//获取元素高度</span><br>        setIsFixed(rect.top &lt;= <span class=\"hljs-number\">0</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>);  <span class=\"hljs-comment\">//吸顶状态更新</span><br>      &#125;, <span class=\"hljs-literal\">true</span>  <span class=\"hljs-comment\">//Rax中屏蔽了冒泡事件，需要在捕获阶段监听事件</span><br>    );<br>  &#125;, []);  <br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabbar</span> <span class=\"hljs-attr\">className</span>=`<span class=\"hljs-attr\">tabbar</span> $&#123;<span class=\"hljs-attr\">isFixed</span> ? &quot;<span class=\"hljs-attr\">tabbar--fixed</span>&quot; <span class=\"hljs-attr\">:</span> <span class=\"hljs-attr\">null</span>&#125;` <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;tabbar&quot;</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.tabbar</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: sticky;  <span class=\"hljs-comment\">/* 粘性定位 */</span><br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>  ...  <span class=\"hljs-comment\">/* 未吸顶样式 */</span><br>&#125;<br><br><span class=\"hljs-selector-class\">.abbar--fixed</span> &#123;<br>  ...  <span class=\"hljs-comment\">/* 吸顶样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>虽然完美还原了视觉效果，但是一个简单的吸附判断需要添加滚动监听和状态机，对页面性能影响不小。并且还遇到了小坑：沉浸式 <em>TitleBar</em> 通过监听页面滚动切换效果，给了页面一个滚动层级，导致无法监听到元素的 <em>scrollTop</em> 属性，需要 Hack 处理。复盘的时候使用 <em>IntersectionObserver</em> 重构了一下，通过监听 Tabbar 元素与容器元素之间的交叉状态判断是否吸顶。看起来逼格提升了一个档次，代码如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Tabbar</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (containerRef.current &amp;&amp; tabbarRef.current) &#123;<br>      handleFixed(containerRef.current, tabbarRef.current);<br>    &#125;<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">const</span> handleFixed = <span class=\"hljs-function\">(<span class=\"hljs-params\">containerEle, tabbarEle</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span> &#123;<br>      entries.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (entry.isIntersecting) &#123;<br>          tabbarEle.setAttribute(<span class=\"hljs-string\">&#x27;class&#x27;</span>, <span class=\"hljs-string\">&#x27;tabbar--fixed&#x27;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          tabbarEle.setAttribute(<span class=\"hljs-string\">&#x27;class&#x27;</span>, <span class=\"hljs-string\">&#x27;tabbar--unfixed&#x27;</span>);<br>        &#125;<br>      &#125;)<br>    &#125;, &#123;<br>      <span class=\"hljs-attr\">threshold</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">//元素完全可见时触发回调函数</span><br>    &#125;);<br>    observer.observe(containerEle); <span class=\"hljs-comment\">//开始观察</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;containerRef&#125;</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;container&quot;</span> &gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabbar</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;tabbarRef&#125;</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.container</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: fixed;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.tabbar--fixed</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: fixed;<br>  <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;<br>  ...  <span class=\"hljs-comment\">/* 吸顶样式 */</span><br>&#125;<br><br><span class=\"hljs-selector-class\">.tabbar--unfixed</span> &#123;<br>  <span class=\"hljs-attribute\">position</span>: relative;<br>  ...  <span class=\"hljs-comment\">/* 未吸顶样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>看起来代码更烦了，但实际上可操作性更好。不用通过命令式地计算父子元素间的相对距离判断是否相交，而是声明式地把判断依据交给底层 API 实现。从 scroll 到 IntersectionObserver，性能也提升了不少。由于监听 scroll 事件密集发生，计算量很大，容易造成性能问题（套个节流函数 →_→）；而 IntersectionObserver 则是通过回调实现，只在临界计算一次，所以性能比较好。</p>\n<h3 id=\"电梯导航\"><a href=\"#电梯导航\" class=\"headerlink\" title=\"电梯导航\"></a>电梯导航</h3><p><img  src=\"https://pic.izhaoo.com/20210801222344.gif\"  ><span class=\"image-caption\">电梯效果</span></p>\n<p>不久，视觉同学提议将导航改成电梯导航，没问题……</p>\n<p>电梯导航可以拆成两块逻辑：1、点击导航项滑动至对应模块顶部。2、页面滚动时判断视口内的模块并切换导航。</p>\n<p>滑动模块：点击事件发生时调用 <code>window.scrollTo()</code> 方法平滑页面，平滑高度通过 <code>getElementById(id).offsetTop</code> 获取。</p>\n<p>切换导航：切入正题，使用 <strong>IntersectionObserver</strong> 监听模块元素和根元素（root）的可视状态，组合 <strong>isIntersecting</strong>（是否进入视口）和<strong>intersectionRatio</strong>（进入视口的比例）判断模块全部进入视口时切换 Tab。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">const</span> tabMap = [<span class=\"hljs-string\">&#x27;raider&#x27;</span>, <span class=\"hljs-string\">&#x27;show&#x27;</span>, <span class=\"hljs-string\">&#x27;poi&#x27;</span>];<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Main</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [tab, setTab] = useState(<span class=\"hljs-string\">&#x27;raider&#x27;</span>);<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> tabEle = tabMap.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> <span class=\"hljs-built_in\">document</span>.getElementById(item));  <span class=\"hljs-comment\">//获取DOM</span><br>    handleElevator(tabEle);<br>  &#125;, [])<br><br>  <span class=\"hljs-keyword\">const</span> handleElevator = <span class=\"hljs-function\">(<span class=\"hljs-params\">tabEle</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span> &#123;<br>      entries.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (entry.isIntersecting &amp;&amp; entry.intersectionRatio === <span class=\"hljs-number\">1</span>) &#123;  <span class=\"hljs-comment\">//当模块全部滑入页面时</span><br>          setTab(entry.target.id);  <span class=\"hljs-comment\">//切换Tab</span><br>        &#125;<br>      &#125;);<br>    &#125;)<br>    tabEle.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> observer.observe(item));  <span class=\"hljs-comment\">//遍历Tab设置监听</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">const</span> handleClick = <span class=\"hljs-function\">(<span class=\"hljs-params\">id</span>) =&gt;</span> &#123;<br>    setTab(id)<br>    <span class=\"hljs-built_in\">window</span>.scrollTo(&#123;<br>      <span class=\"hljs-attr\">top</span>: <span class=\"hljs-built_in\">document</span>.getElementById(id).offsetTop,  <span class=\"hljs-comment\">//点击Tab项滑动至对应模块顶部</span><br>      <span class=\"hljs-attr\">behavior</span>: <span class=\"hljs-string\">&#x27;smooth&#x27;</span>  <span class=\"hljs-comment\">//平滑效果</span><br>    &#125;);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tabbar</span> <span class=\"hljs-attr\">tab</span>=<span class=\"hljs-string\">&#123;tab&#125;</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> handleClick(id)&#125; /&gt;</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RaiderGroup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;raider&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ShowGroup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;show&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">PoiGroup</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;poi&quot;</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"图片懒加载\"><a href=\"#图片懒加载\" class=\"headerlink\" title=\"图片懒加载\"></a>图片懒加载</h3><p>同理，判断图片进入可视区后将 <em>src</em> 中的占位图替换为 <em>data-src</em> 中的真实地址即可。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Lazyload</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> imagesEle = <span class=\"hljs-built_in\">document</span>.getElementsByClassName(<span class=\"hljs-string\">&quot;image-lazyload&quot;</span>);<br>    <span class=\"hljs-keyword\">const</span> containerEle = getElementById(<span class=\"hljs-string\">&quot;container&quot;</span>);<br>    handleLazyload(imagesEle, containerEle);<br>  &#125;, [])<br><br>  <span class=\"hljs-keyword\">const</span> handleLazyload = <span class=\"hljs-function\">(<span class=\"hljs-params\">imagesEle, containerEle</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span>&#123;<br>      entries.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (item.isIntersecting) &#123;<br>          item.target.src = item.target.getAttribute(<span class=\"hljs-string\">&quot;data-src&quot;</span>);  <span class=\"hljs-comment\">//替换真实图片</span><br>          observer.unobserve(item.target);  <span class=\"hljs-comment\">//取消监听</span><br>        &#125;<br>      &#125;)<br>    &#125;, &#123;<br>      <span class=\"hljs-attr\">root</span>: containerEle<br>    &#125;);<br>    imagesEle.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> observer.observe(item));  <span class=\"hljs-comment\">//遍历图片设置监听</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;image-lazyload&quot;</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;image-lazyload&quot;</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;image-lazyload&quot;</span> <span class=\"hljs-attr\">data-src</span>=<span class=\"hljs-string\">&quot;...&quot;</span> /&gt;</span></span><br><span class=\"xml\">      ...</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"无限加载\"><a href=\"#无限加载\" class=\"headerlink\" title=\"无限加载\"></a>无限加载</h3><p>同理，判断页面划到底部时（Loading 进入视口时），获取数据并插入，可以设置预加载高度提前加载。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">LoadMore</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> [data, setData] = useState([])<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> loadingEle = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&quot;loading&quot;</span>);<br>    handleLoadMore(loadingEle);<br>  &#125;, [])<br><br>  <span class=\"hljs-keyword\">const</span> handleLoadMore = <span class=\"hljs-function\">(<span class=\"hljs-params\">loadingEle, preload</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span>&#123;<br>      entries.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">entry</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (entry.isIntersecting) &#123;  <span class=\"hljs-comment\">//Loading进入视口时，即划到底部时</span><br>          fetchData();  <span class=\"hljs-comment\">//获取数据</span><br>        &#125;<br>      &#125;)<br>    &#125;, &#123;<br>      <span class=\"hljs-attr\">rootMargin</span>: <span class=\"hljs-string\">`0px 0px <span class=\"hljs-subst\">$&#123;preload&#125;</span>px 0px`</span>, <span class=\"hljs-comment\">// 提前加载高度</span><br>    &#125;);<br>    observer.observe(loadingEle);  <span class=\"hljs-comment\">//设置监听</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">const</span> fetchData = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> get(...);<br>    <span class=\"hljs-keyword\">if</span> (res.isSuccess) &#123;<br>      setData(data.concat(res.data));  <span class=\"hljs-comment\">//插入数据</span><br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      &#123;data &amp;&amp; data.length &gt; 0 &amp;&amp; data.map(item =&gt; <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> /&gt;</span>)&#125;  &#123;/* 渲染元素 */&#125;</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Loading</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;loading&quot;</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"曝光埋点\"><a href=\"#曝光埋点\" class=\"headerlink\" title=\"曝光埋点\"></a>曝光埋点</h3><p>同理，需要判断元素全部进入可视区域时触发。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Exposure</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> expEle = <span class=\"hljs-built_in\">document</span>.getElementsByClassName(<span class=\"hljs-string\">&quot;need-exp&quot;</span>);<br>    handleExposure(expEle);<br>  &#125;, [])<br><br>  <span class=\"hljs-keyword\">const</span> handleExposure = <span class=\"hljs-function\">(<span class=\"hljs-params\">expEle</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> observer = <span class=\"hljs-keyword\">new</span> IntersectionObserver(<span class=\"hljs-function\">(<span class=\"hljs-params\">entries</span>) =&gt;</span>&#123;<br>      entries.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (item.intersectionRatio === <span class=\"hljs-number\">1</span>) &#123;  <span class=\"hljs-comment\">//元素全部进入可视区域时</span><br>          ...  <span class=\"hljs-comment\">//曝光逻辑</span><br>          observer.unobserve(item.target);  <span class=\"hljs-comment\">//取消监听</span><br>        &#125;<br>      &#125;)<br>    &#125;, &#123;<br>      <span class=\"hljs-attr\">threshold</span>: <span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\">//当元素全部进入可视区时触发</span><br>    &#125;);<br>    expEle.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> observer.observe(item));  <span class=\"hljs-comment\">//遍历元素设置监听</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;need-exp&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;need-exp&quot;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">View</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;need-exp&quot;</span> /&gt;</span></span><br><span class=\"xml\">      ...</span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">View</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"滚动动画\"><a href=\"#滚动动画\" class=\"headerlink\" title=\"滚动动画\"></a>滚动动画</h3><p><img  src=\"https://pic.izhaoo.com/20210803223246.gif\"  ><span class=\"image-caption\">滚动效果</span></p>\n<p>之前业务需要轮播图自适应图片高度，勉强还原了视觉效果。但是可以看到效果并不是最佳，自适应动画是在图片切换完成后才触发的，并没有实现跟手。</p>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"js","path":"api/tags/js.json"}]}