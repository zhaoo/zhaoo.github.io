{"title":"CSS - BEM 命名规范","slug":"css-bem","date":"2020-11-16T08:15:30.000Z","updated":"2021-02-03T08:03:41.000Z","comments":true,"path":"api/articles/css-bem.json","realPath":"/2020/11/16/css-bem/","excerpt":"基于模块化思想的 CSS 样式命名规范。","covers":["https://pic.izhaoo.com/20201117141547.png"],"cover":"https://pic.izhaoo.com/20201112102553.jpg","content":"<p>基于模块化思想的 <code>CSS</code> 样式命名规范。</p>\n<span id=\"more\"></span>\n\n<p>&lt;封面摄于江苏·南京的老门东，这儿环境清幽，南京最值得游玩的地方。&gt;</p>\n<p>传统的 <code>CSS</code> 是没有命名空间（作用域）这一概念的，当页面模块过多时容易引起样式冲突，这时候可以为样式名称添加 <em>前缀</em> 或 <em>后缀</em> 来解决。</p>\n<p><strong>BEM</strong> 便是一套广为流传的命名约定，旨在规范化 <code>CSS</code> 样式名称，便于阅读和<del>编写</del>，以及团队协作。</p>\n<h2 id=\"规范定义\"><a href=\"#规范定义\" class=\"headerlink\" title=\"规范定义\"></a>规范定义</h2><p><code>BEM</code> 是 <code>Block（块）</code>、<code>Element（元素）</code>、<code>Modifier（修饰符）</code>的缩写，顾名思义，整套命名规范就是基于这三部分进行组合的。</p>\n<h3 id=\"词组\"><a href=\"#词组\" class=\"headerlink\" title=\"词组\"></a>词组</h3><p><strong>Block（块）</strong></p>\n<p>块是指具有独立意义的独立实体，也就是页面中的一些独立模块。例如：<code>navbar</code>、<code>article</code>、<code>toc</code>、<code>menu</code>。</p>\n<p><strong>Element（元素）</strong></p>\n<p>元素是指块的一部分，没有独立的意义，并且在语义上与其块相关。例如：<code>title</code>、<code>content</code>、<code>item</code>、<code>info</code>。</p>\n<p><strong>Modifier（修饰符）</strong></p>\n<p>修饰符是指块或元素上的标志，使用它们可以更改外观或行为。例如：<code>disabled</code>、<code>checked</code>、<code>success</code>、<code>primary</code>。</p>\n<p><img  src=\"https://pic.izhaoo.com/20201117141547.png\"  ><span class=\"image-caption\">BEM - 图示</span></p>\n<p>如上图，红色部分是块，绿色部分是元素，蓝色部分是修饰符。</p>\n<h3 id=\"连接符\"><a href=\"#连接符\" class=\"headerlink\" title=\"连接符\"></a>连接符</h3><p><strong>__（双下划线）</strong></p>\n<p>双下划线用来连接 <em>块</em> 与 <em>元素</em> 。例如：<code>article__title</code>、<code>article__content</code>、<code>article__item</code>。</p>\n<p><strong>– （双中划线）</strong></p>\n<p>双中划线用来连接 <em>元素</em> 与 <em>修饰符</em>。例如：<code>button--disabled</code>、<code>form--primary</code>、<code>toc--active</code>。</p>\n<p><strong>-（中划线）</strong></p>\n<p>中划线用来连接 <em>字符</em>，块、元素、修饰符中均可使用。例如：<code>order-form</code>、<code>progress-bar</code>、<code>theme-dark</code>。</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>组合上述部分进行命名即可，例如通常我们是这么命名的：</p>\n<pre><code class=\"html\">&lt;!-- 传统命名 --&gt;\n&lt;article class=&quot;article&quot;&gt;\n  &lt;div class=&quot;head&quot;&gt;\n    &lt;h1 class=&quot;title&quot;&gt;CSS - BEM 命名规范&lt;/h1&gt;\n    &lt;div class=&quot;info&quot;&gt;\n      &lt;span&gt;时间：十一月 16, 2020&lt;/span&gt;\n      &lt;span&gt;访客：666&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;content&quot;&gt;\n    &lt;code class=&quot;code&quot;&gt;\n      ...\n    &lt;/code&gt;\n    ...\n  &lt;/div&gt;\n&lt;/article&gt;</code></pre>\n<p>换成 <code>BEM</code> 就可以这么写：</p>\n<pre><code class=\"html\">&lt;!-- REM 命名 --&gt;\n&lt;article class=&quot;article&quot;&gt;\n  &lt;div class=&quot;article__head&quot;&gt;\n    &lt;h1 class=&quot;article__title&quot;&gt;CSS - BEM 命名规范&lt;/h1&gt;\n    &lt;div class=&quot;article__info&quot;&gt;\n      &lt;span&gt;时间：十一月 16, 2020&lt;/span&gt;\n      &lt;span&gt;访客：666&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;article__content&quot;&gt;\n    &lt;code class=&quot;article__code--highlight&quot;&gt;\n      ...\n    &lt;/code&gt;\n    ...\n  &lt;/div&gt;\n&lt;/article&gt;</code></pre>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><h3 id=\"配合-CSS-预处理器使用\"><a href=\"#配合-CSS-预处理器使用\" class=\"headerlink\" title=\"配合 CSS 预处理器使用\"></a>配合 CSS 预处理器使用</h3><p><code>BEM</code> 最大的诟病是书写太麻烦了，每个样式都像一长串蚂蚁，真是简（you）洁（chou）明（you）了（chang）呢。</p>\n<p>在 <code>Sass</code>、<code>Less</code>、<code>Stylus</code> 等 <code>CSS</code> 预处理器大行其道的现在，配合 <code>&amp;（拼接符）</code> 使用会相对简单，如下：</p>\n<pre><code class=\"css\">/* Stylus + BEM 编译前 */\n.article\n  &amp;__head\n  &amp;__title\n  &amp;__info\n  &amp;__content\n  &amp;__code\n    &amp;--highlight</code></pre>\n<pre><code class=\"css\">/* Stylus + BEM 编译后 */\n.article__head &#123;&#125;\n.article__title &#123;&#125;\n.article__info &#123;&#125;\n.article__content &#123;&#125;\n.article__code &#123;&#125;\n.article__code--highlight &#123;&#125;</code></pre>\n<p>其实在使用 <code>CSS</code> 预处理器时本身就具备了 <strong>作用域</strong> 的功能，最大的痛点解决了，使用 <code>BEM</code> duck 不必。存在即合理，<code>BEM</code> 还是有它的用武之地的。</p>\n<p>先来看看传统的 <code>CSS</code> 预处理代码。</p>\n<p><code>BEM</code> 的优势有以下方面：</p>\n<pre><code class=\"css\">/* 传统 Stylus 编译前 */\n.article\n  .head\n    .title\n    .info\n  .content\n    .code\n      &amp;.highlight</code></pre>\n<pre><code class=\"css\">/* 传统 Stylus 编译后 */\n.article &#123;&#125;\n.article .head &#123;&#125;\n.article .head .title &#123;&#125;\n.article .head .info &#123;&#125;\n.article .content &#123;&#125;\n.article .content .code &#123;&#125;\n.article .content .code.highlight &#123;&#125;</code></pre>\n<p><strong>性能</strong></p>\n<p>可以看到传统 <code>Stylus</code> 编译后的 <code>CSS</code> 样式中，选择器存在大量堆叠。而 <code>CSS</code> 引擎查找样式表时是根据 <em>从左到右</em> 的顺序去匹配规则的，这样就会浪费很多的查询性能，且开销随着嵌套层数呈几何级数递增。但是采用 <code>BEM</code> + <code>Stylus</code> 的写法一般就生成一条选择器样式，只需查询一次，做到 “指哪打哪”。</p>\n<p><strong>语义化</strong></p>\n<p>前面说到传统 <code>Stylus</code> 编译结果中存在大量重复嵌套，在 <code>debug</code> 时也是不直观的。而 <code>BEM</code> + <code>Stylus</code> 编译生成后则一目了然。</p>\n<h3 id=\"减少连接层数\"><a href=\"#减少连接层数\" class=\"headerlink\" title=\"减少连接层数\"></a>减少连接层数</h3><p><code>BEM</code> 本就麻烦，还要连接个几层，年轻人耗子尾汁。</p>\n<ul>\n<li><code>block__element--modifier</code> =&gt; 一只蚂蚁，一个头，一个身子，一个屁股。</li>\n<li><code>block__block__element_element--modifier--modifier</code> =&gt; 一只蚂蚁，许多头，许多身子，许多屁股。</li>\n</ul>\n<p><code>B + E + M</code> 足矣，没有 <code>nB + nE +nM</code> 这样的写法。必须对页面元素进行扁平化，抽象到只有一层结构。</p>\n<h3 id=\"恰当使用\"><a href=\"#恰当使用\" class=\"headerlink\" title=\"恰当使用\"></a>恰当使用</h3><p>在编写页面级组件时可以使用传统写法，毕竟无需多次复用；在编写全局组件时使用 <code>BEM</code> 规范，约定俗成便于团队维护。</p>\n<p>最后：<code>BEM</code> 看着太难受了，我一般不用。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p><a href=\"http://getbem.com/introduction/\">Introduction - BEM — Block Element Modifier</a></p>\n</blockquote>\n","more":"<p>&lt;封面摄于江苏·南京的老门东，这儿环境清幽，南京最值得游玩的地方。&gt;</p>\n<p>传统的 <code>CSS</code> 是没有命名空间（作用域）这一概念的，当页面模块过多时容易引起样式冲突，这时候可以为样式名称添加 <em>前缀</em> 或 <em>后缀</em> 来解决。</p>\n<p><strong>BEM</strong> 便是一套广为流传的命名约定，旨在规范化 <code>CSS</code> 样式名称，便于阅读和<del>编写</del>，以及团队协作。</p>\n<h2 id=\"规范定义\"><a href=\"#规范定义\" class=\"headerlink\" title=\"规范定义\"></a>规范定义</h2><p><code>BEM</code> 是 <code>Block（块）</code>、<code>Element（元素）</code>、<code>Modifier（修饰符）</code>的缩写，顾名思义，整套命名规范就是基于这三部分进行组合的。</p>\n<h3 id=\"词组\"><a href=\"#词组\" class=\"headerlink\" title=\"词组\"></a>词组</h3><p><strong>Block（块）</strong></p>\n<p>块是指具有独立意义的独立实体，也就是页面中的一些独立模块。例如：<code>navbar</code>、<code>article</code>、<code>toc</code>、<code>menu</code>。</p>\n<p><strong>Element（元素）</strong></p>\n<p>元素是指块的一部分，没有独立的意义，并且在语义上与其块相关。例如：<code>title</code>、<code>content</code>、<code>item</code>、<code>info</code>。</p>\n<p><strong>Modifier（修饰符）</strong></p>\n<p>修饰符是指块或元素上的标志，使用它们可以更改外观或行为。例如：<code>disabled</code>、<code>checked</code>、<code>success</code>、<code>primary</code>。</p>\n<p><img  src=\"https://pic.izhaoo.com/20201117141547.png\"  ><span class=\"image-caption\">BEM - 图示</span></p>\n<p>如上图，红色部分是块，绿色部分是元素，蓝色部分是修饰符。</p>\n<h3 id=\"连接符\"><a href=\"#连接符\" class=\"headerlink\" title=\"连接符\"></a>连接符</h3><p><strong>__（双下划线）</strong></p>\n<p>双下划线用来连接 <em>块</em> 与 <em>元素</em> 。例如：<code>article__title</code>、<code>article__content</code>、<code>article__item</code>。</p>\n<p><strong>– （双中划线）</strong></p>\n<p>双中划线用来连接 <em>元素</em> 与 <em>修饰符</em>。例如：<code>button--disabled</code>、<code>form--primary</code>、<code>toc--active</code>。</p>\n<p><strong>-（中划线）</strong></p>\n<p>中划线用来连接 <em>字符</em>，块、元素、修饰符中均可使用。例如：<code>order-form</code>、<code>progress-bar</code>、<code>theme-dark</code>。</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>组合上述部分进行命名即可，例如通常我们是这么命名的：</p>\n<pre><code class=\"html\">&lt;!-- 传统命名 --&gt;\n&lt;article class=&quot;article&quot;&gt;\n  &lt;div class=&quot;head&quot;&gt;\n    &lt;h1 class=&quot;title&quot;&gt;CSS - BEM 命名规范&lt;/h1&gt;\n    &lt;div class=&quot;info&quot;&gt;\n      &lt;span&gt;时间：十一月 16, 2020&lt;/span&gt;\n      &lt;span&gt;访客：666&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;content&quot;&gt;\n    &lt;code class=&quot;code&quot;&gt;\n      ...\n    &lt;/code&gt;\n    ...\n  &lt;/div&gt;\n&lt;/article&gt;</code></pre>\n<p>换成 <code>BEM</code> 就可以这么写：</p>\n<pre><code class=\"html\">&lt;!-- REM 命名 --&gt;\n&lt;article class=&quot;article&quot;&gt;\n  &lt;div class=&quot;article__head&quot;&gt;\n    &lt;h1 class=&quot;article__title&quot;&gt;CSS - BEM 命名规范&lt;/h1&gt;\n    &lt;div class=&quot;article__info&quot;&gt;\n      &lt;span&gt;时间：十一月 16, 2020&lt;/span&gt;\n      &lt;span&gt;访客：666&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=&quot;article__content&quot;&gt;\n    &lt;code class=&quot;article__code--highlight&quot;&gt;\n      ...\n    &lt;/code&gt;\n    ...\n  &lt;/div&gt;\n&lt;/article&gt;</code></pre>\n<h2 id=\"一些建议\"><a href=\"#一些建议\" class=\"headerlink\" title=\"一些建议\"></a>一些建议</h2><h3 id=\"配合-CSS-预处理器使用\"><a href=\"#配合-CSS-预处理器使用\" class=\"headerlink\" title=\"配合 CSS 预处理器使用\"></a>配合 CSS 预处理器使用</h3><p><code>BEM</code> 最大的诟病是书写太麻烦了，每个样式都像一长串蚂蚁，真是简（you）洁（chou）明（you）了（chang）呢。</p>\n<p>在 <code>Sass</code>、<code>Less</code>、<code>Stylus</code> 等 <code>CSS</code> 预处理器大行其道的现在，配合 <code>&amp;（拼接符）</code> 使用会相对简单，如下：</p>\n<pre><code class=\"css\">/* Stylus + BEM 编译前 */\n.article\n  &amp;__head\n  &amp;__title\n  &amp;__info\n  &amp;__content\n  &amp;__code\n    &amp;--highlight</code></pre>\n<pre><code class=\"css\">/* Stylus + BEM 编译后 */\n.article__head &#123;&#125;\n.article__title &#123;&#125;\n.article__info &#123;&#125;\n.article__content &#123;&#125;\n.article__code &#123;&#125;\n.article__code--highlight &#123;&#125;</code></pre>\n<p>其实在使用 <code>CSS</code> 预处理器时本身就具备了 <strong>作用域</strong> 的功能，最大的痛点解决了，使用 <code>BEM</code> duck 不必。存在即合理，<code>BEM</code> 还是有它的用武之地的。</p>\n<p>先来看看传统的 <code>CSS</code> 预处理代码。</p>\n<p><code>BEM</code> 的优势有以下方面：</p>\n<pre><code class=\"css\">/* 传统 Stylus 编译前 */\n.article\n  .head\n    .title\n    .info\n  .content\n    .code\n      &amp;.highlight</code></pre>\n<pre><code class=\"css\">/* 传统 Stylus 编译后 */\n.article &#123;&#125;\n.article .head &#123;&#125;\n.article .head .title &#123;&#125;\n.article .head .info &#123;&#125;\n.article .content &#123;&#125;\n.article .content .code &#123;&#125;\n.article .content .code.highlight &#123;&#125;</code></pre>\n<p><strong>性能</strong></p>\n<p>可以看到传统 <code>Stylus</code> 编译后的 <code>CSS</code> 样式中，选择器存在大量堆叠。而 <code>CSS</code> 引擎查找样式表时是根据 <em>从左到右</em> 的顺序去匹配规则的，这样就会浪费很多的查询性能，且开销随着嵌套层数呈几何级数递增。但是采用 <code>BEM</code> + <code>Stylus</code> 的写法一般就生成一条选择器样式，只需查询一次，做到 “指哪打哪”。</p>\n<p><strong>语义化</strong></p>\n<p>前面说到传统 <code>Stylus</code> 编译结果中存在大量重复嵌套，在 <code>debug</code> 时也是不直观的。而 <code>BEM</code> + <code>Stylus</code> 编译生成后则一目了然。</p>\n<h3 id=\"减少连接层数\"><a href=\"#减少连接层数\" class=\"headerlink\" title=\"减少连接层数\"></a>减少连接层数</h3><p><code>BEM</code> 本就麻烦，还要连接个几层，年轻人耗子尾汁。</p>\n<ul>\n<li><code>block__element--modifier</code> =&gt; 一只蚂蚁，一个头，一个身子，一个屁股。</li>\n<li><code>block__block__element_element--modifier--modifier</code> =&gt; 一只蚂蚁，许多头，许多身子，许多屁股。</li>\n</ul>\n<p><code>B + E + M</code> 足矣，没有 <code>nB + nE +nM</code> 这样的写法。必须对页面元素进行扁平化，抽象到只有一层结构。</p>\n<h3 id=\"恰当使用\"><a href=\"#恰当使用\" class=\"headerlink\" title=\"恰当使用\"></a>恰当使用</h3><p>在编写页面级组件时可以使用传统写法，毕竟无需多次复用；在编写全局组件时使用 <code>BEM</code> 规范，约定俗成便于团队维护。</p>\n<p>最后：<code>BEM</code> 看着太难受了，我一般不用。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><blockquote>\n<p><a href=\"http://getbem.com/introduction/\">Introduction - BEM — Block Element Modifier</a></p>\n</blockquote>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"}]}