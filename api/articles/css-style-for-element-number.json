{"title":"CSS - 元素数量选择器","slug":"css-style-for-element-number","date":"2020-11-16T11:40:46.000Z","updated":"2021-02-28T13:57:00.000Z","comments":true,"path":"api/articles/css-style-for-element-number.json","realPath":"/2020/11/16/css-style-for-element-number/","excerpt":"根据元素数量匹配样式，解决 向前选择 和 重复元素 问题。","covers":["https://pic.izhaoo.com/20201116195907.png"],"cover":"https://pic.izhaoo.com/20201112102133.jpg","content":"<p>根据元素数量匹配样式，解决 <strong>向前选择</strong> 和 <strong>重复元素</strong> 问题。</p>\n<span id=\"more\"></span>\n\n<p>&lt;封面摄于江苏·南京的先锋书店，打卡网红书店。&gt;</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><h3 id=\"场景一\"><a href=\"#场景一\" class=\"headerlink\" title=\"场景一\"></a>场景一</h3><p>今天在给 <code>hexo-theme-zhaoo</code> 写 <strong>文章目录 (toc)</strong>，有个需求：当目录不存在时，不显示标题。</p>\n<p><img  src=\"https://pic.izhaoo.com/20201116195907.png\"  ><span class=\"image-caption\">文章目录</span></p>\n<p>抽象出 <code>DOM</code> 结构：</p>\n<pre><code class=\"html\">&lt;aside class=&quot;toc-wrap&quot;&gt;\n  &lt;h3 class=&quot;toc-title&quot;&gt;文章目录：&lt;/h3&gt;\n  &lt;ol class=&quot;toc&quot;&gt;...&lt;/ol&gt;\n&lt;/aside&gt;</code></pre>\n<p>最直接的思路是匹配 <code>.toc</code>，若该元素不存在，则将它前面的 <code>.toc-title</code> 隐藏。但是 <code>CSS</code> 没有向前选择，因为这样回引起回流。</p>\n<p>需要想个办法曲线救国，其实借助它们的公共父元素 <code>.toc-wrap</code> 即可解决，若 <code>.toc-wrap</code> 只有一个子元素则将它隐藏。如下：</p>\n<pre><code class=\"css\">.toc-wrap\n  &amp; &gt; :only-child\n    display none</code></pre>\n<p>🌰 很简单，却值得思考一下，<code>CSS</code> 真的不能 “向前选择” 嘛？</p>\n<h3 id=\"场景二\"><a href=\"#场景二\" class=\"headerlink\" title=\"场景二\"></a>场景二</h3><p>在构建 <em>栅格化</em> 布局的时候，早期的 <code>BootStrap</code> 使用了大量的重复代码，类似这样：</p>\n<pre><code class=\"css\">@media (min-width: 768px) &#123;\n  .col-md-1 &#123; flex: 0 0 8.33333%; max-width: 8.33333%; &#125;\n  .col-md-2 &#123; flex: 0 0 16.6667%; max-width: 16.6667%; &#125;\n  .col-md-3 &#123; flex: 0 0 25%; max-width: 25%; &#125;\n  .col-md-4 &#123; flex: 0 0 33.3333%; max-width: 33.3333%; &#125;\n  .col-md-5 &#123; flex: 0 0 41.6667%; max-width: 41.6667%; &#125;\n  .col-md-6 &#123; flex: 0 0 50%; max-width: 50%; &#125;\n  .col-md-7 &#123; flex: 0 0 58.3333%; max-width: 58.3333%; &#125;\n  .col-md-8 &#123; flex: 0 0 66.6667%; max-width: 66.6667%; &#125;\n  .col-md-9 &#123; flex: 0 0 75%; max-width: 75%; &#125;\n  .col-md-10 &#123; flex: 0 0 83.3333%; max-width: 83.3333%; &#125;\n  .col-md-11 &#123; flex: 0 0 91.6667%; max-width: 91.6667%; &#125;\n  .col-md-12 &#123; flex: 0 0 100%; max-width: 100%; &#125;\n&#125;\n@media (min-width: 992px) &#123;\n  .col-lg-1 &#123; flex: 0 0 8.33333%; max-width: 8.33333%; &#125;\n  .col-lg-2 &#123; flex: 0 0 16.6667%; max-width: 16.6667%; &#125;\n  .col-lg-3 &#123; flex: 0 0 25%; max-width: 25%; &#125;\n  .col-lg-4 &#123; flex: 0 0 33.3333%; max-width: 33.3333%; &#125;\n  .col-lg-5 &#123; flex: 0 0 41.6667%; max-width: 41.6667%; &#125;\n  .col-lg-6 &#123; flex: 0 0 50%; max-width: 50%; &#125;\n  .col-lg-7 &#123; flex: 0 0 58.3333%; max-width: 58.3333%; &#125;\n  .col-lg-8 &#123; flex: 0 0 66.6667%; max-width: 66.6667%; &#125;\n  .col-lg-9 &#123; flex: 0 0 75%; max-width: 75%; &#125;\n  .col-lg-10 &#123; flex: 0 0 83.3333%; max-width: 83.3333%; &#125;\n  .col-lg-11 &#123; flex: 0 0 91.6667%; max-width: 91.6667%; &#125;\n  .col-lg-12 &#123; flex: 0 0 100%; max-width: 100%; &#125;\n&#125;</code></pre>\n<p>在使用 <code>CSS 预处理器</code> 后可以简化成下面这样，但是编译后依然存在大量重复代码。</p>\n<pre><code class=\"css\">for $i in 1 .. 12\n  .col-&#123;$i&#125;\n    col-attr round(($i * 100 / 12) %, 6)\n@media (min-width 576px)\n  for $i in 1 .. 12\n    .col-sm-&#123;$i&#125;\n      col-attr round(($i * 100 / 12) %, 6)\n@media (min-width 768px)\n  for $i in 1 .. 12\n    .col-md-&#123;$i&#125;\n      col-attr round(($i * 100 / 12) %, 6)\n@media (min-width 992px)\n  for $i in 1 .. 12\n    .col-lg-&#123;$i&#125;\n      col-attr round(($i * 100 / 12) %, 6)\n@media (min-width 1200px)\n  for $i in 1 .. 12\n    .col-xl-&#123;$i&#125;\n      col-attr round(($i * 100 / 12) %, 6)</code></pre>\n<p>灵魂拷问，<code>CSS</code> 真的不适合处理 “重复元素” 的场景嘛？</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>一些 <code>CSS3</code> 选择器：</p>\n<ul>\n<li><code>&gt;</code> 子元素选择器</li>\n<li><code>+</code> 相邻元素选择器</li>\n<li><code>~</code> 兄弟元素选择器</li>\n</ul>\n<p>一些 <code>CSS3</code> 伪类：</p>\n<ul>\n<li><code>:only-child</code> 父元素的唯一子元素</li>\n<li><code>:first-child</code> 父元素的第一个子元素</li>\n<li><code>:last-child</code> 父元素的最后一个子元素</li>\n<li><code>:nth-child(n)</code> 父元素的第 N 个子元素</li>\n<li><code>:nth-last-child(n)</code> 父元素的倒数第 N 个子元素</li>\n<li><code>:nth-child(xn+y)</code> 父元素的第 xN + y 个子元素</li>\n<li><code>:nth-last-child(xn+y)</code> 父元素的倒数第 xN + y 个子元素</li>\n</ul>\n<h2 id=\"化学反应\"><a href=\"#化学反应\" class=\"headerlink\" title=\"化学反应\"></a>化学反应</h2><p>结合以上的 <em>选择器</em> 和 <em>伪类</em> 可以产生一些有趣的 “化学反应”，基于元素的数量来匹配样式。</p>\n<p><code>DOM</code> 结构如下：</p>\n<pre><code class=\"html\">&lt;ul&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n  &lt;li&gt;3&lt;/li&gt;\n  ...\n&lt;/ul&gt;</code></pre>\n<h3 id=\"Andre-Luis\"><a href=\"#Andre-Luis\" class=\"headerlink\" title=\"André Luís\"></a>André Luís</h3><p><code>André Luís</code> 方案如下：</p>\n<pre><code class=\"css\">/* 只有一个元素时 */\nul&gt;li:nth-child(1):nth-last-child(1) &#123; width: 100%; &#125;  /* 匹配第一个元素 */\nul&gt;li:only-child &#123; width: 100%; &#125;  /* 匹配第一个元素 */</code></pre>\n<pre><code class=\"css\">/* 有且仅有两个元素时 */\nul&gt;li:nth-child(1):nth-last-child(2),  /* 匹配第一个元素 */\nul&gt;li:nth-child(2):nth-last-child(1) &#123;  /* 匹配第二个元素 */\n    width: 50%;  /* 合起来就是匹配所有元素 */\n&#125;</code></pre>\n<pre><code class=\"css\">/* 有且仅有三个元素时 */\nul&gt;li:nth-child(1):nth-last-child(3),\nul&gt;li:nth-child(2):nth-last-child(2),\nul&gt;li:nth-child(3):nth-last-child(1) &#123;\n    width: 33.3333%;\n&#125;</code></pre>\n<blockquote>\n<p><a href=\"http://andr3.net/blog/post/142\">Clever lists with CSS3 selectors</a></p>\n</blockquote>\n<h3 id=\"Lea-Verou\"><a href=\"#Lea-Verou\" class=\"headerlink\" title=\"Lea Verou\"></a>Lea Verou</h3><p>上述方案存在一个问题，当元素数量过多时，还是存在大量的重复选择器。升级版的 <code>Lea Verou</code> 方案只需两行固定的选择器即可解决。</p>\n<pre><code class=\"css\">/* 只有一个元素时 */\nul&gt;li:first-child:nth-last-child(1) &#123;\n    width: 100%;\n&#125;</code></pre>\n<pre><code class=\"css\">/* 有且仅有两个元素时 */\nul&gt;li:first-child:nth-last-child(2),\nul&gt;li:first-child:nth-last-child(2) ~ li &#123;\n    width: 50%;\n&#125;</code></pre>\n<pre><code class=\"css\">/* 有且仅有三个元素时 */\nul&gt;li:first-child:nth-last-child(3),  /* 匹配第一个元素 */\nul&gt;li:first-child:nth-last-child(3) ~ li &#123;  /* 匹配除第一个元素外的所有元素 */\n    width: 33.3333%;\n&#125;</code></pre>\n<blockquote>\n<p><a href=\"https://lea.verou.me/2011/01/styling-children-based-on-their-number-with-css3/\">Styling elements based on sibling count</a></p>\n</blockquote>\n<h3 id=\"再改进\"><a href=\"#再改进\" class=\"headerlink\" title=\"再改进\"></a>再改进</h3><p>不确定元素数量时：</p>\n<pre><code class=\"css\">/* 大于三个元素时 */\nul&gt;li:first-child:nth-last-child(n+3),\nul&gt;li:first-child:nth-last-child(n+3) ~ li &#123;\n  width: calc(100% / n);\n&#125;</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上述方法即可解决 <strong>向前选择</strong> 和 <strong>重复元素</strong> 这两个问题，遇到实际场景时借助父元素灵活运用即可。</p>\n","more":"<p>&lt;封面摄于江苏·南京的先锋书店，打卡网红书店。&gt;</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><h3 id=\"场景一\"><a href=\"#场景一\" class=\"headerlink\" title=\"场景一\"></a>场景一</h3><p>今天在给 <code>hexo-theme-zhaoo</code> 写 <strong>文章目录 (toc)</strong>，有个需求：当目录不存在时，不显示标题。</p>\n<p><img  src=\"https://pic.izhaoo.com/20201116195907.png\"  ><span class=\"image-caption\">文章目录</span></p>\n<p>抽象出 <code>DOM</code> 结构：</p>\n<pre><code class=\"html\">&lt;aside class=&quot;toc-wrap&quot;&gt;\n  &lt;h3 class=&quot;toc-title&quot;&gt;文章目录：&lt;/h3&gt;\n  &lt;ol class=&quot;toc&quot;&gt;...&lt;/ol&gt;\n&lt;/aside&gt;</code></pre>\n<p>最直接的思路是匹配 <code>.toc</code>，若该元素不存在，则将它前面的 <code>.toc-title</code> 隐藏。但是 <code>CSS</code> 没有向前选择，因为这样回引起回流。</p>\n<p>需要想个办法曲线救国，其实借助它们的公共父元素 <code>.toc-wrap</code> 即可解决，若 <code>.toc-wrap</code> 只有一个子元素则将它隐藏。如下：</p>\n<pre><code class=\"css\">.toc-wrap\n  &amp; &gt; :only-child\n    display none</code></pre>\n<p>🌰 很简单，却值得思考一下，<code>CSS</code> 真的不能 “向前选择” 嘛？</p>\n<h3 id=\"场景二\"><a href=\"#场景二\" class=\"headerlink\" title=\"场景二\"></a>场景二</h3><p>在构建 <em>栅格化</em> 布局的时候，早期的 <code>BootStrap</code> 使用了大量的重复代码，类似这样：</p>\n<pre><code class=\"css\">@media (min-width: 768px) &#123;\n  .col-md-1 &#123; flex: 0 0 8.33333%; max-width: 8.33333%; &#125;\n  .col-md-2 &#123; flex: 0 0 16.6667%; max-width: 16.6667%; &#125;\n  .col-md-3 &#123; flex: 0 0 25%; max-width: 25%; &#125;\n  .col-md-4 &#123; flex: 0 0 33.3333%; max-width: 33.3333%; &#125;\n  .col-md-5 &#123; flex: 0 0 41.6667%; max-width: 41.6667%; &#125;\n  .col-md-6 &#123; flex: 0 0 50%; max-width: 50%; &#125;\n  .col-md-7 &#123; flex: 0 0 58.3333%; max-width: 58.3333%; &#125;\n  .col-md-8 &#123; flex: 0 0 66.6667%; max-width: 66.6667%; &#125;\n  .col-md-9 &#123; flex: 0 0 75%; max-width: 75%; &#125;\n  .col-md-10 &#123; flex: 0 0 83.3333%; max-width: 83.3333%; &#125;\n  .col-md-11 &#123; flex: 0 0 91.6667%; max-width: 91.6667%; &#125;\n  .col-md-12 &#123; flex: 0 0 100%; max-width: 100%; &#125;\n&#125;\n@media (min-width: 992px) &#123;\n  .col-lg-1 &#123; flex: 0 0 8.33333%; max-width: 8.33333%; &#125;\n  .col-lg-2 &#123; flex: 0 0 16.6667%; max-width: 16.6667%; &#125;\n  .col-lg-3 &#123; flex: 0 0 25%; max-width: 25%; &#125;\n  .col-lg-4 &#123; flex: 0 0 33.3333%; max-width: 33.3333%; &#125;\n  .col-lg-5 &#123; flex: 0 0 41.6667%; max-width: 41.6667%; &#125;\n  .col-lg-6 &#123; flex: 0 0 50%; max-width: 50%; &#125;\n  .col-lg-7 &#123; flex: 0 0 58.3333%; max-width: 58.3333%; &#125;\n  .col-lg-8 &#123; flex: 0 0 66.6667%; max-width: 66.6667%; &#125;\n  .col-lg-9 &#123; flex: 0 0 75%; max-width: 75%; &#125;\n  .col-lg-10 &#123; flex: 0 0 83.3333%; max-width: 83.3333%; &#125;\n  .col-lg-11 &#123; flex: 0 0 91.6667%; max-width: 91.6667%; &#125;\n  .col-lg-12 &#123; flex: 0 0 100%; max-width: 100%; &#125;\n&#125;</code></pre>\n<p>在使用 <code>CSS 预处理器</code> 后可以简化成下面这样，但是编译后依然存在大量重复代码。</p>\n<pre><code class=\"css\">for $i in 1 .. 12\n  .col-&#123;$i&#125;\n    col-attr round(($i * 100 / 12) %, 6)\n@media (min-width 576px)\n  for $i in 1 .. 12\n    .col-sm-&#123;$i&#125;\n      col-attr round(($i * 100 / 12) %, 6)\n@media (min-width 768px)\n  for $i in 1 .. 12\n    .col-md-&#123;$i&#125;\n      col-attr round(($i * 100 / 12) %, 6)\n@media (min-width 992px)\n  for $i in 1 .. 12\n    .col-lg-&#123;$i&#125;\n      col-attr round(($i * 100 / 12) %, 6)\n@media (min-width 1200px)\n  for $i in 1 .. 12\n    .col-xl-&#123;$i&#125;\n      col-attr round(($i * 100 / 12) %, 6)</code></pre>\n<p>灵魂拷问，<code>CSS</code> 真的不适合处理 “重复元素” 的场景嘛？</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>一些 <code>CSS3</code> 选择器：</p>\n<ul>\n<li><code>&gt;</code> 子元素选择器</li>\n<li><code>+</code> 相邻元素选择器</li>\n<li><code>~</code> 兄弟元素选择器</li>\n</ul>\n<p>一些 <code>CSS3</code> 伪类：</p>\n<ul>\n<li><code>:only-child</code> 父元素的唯一子元素</li>\n<li><code>:first-child</code> 父元素的第一个子元素</li>\n<li><code>:last-child</code> 父元素的最后一个子元素</li>\n<li><code>:nth-child(n)</code> 父元素的第 N 个子元素</li>\n<li><code>:nth-last-child(n)</code> 父元素的倒数第 N 个子元素</li>\n<li><code>:nth-child(xn+y)</code> 父元素的第 xN + y 个子元素</li>\n<li><code>:nth-last-child(xn+y)</code> 父元素的倒数第 xN + y 个子元素</li>\n</ul>\n<h2 id=\"化学反应\"><a href=\"#化学反应\" class=\"headerlink\" title=\"化学反应\"></a>化学反应</h2><p>结合以上的 <em>选择器</em> 和 <em>伪类</em> 可以产生一些有趣的 “化学反应”，基于元素的数量来匹配样式。</p>\n<p><code>DOM</code> 结构如下：</p>\n<pre><code class=\"html\">&lt;ul&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n  &lt;li&gt;3&lt;/li&gt;\n  ...\n&lt;/ul&gt;</code></pre>\n<h3 id=\"Andre-Luis\"><a href=\"#Andre-Luis\" class=\"headerlink\" title=\"André Luís\"></a>André Luís</h3><p><code>André Luís</code> 方案如下：</p>\n<pre><code class=\"css\">/* 只有一个元素时 */\nul&gt;li:nth-child(1):nth-last-child(1) &#123; width: 100%; &#125;  /* 匹配第一个元素 */\nul&gt;li:only-child &#123; width: 100%; &#125;  /* 匹配第一个元素 */</code></pre>\n<pre><code class=\"css\">/* 有且仅有两个元素时 */\nul&gt;li:nth-child(1):nth-last-child(2),  /* 匹配第一个元素 */\nul&gt;li:nth-child(2):nth-last-child(1) &#123;  /* 匹配第二个元素 */\n    width: 50%;  /* 合起来就是匹配所有元素 */\n&#125;</code></pre>\n<pre><code class=\"css\">/* 有且仅有三个元素时 */\nul&gt;li:nth-child(1):nth-last-child(3),\nul&gt;li:nth-child(2):nth-last-child(2),\nul&gt;li:nth-child(3):nth-last-child(1) &#123;\n    width: 33.3333%;\n&#125;</code></pre>\n<blockquote>\n<p><a href=\"http://andr3.net/blog/post/142\">Clever lists with CSS3 selectors</a></p>\n</blockquote>\n<h3 id=\"Lea-Verou\"><a href=\"#Lea-Verou\" class=\"headerlink\" title=\"Lea Verou\"></a>Lea Verou</h3><p>上述方案存在一个问题，当元素数量过多时，还是存在大量的重复选择器。升级版的 <code>Lea Verou</code> 方案只需两行固定的选择器即可解决。</p>\n<pre><code class=\"css\">/* 只有一个元素时 */\nul&gt;li:first-child:nth-last-child(1) &#123;\n    width: 100%;\n&#125;</code></pre>\n<pre><code class=\"css\">/* 有且仅有两个元素时 */\nul&gt;li:first-child:nth-last-child(2),\nul&gt;li:first-child:nth-last-child(2) ~ li &#123;\n    width: 50%;\n&#125;</code></pre>\n<pre><code class=\"css\">/* 有且仅有三个元素时 */\nul&gt;li:first-child:nth-last-child(3),  /* 匹配第一个元素 */\nul&gt;li:first-child:nth-last-child(3) ~ li &#123;  /* 匹配除第一个元素外的所有元素 */\n    width: 33.3333%;\n&#125;</code></pre>\n<blockquote>\n<p><a href=\"https://lea.verou.me/2011/01/styling-children-based-on-their-number-with-css3/\">Styling elements based on sibling count</a></p>\n</blockquote>\n<h3 id=\"再改进\"><a href=\"#再改进\" class=\"headerlink\" title=\"再改进\"></a>再改进</h3><p>不确定元素数量时：</p>\n<pre><code class=\"css\">/* 大于三个元素时 */\nul&gt;li:first-child:nth-last-child(n+3),\nul&gt;li:first-child:nth-last-child(n+3) ~ li &#123;\n  width: calc(100% / n);\n&#125;</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过上述方法即可解决 <strong>向前选择</strong> 和 <strong>重复元素</strong> 这两个问题，遇到实际场景时借助父元素灵活运用即可。</p>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"}]}