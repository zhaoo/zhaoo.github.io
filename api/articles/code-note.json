{"title":"搬砖笔记","slug":"code-note","date":"2021-07-31T16:19:16.000Z","updated":"2021-08-29T12:17:25.750Z","comments":true,"path":"api/articles/code-note.json","realPath":"/2021/08/01/code-note/","excerpt":"搬砖杂记，前端是门手艺活，我家狗看多了都会写。","covers":["https://pic.izhaoo.com/20210801001641.jpg","https://pic.izhaoo.com/20210801001546.jpg","https://pic.izhaoo.com/20210815123034.jpg"],"cover":"https://pic.izhaoo.com/20210714214358.jpg","content":"<p>搬砖杂记，前端是门手艺活，我家狗看多了都会写。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"子组件监听滚动\"><a href=\"#子组件监听滚动\" class=\"headerlink\" title=\"子组件监听滚动\"></a>子组件监听滚动</h3><p>React 子组件生命周期中 <em>addEventListener</em> 的时候，需要将第三个参数设置为 <code>true</code>。因为 React 对事件做了合成处理，子组件滚动是捕获事件，父组件滚动是冒泡事件。addEventListener 第三个参数默认为 <em>false</em>，只监听冒泡事件，所以子组件的捕获事件默认监听不到，需要改成 <em>true</em>。</p>\n<pre><code class=\"javascript\">useEffect(() =&gt; &#123;\n  window.addEventListener(&quot;scroll&quot;, (e) =&gt; &#123;\n    const &#123;top, bottom, left, right&#125; = e.target.getBoundingClientRect();\n  &#125;, true);\n&#125;, []);</code></pre>\n<h3 id=\"浮层禁止背景滚动\"><a href=\"#浮层禁止背景滚动\" class=\"headerlink\" title=\"浮层禁止背景滚动\"></a>浮层禁止背景滚动</h3><p><em>rxpi-pad</em> 浮动面板有个坑，面板滚动事件和背景滚动事件做了绑定，通过 <em>autoLockScrolling</em> 属性只能全部开启或关闭。一般我们需要让背景禁止滚动，而面板内容可以滚动，只能 hack 一下：</p>\n<pre><code class=\"javascript\">useEffect(() =&gt; &#123;\n  const body = document.body;\n  if (visible) &#123;\n    body.style.overflow = &quot;hidden&quot;;\n  &#125; else &#123;\n    body.style.overflow = &quot;visible&quot;;\n  &#125;\n&#125;, [visible]);</code></pre>\n<h3 id=\"在数组指定项插入数组\"><a href=\"#在数组指定项插入数组\" class=\"headerlink\" title=\"在数组指定项插入数组\"></a>在数组指定项插入数组</h3><p>JavaScript 中的 <em>splice</em> 只能在数组中删除或插入一个元素，而不能插入数组，可借助 <strong>apply</strong> 赋能。</p>\n<pre><code class=\"javascript\">const arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; \nconst arr2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]; \narr2.unshift(1, 1);\nArray.prototype.splice.apply(arr1, arr2);\nconsole.log(arr1)  // [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;c&quot;]</code></pre>\n<p>相当于：</p>\n<pre><code class=\"javascript\">const arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; \nconst arr2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;];\narr1.splice(1, 1, &#39;1&#39;, &#39;2&#39;, &#39;3’);</code></pre>\n<h3 id=\"标签换行截断\"><a href=\"#标签换行截断\" class=\"headerlink\" title=\"标签换行截断\"></a>标签换行截断</h3><p>标签组都会设置一个宽度，当标签过多或过长时，最后一项会被“砍掉”，很尴尬。给容器设置一个固定高度和换行，将超出部分顶到第二行隐藏，干掉总比破掉好。</p>\n<p><img  src=\"https://pic.izhaoo.com/20210801001641.jpg\"  ><span class=\"image-caption\">超出截断</span></p>\n<p><img  src=\"https://pic.izhaoo.com/20210801001546.jpg\"  ><span class=\"image-caption\">超出隐藏</span></p>\n<pre><code class=\"css\">.tags-wrapper &#123;\n  height: 40rpx;  /* 标签高度 */\n  flex-wrap: wrap;\n  overflow: hidden;\n&#125;</code></pre>\n<h3 id=\"iphoneX-适配\"><a href=\"#iphoneX-适配\" class=\"headerlink\" title=\"iphoneX 适配\"></a>iphoneX 适配</h3><p>iphoneX 这破手机就是反人类，丑得要死，给前端小哥哥烦的要死，适配 iphoneX 也是老生常谈的事。一次业务中遇到个非主流坑，淘宝端 iphoneX 底部会多出一块白条，其他客户端和机型都没问题。通过层级定位后发现这个白条是在容器外部产生的，甚至可能是客户端处。最后师兄一句 <code>height: 100vh</code> 解决。</p>\n<p>这不是 iphoneX 适配标准解法吗？？？</p>\n<p>666！！！</p>\n<p><strong>方案一</strong></p>\n<p><em>适用于版本 &gt;= IOS11</em></p>\n<p>在 HTML 头部 <em>viewport</em> 标签中，将 <em>viewport-fit</em> 值设置为 <code>contain</code>。（视口完全包含网页内容，头部位置固定元素将被包含在ios11的安全区域内）</p>\n<p>在 CSS 中使用以下布局常数，将布局限定在安全容器内：</p>\n<ul>\n<li>constant(safe-area-inset-top)</li>\n<li>constant(safe-area-inset-bottom)</li>\n<li>constant(safe-area-inset-left)</li>\n<li>constant(safe-area-inset-right)</li>\n</ul>\n<pre><code class=\"css\">.container &#123;\n  padding: constant(safe-area-inset-top) constant(safe-area-inset-right) constant(safe-area-inset-bottom) constant(safe-area-inset-left);\n&#125;</code></pre>\n<p><strong>方案二</strong></p>\n<pre><code class=\"css\">position: absolute;\ntop: ???;\nbottom: ???;</code></pre>\n<p>绝对定位一把梭，不服就干，怕过谁。劳资的代码只有 <strong>absolute</strong>！</p>\n<h3 id=\"useState-同步获取最新状态值\"><a href=\"#useState-同步获取最新状态值\" class=\"headerlink\" title=\"useState 同步获取最新状态值\"></a>useState 同步获取最新状态值</h3><p>React 中 <code>this.setState()</code> 的第二个参数可以传入一个回调函数用于获取实时更新后的状态值，例如：</p>\n<pre><code class=\"javascript\">this.setState(&#123;\n  username: &#39;兆兆&#39;\n&#125;, () =&gt; &#123;\n  console.log(this.state.username);\n&#125;);</code></pre>\n<p>但是 Hooks 中的 useState 官方却把它干掉了，我们可以结合 useState、useRef、useEffect 来模拟一个：</p>\n<pre><code class=\"js\">const useCallbackState = (state) =&gt; &#123;\n  const ref = useRef();\n  const [data, setData] = useState(state);\n\n  useEffect(() =&gt; &#123;\n    ref.current &amp;&amp; ref.current(data);\n  &#125;, [data]);\n\n  return [data, function (val, callback) &#123;\n    ref.current = callback;\n    setData(val);\n  &#125;];\n&#125;</code></pre>\n<p>似乎蕴含了点哲学：</p>\n<ul>\n<li>useState：异步存储数据</li>\n<li>useRef：同步缓存最新数据</li>\n<li>useEffect：监测数据状态变更</li>\n</ul>\n<h3 id=\"Taro-点击穿透\"><a href=\"#Taro-点击穿透\" class=\"headerlink\" title=\"Taro 点击穿透\"></a>Taro 点击穿透</h3><p>在使用 Taro 开发小程序时，被点击穿透坑了。背景如图，在一个评论浮层中点击输入框，点击事件会穿透到底部的浮层上，直接把浮层关了。Taro 文档汇总说明需要使用 <code>e.stopPropagation()</code> 代替小程序中的 <code>catchEvent</code>，然并卵。查看源码后发现，Taro 在编译过程中会直接将 <code>e.stopPropagation()</code> 转换为 <code>catchEvent</code> 打到 <code>wxml</code> 上，这套路…后来发现，在自定义组件中，这条逻辑不生效。解决方案是只需要在自定义组件外层再套一层 <code>View</code>，并加上 <code>e.stopPropagation()</code> 即可。</p>\n<p><img  src=\"https://pic.izhaoo.com/20210815123034.jpg\"  ><span class=\"image-caption\">评论浮层</span></p>\n<h3 id=\"forEach-异步调用\"><a href=\"#forEach-异步调用\" class=\"headerlink\" title=\"forEach 异步调用\"></a>forEach 异步调用</h3><p>最近开发的小程序发布评论提审被驳回了，需要接入安全风控中心。整个流程如下：1、首先通过 LeanCloud 接口获取获取存储在 BaaS 上的评论数据。2、遍历评论列表，将每条评论内容上传至云函数。3、通过审核接口获取内容敏感程度，剔除不正能量的内容。过程中多次使用 <code>forEach</code> 遍历，并且在遍历过程中调用了异步接口。<code>forEach</code> 本身是同步的，但是在遍历中如果调用了异步代码，并不会阻塞进程，很有可能还没拿到结果就执行了后续的代码。有如下解决方案：</p>\n<p><strong>内部同步，外部异步</strong></p>\n<pre><code class=\"javascript\">comments.forEach(async (item, index) =&gt;&#123;\n  await secCheck(item);\n  filterRes(item);\n  return item;\n&#125;)</code></pre>\n<p><strong>内部异步，外部同步</strong></p>\n<pre><code class=\"javascript\">const asyncFunc = [];\ncomments.forEach((item, index) =&gt;&#123;\n  asyncFun.push(secCheck(item));\n  filterRes(item);\n&#125;)\nPromise.all(asyncFun).then((res) =&gt; &#123;\n  return res;\n&#125;);</code></pre>\n<p><strong>内部外部都同步</strong></p>\n<pre><code class=\"javascript\">Promise.all(\n  comments.map( item =&gt;&#123;\n    return new Promise(async (resolve, reject) =&gt;&#123;\n      await secCheck(item);\n      filterRes(item);\n      resolve();\n    &#125;)\n  &#125;)\n).then((res) =&gt;&#123;\n  return res;\n&#125;)</code></pre>\n<h3 id=\"常用-Hooks-封装\"><a href=\"#常用-Hooks-封装\" class=\"headerlink\" title=\"常用 Hooks 封装\"></a>常用 Hooks 封装</h3><p><strong>缓存状态</strong></p>\n<p>获取上一次执行的状态。</p>\n<pre><code class=\"javascript\">const usePrevious = (value: any) =&gt; &#123;\n  const ref = useRef();\n  useEffect(() =&gt; &#123;\n    ref.current = value;\n  &#125;, [value]);\n  return ref.current;\n&#125;</code></pre>\n<p><strong>批量设置状态</strong></p>\n<p>像 <code>this.setState()</code> 一样批量设置状态。</p>\n<pre><code class=\"javascript\">const useSet = (initState: any) =&gt; &#123;\n  return useReducer((state: any, newState: any) =&gt; &#123;\n    return &#123; ...state, ...newState &#125;;\n  &#125;, initState);\n&#125;</code></pre>\n<p><strong>节流</strong></p>\n<pre><code class=\"javascript\">const useThrottle = (fn: any, delay: number, dep = []) =&gt; &#123;\n  const &#123; current &#125; = useRef(&#123; fn, timer: null &#125;);\n  useEffect(\n    function () &#123;\n      current.fn = fn;\n    &#125;,\n    [fn],\n  );\n\n  return useCallback(function f(...args: any) &#123;\n    if (!current.timer) &#123;\n      current.timer = setTimeout(() =&gt; &#123;\n        delete current.timer;\n      &#125;, delay);\n      current.fn(...args);\n    &#125;\n  &#125;, dep);\n&#125;</code></pre>\n","more":"<h3 id=\"子组件监听滚动\"><a href=\"#子组件监听滚动\" class=\"headerlink\" title=\"子组件监听滚动\"></a>子组件监听滚动</h3><p>React 子组件生命周期中 <em>addEventListener</em> 的时候，需要将第三个参数设置为 <code>true</code>。因为 React 对事件做了合成处理，子组件滚动是捕获事件，父组件滚动是冒泡事件。addEventListener 第三个参数默认为 <em>false</em>，只监听冒泡事件，所以子组件的捕获事件默认监听不到，需要改成 <em>true</em>。</p>\n<pre><code class=\"javascript\">useEffect(() =&gt; &#123;\n  window.addEventListener(&quot;scroll&quot;, (e) =&gt; &#123;\n    const &#123;top, bottom, left, right&#125; = e.target.getBoundingClientRect();\n  &#125;, true);\n&#125;, []);</code></pre>\n<h3 id=\"浮层禁止背景滚动\"><a href=\"#浮层禁止背景滚动\" class=\"headerlink\" title=\"浮层禁止背景滚动\"></a>浮层禁止背景滚动</h3><p><em>rxpi-pad</em> 浮动面板有个坑，面板滚动事件和背景滚动事件做了绑定，通过 <em>autoLockScrolling</em> 属性只能全部开启或关闭。一般我们需要让背景禁止滚动，而面板内容可以滚动，只能 hack 一下：</p>\n<pre><code class=\"javascript\">useEffect(() =&gt; &#123;\n  const body = document.body;\n  if (visible) &#123;\n    body.style.overflow = &quot;hidden&quot;;\n  &#125; else &#123;\n    body.style.overflow = &quot;visible&quot;;\n  &#125;\n&#125;, [visible]);</code></pre>\n<h3 id=\"在数组指定项插入数组\"><a href=\"#在数组指定项插入数组\" class=\"headerlink\" title=\"在数组指定项插入数组\"></a>在数组指定项插入数组</h3><p>JavaScript 中的 <em>splice</em> 只能在数组中删除或插入一个元素，而不能插入数组，可借助 <strong>apply</strong> 赋能。</p>\n<pre><code class=\"javascript\">const arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; \nconst arr2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]; \narr2.unshift(1, 1);\nArray.prototype.splice.apply(arr1, arr2);\nconsole.log(arr1)  // [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;c&quot;]</code></pre>\n<p>相当于：</p>\n<pre><code class=\"javascript\">const arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; \nconst arr2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;];\narr1.splice(1, 1, &#39;1&#39;, &#39;2&#39;, &#39;3’);</code></pre>\n<h3 id=\"标签换行截断\"><a href=\"#标签换行截断\" class=\"headerlink\" title=\"标签换行截断\"></a>标签换行截断</h3><p>标签组都会设置一个宽度，当标签过多或过长时，最后一项会被“砍掉”，很尴尬。给容器设置一个固定高度和换行，将超出部分顶到第二行隐藏，干掉总比破掉好。</p>\n<p><img  src=\"https://pic.izhaoo.com/20210801001641.jpg\"  ><span class=\"image-caption\">超出截断</span></p>\n<p><img  src=\"https://pic.izhaoo.com/20210801001546.jpg\"  ><span class=\"image-caption\">超出隐藏</span></p>\n<pre><code class=\"css\">.tags-wrapper &#123;\n  height: 40rpx;  /* 标签高度 */\n  flex-wrap: wrap;\n  overflow: hidden;\n&#125;</code></pre>\n<h3 id=\"iphoneX-适配\"><a href=\"#iphoneX-适配\" class=\"headerlink\" title=\"iphoneX 适配\"></a>iphoneX 适配</h3><p>iphoneX 这破手机就是反人类，丑得要死，给前端小哥哥烦的要死，适配 iphoneX 也是老生常谈的事。一次业务中遇到个非主流坑，淘宝端 iphoneX 底部会多出一块白条，其他客户端和机型都没问题。通过层级定位后发现这个白条是在容器外部产生的，甚至可能是客户端处。最后师兄一句 <code>height: 100vh</code> 解决。</p>\n<p>这不是 iphoneX 适配标准解法吗？？？</p>\n<p>666！！！</p>\n<p><strong>方案一</strong></p>\n<p><em>适用于版本 &gt;= IOS11</em></p>\n<p>在 HTML 头部 <em>viewport</em> 标签中，将 <em>viewport-fit</em> 值设置为 <code>contain</code>。（视口完全包含网页内容，头部位置固定元素将被包含在ios11的安全区域内）</p>\n<p>在 CSS 中使用以下布局常数，将布局限定在安全容器内：</p>\n<ul>\n<li>constant(safe-area-inset-top)</li>\n<li>constant(safe-area-inset-bottom)</li>\n<li>constant(safe-area-inset-left)</li>\n<li>constant(safe-area-inset-right)</li>\n</ul>\n<pre><code class=\"css\">.container &#123;\n  padding: constant(safe-area-inset-top) constant(safe-area-inset-right) constant(safe-area-inset-bottom) constant(safe-area-inset-left);\n&#125;</code></pre>\n<p><strong>方案二</strong></p>\n<pre><code class=\"css\">position: absolute;\ntop: ???;\nbottom: ???;</code></pre>\n<p>绝对定位一把梭，不服就干，怕过谁。劳资的代码只有 <strong>absolute</strong>！</p>\n<h3 id=\"useState-同步获取最新状态值\"><a href=\"#useState-同步获取最新状态值\" class=\"headerlink\" title=\"useState 同步获取最新状态值\"></a>useState 同步获取最新状态值</h3><p>React 中 <code>this.setState()</code> 的第二个参数可以传入一个回调函数用于获取实时更新后的状态值，例如：</p>\n<pre><code class=\"javascript\">this.setState(&#123;\n  username: &#39;兆兆&#39;\n&#125;, () =&gt; &#123;\n  console.log(this.state.username);\n&#125;);</code></pre>\n<p>但是 Hooks 中的 useState 官方却把它干掉了，我们可以结合 useState、useRef、useEffect 来模拟一个：</p>\n<pre><code class=\"js\">const useCallbackState = (state) =&gt; &#123;\n  const ref = useRef();\n  const [data, setData] = useState(state);\n\n  useEffect(() =&gt; &#123;\n    ref.current &amp;&amp; ref.current(data);\n  &#125;, [data]);\n\n  return [data, function (val, callback) &#123;\n    ref.current = callback;\n    setData(val);\n  &#125;];\n&#125;</code></pre>\n<p>似乎蕴含了点哲学：</p>\n<ul>\n<li>useState：异步存储数据</li>\n<li>useRef：同步缓存最新数据</li>\n<li>useEffect：监测数据状态变更</li>\n</ul>\n<h3 id=\"Taro-点击穿透\"><a href=\"#Taro-点击穿透\" class=\"headerlink\" title=\"Taro 点击穿透\"></a>Taro 点击穿透</h3><p>在使用 Taro 开发小程序时，被点击穿透坑了。背景如图，在一个评论浮层中点击输入框，点击事件会穿透到底部的浮层上，直接把浮层关了。Taro 文档汇总说明需要使用 <code>e.stopPropagation()</code> 代替小程序中的 <code>catchEvent</code>，然并卵。查看源码后发现，Taro 在编译过程中会直接将 <code>e.stopPropagation()</code> 转换为 <code>catchEvent</code> 打到 <code>wxml</code> 上，这套路…后来发现，在自定义组件中，这条逻辑不生效。解决方案是只需要在自定义组件外层再套一层 <code>View</code>，并加上 <code>e.stopPropagation()</code> 即可。</p>\n<p><img  src=\"https://pic.izhaoo.com/20210815123034.jpg\"  ><span class=\"image-caption\">评论浮层</span></p>\n<h3 id=\"forEach-异步调用\"><a href=\"#forEach-异步调用\" class=\"headerlink\" title=\"forEach 异步调用\"></a>forEach 异步调用</h3><p>最近开发的小程序发布评论提审被驳回了，需要接入安全风控中心。整个流程如下：1、首先通过 LeanCloud 接口获取获取存储在 BaaS 上的评论数据。2、遍历评论列表，将每条评论内容上传至云函数。3、通过审核接口获取内容敏感程度，剔除不正能量的内容。过程中多次使用 <code>forEach</code> 遍历，并且在遍历过程中调用了异步接口。<code>forEach</code> 本身是同步的，但是在遍历中如果调用了异步代码，并不会阻塞进程，很有可能还没拿到结果就执行了后续的代码。有如下解决方案：</p>\n<p><strong>内部同步，外部异步</strong></p>\n<pre><code class=\"javascript\">comments.forEach(async (item, index) =&gt;&#123;\n  await secCheck(item);\n  filterRes(item);\n  return item;\n&#125;)</code></pre>\n<p><strong>内部异步，外部同步</strong></p>\n<pre><code class=\"javascript\">const asyncFunc = [];\ncomments.forEach((item, index) =&gt;&#123;\n  asyncFun.push(secCheck(item));\n  filterRes(item);\n&#125;)\nPromise.all(asyncFun).then((res) =&gt; &#123;\n  return res;\n&#125;);</code></pre>\n<p><strong>内部外部都同步</strong></p>\n<pre><code class=\"javascript\">Promise.all(\n  comments.map( item =&gt;&#123;\n    return new Promise(async (resolve, reject) =&gt;&#123;\n      await secCheck(item);\n      filterRes(item);\n      resolve();\n    &#125;)\n  &#125;)\n).then((res) =&gt;&#123;\n  return res;\n&#125;)</code></pre>\n<h3 id=\"常用-Hooks-封装\"><a href=\"#常用-Hooks-封装\" class=\"headerlink\" title=\"常用 Hooks 封装\"></a>常用 Hooks 封装</h3><p><strong>缓存状态</strong></p>\n<p>获取上一次执行的状态。</p>\n<pre><code class=\"javascript\">const usePrevious = (value: any) =&gt; &#123;\n  const ref = useRef();\n  useEffect(() =&gt; &#123;\n    ref.current = value;\n  &#125;, [value]);\n  return ref.current;\n&#125;</code></pre>\n<p><strong>批量设置状态</strong></p>\n<p>像 <code>this.setState()</code> 一样批量设置状态。</p>\n<pre><code class=\"javascript\">const useSet = (initState: any) =&gt; &#123;\n  return useReducer((state: any, newState: any) =&gt; &#123;\n    return &#123; ...state, ...newState &#125;;\n  &#125;, initState);\n&#125;</code></pre>\n<p><strong>节流</strong></p>\n<pre><code class=\"javascript\">const useThrottle = (fn: any, delay: number, dep = []) =&gt; &#123;\n  const &#123; current &#125; = useRef(&#123; fn, timer: null &#125;);\n  useEffect(\n    function () &#123;\n      current.fn = fn;\n    &#125;,\n    [fn],\n  );\n\n  return useCallback(function f(...args: any) &#123;\n    if (!current.timer) &#123;\n      current.timer = setTimeout(() =&gt; &#123;\n        delete current.timer;\n      &#125;, delay);\n      current.fn(...args);\n    &#125;\n  &#125;, dep);\n&#125;</code></pre>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"js","path":"api/tags/js.json"},{"name":"css","path":"api/tags/css.json"}]}