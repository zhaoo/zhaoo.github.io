{"title":"算法笔记","slug":"algorithm-note","date":"2019-12-28T12:12:35.000Z","updated":"2021-02-03T08:02:26.000Z","comments":true,"path":"api/articles/algorithm-note.json","realPath":"/2019/12/28/algorithm-note/","excerpt":"算法选修课自学笔记。","covers":null,"cover":"https://pic.izhaoo.com/20200305030152.jpg","content":"<p>算法选修课自学笔记。</p>\n<span id=\"more\"></span>\n\n<p>&lt;封面摄于浙江·嵊州的四明山，山颠为冰雪覆盖，北欧的感觉。&gt;</p>\n<h3 id=\"分治算法\"><a href=\"#分治算法\" class=\"headerlink\" title=\"分治算法\"></a>分治算法</h3><h5 id=\"线性时间选择\"><a href=\"#线性时间选择\" class=\"headerlink\" title=\"线性时间选择\"></a>线性时间选择</h5><p>O(n)</p>\n<pre><code class=\"c++\">//随机线性选择（伪代码），O(n)\n\nint partition (Type a[], int p, int r) &#123;\n  int i = p, j = r+1\n  Type x = a[p]    //第一个元素为基准\n  while (true) &#123;\n    while (a[++i] &lt; x &amp;&amp; i &lt; r)    //左标兵向右\n    while (a[--j] &gt; x)    //右标兵向左\n    if (i &gt;= j)\n      break\n    swap(a[i], a[j])    //交换位置\n  &#125;\n  a[p] = a[j]    //第一个元素和最小数交换位置\n  a[j] = x\n  return j    //返回基准位置\n&#125;\n\nint randomizedPartition (Type a[], int p, int r) &#123;\n  int i = random(p, r)\n  swap(a[i], a[p])    //将随机元素作为基准（第一个元素）\n  return partition(a, p, r)\n&#125;\n\nType randomizedSelect(Type a[], int p, int r, int k) &#123;    //第k小个元素\n  if (p == r)    //只有一个元素\n    return a[p]\n  int i = randomizedPartition(a, p ,r)    //i为随机基准位置\n  j = i-p+1    //计算数组a[p:i]个数（左边）\n  if (k &lt;= j)\n    return randomizedSelect(a, p, i, k)    //落在左边\n  else\n    return randomizedSelect(a, i+1, r, k-j)    //落在右边\n&#125;</code></pre>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><h5 id=\"01背包问题\"><a href=\"#01背包问题\" class=\"headerlink\" title=\"01背包问题\"></a>01背包问题</h5><p>O(n)</p>\n<blockquote>\n<p>参考：<a href=\"https://yq.aliyun.com/articles/714964?spm=a2c4e.11153940.0.0.16233fa9KjyGn1&type=2\">算法题之动态规划-01背包问题</a></p>\n</blockquote>\n<pre><code class=\"c++\">void knapsack(Type v, int w, int c, int n, Type **m) &#123;     //价值，重量，容量，数量，矩阵\n  int jMax = min(w[n]-1, c)\n    for (int j = 0; j &lt;= jMax; j++)\n      m[n][j] = 0\n    for (int j = w[n]; j &lt;= c; j++)\n      m[n][j] = v[n]\n    for (int i = n-1; i &gt; 1; i==) &#123;\n      jMax = min(w[i] - 1, c)\n      for (int j = 0; j &lt;= jMax; j++)\n        m[i][j] = m[i+1][j]\n      for (int j =w [i]; j &lt;= c; j++)\n        m[i][j] = max(m[1][c], m[2][c-w[1]]+v[i])\n      m[1][c] = m[2][c]\n      if (c &gt;= w[1])\n        m[1][c] = max(m[1][c], m[2][c-w[1]]+v[1])\n    &#125;\n&#125;</code></pre>\n<pre><code class=\"javascript\">// 01背包问题，动态规划，O(n)\n\nvar knapsack = &#123;\n  getMaxValue: function (weight, value, n, w) &#123;    //各物品重量，各物品价值，物品数量，背包容量\n    var table = new Array(n)\n    for (var i = 0; i &lt; table.length; i++) &#123;\n      table[i] = new Array(w)\n      for (var j = 0; j &lt; table[i].length; j++)\n        table[i][j] = 0\n    &#125;\n    for (var i = 1; i &lt; n; i++) &#123;    //物品数量\n      for (var j = 1; j &lt; w; j++) &#123;    //背包容量\n        if (weight[i] &gt; j)\n          table[i][j] = table[i - 1][j]    //装不下(物品价值大于背包容量)\n        else\n          table[i][j] = Math.max(table[i - 1][j], table[i - 1][j - weight[i]] + value[i])    //装得下(max&#123;装，不装&#125;)\n      &#125;\n    &#125;\n    return table[n-1][w-1]\n  &#125;,\n  main: function () &#123;\n    var weight = new Array(6, 3, 5, 4, 6)\n    var value = new Array(2, 2, 6, 5, 4)\n    var n = 5,\n      w = 10\n    return this.getMaxValue(weight, value, n, w)\n  &#125;\n&#125;\nconsole.log(knapsack.main())</code></pre>\n<h3 id=\"回溯法\"><a href=\"#回溯法\" class=\"headerlink\" title=\"回溯法\"></a>回溯法</h3><h5 id=\"n皇后问题\"><a href=\"#n皇后问题\" class=\"headerlink\" title=\"n皇后问题\"></a>n皇后问题</h5><pre><code class=\"c++\">bool place(int t) &#123;\n    for (int i; i &lt; t; i++)\n    if ((x[i] == x[t]) || (abs(t-i) == abs(x[t]-x[i])))\n      return false\n  return true\n&#125;\n\nvoid backtrack(int t) &#123;\n  if (t &gt; n)\n    sum++\n  else &#123;\n    for (int i; i &lt; n; i++) &#123;\n      x[t] = i    //关键\n      if (place(t))\n        backtrack(t+1)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"javascript\">//n皇后问题，回溯法\n\nvar n = 4\nvar x = []\nfunction place(t) &#123;    //判断第t个皇后能否放在第i个位置\n  var flag = true\n  for (var j = 0; j &lt; t; j++) &#123;\n    if (x[t] === x[j] || t - j === Math.abs(x[t] - x[j])) &#123;    //判断与竖、撇捺是否有冲突\n      flag = false\n      break\n    &#125;\n  &#125;\n  return flag\n&#125;\nfunction backtrack(t) &#123;\n  if (t === n) &#123;    //当前位置到了叶节点输出一个解\n    console.log(x)\n  &#125; else &#123;\n    for (var i = 0; i &lt; n; i++) &#123;\n      x[t] = i\n      if (place(t)) &#123;\n        queen(t + 1)    //不冲突进行下一行搜索\n      &#125;\n    &#125;\n  &#125;\n&#125;\nbacktrack(0)</code></pre>\n<h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3><h5 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h5><p>O(n^2)</p>\n<p>MST性质（最小生成树定义）：假设G=(V, E)是一个连通网，U 是顶点集V的真子集。若(u, v )是一条具有最小权值的边，其中u∈U， v∈V-U，则必存在一棵包含边(u, v)的最小生成树。</p>\n<p>MST性质证明：假设G的任何一颗最小生成树都不含边(u, v)。将边(u, v)添加到G的一颗最小生成树上，将产生含有边(u, v)的圈，并且在这个圈上有一条不同于(u, v)的边(u’, v’)，使得u’∈U，v’∈V-U。将这条边(u’, v’)删去，得到G的另一颗生成树T’。因为c[u][v]&lt;=c[u’][v’]，所以T’的耗费&lt;=T的耗费。于是T’是一颗含有边(u, v)的最小生成树，与原假设矛盾，即证明MST成立。</p>\n<pre><code class=\"c++\">void prim(int n, Type **c) &#123;\n  Type lowcost[maxint]\n  int closet[maxint]\n  bool s[maxint]\n  s[1] = true\n  for (int i = 2; i &lt;= n; i++) &#123;\n    lowcost[i] = c[1][i]\n    closet[i] = 1\n    s[i] = false\n  &#125;\n  for (int i = 1; i &lt; n; i++) &#123;\n    Type min = INF\n    int j = 1\n    for (int k = 2; k &lt;= n; k++) &#123;\n      if ((lowcost[k] &lt; min) &amp;&amp; (!s[k])) &#123;\n        min = lowcost[k]\n        j = k\n      &#125;\n    &#125;\n    s[j] = true\n    for (int k = 2; k &lt;= n; k++) &#123;\n      if ((c[j][k] &lt; lowcost(k)) &amp;&amp; (!s[k])) &#123;\n        lowcost[k] = c[j][k]\n        closet[k] = j\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"javascript\">//最小生成树，prim算法（伪代码）\n\nfunction prim(int n, int u0, int c[N][N]) &#123;\n  s[u0] = true    //第一个点在U内\n  //初始化\n  for (int i; i &lt; n; i++) &#123;\n    if (i !== u0) &#123;\n      lowcost[i] = c[u0][i]    //最近权为到u0的权\n      closet[i] = u0    //最近点为u0\n      s[i] = false    //不在U内\n    &#125; else &#123;\n      lowcost[i] = 0\n    &#125;\n  &#125;\n  for (int i = 1; i &lt; n; i++) &#123;\n    int temp = INF    //权\n    int t = u0\n    for (int j = 1; j &lt; n; j++) &#123;\n      if ((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) &#123;    //不在U内且权更小\n        t = j\n        temp = lowcost[j]\n      &#125;\n    &#125;\n    if (t === u0)    //找不到最小路径点\n      break\n    s[t] = true    //加入U\n    //更新lowcost和closet\n    for (int j = 1; j &lt;= n; j++) &#123;\n      if ((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) &#123;    //不在U内且t到j的权小于最短权\n        lowcost[j] = c[t][j]\n        closest[j] = t\n      &#125;\n    &#125;\n  &#125;\n  //最小费用为lowcost之和\n&#125;</code></pre>\n<h3 id=\"排序算法比较\"><a href=\"#排序算法比较\" class=\"headerlink\" title=\"排序算法比较\"></a>排序算法比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">排序方式</th>\n<th align=\"center\">平均情况</th>\n<th align=\"center\">辅助空间</th>\n<th align=\"center\">稳定性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">冒泡排序</td>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">选择排序</td>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">插入排序</td>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">希尔排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">快速排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">归并排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">堆排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">桶排序</td>\n<td align=\"center\">O(n+c)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">基数排序</td>\n<td align=\"center\">O(nlog(r)m)</td>\n<td align=\"center\">O(r)</td>\n<td align=\"center\">稳定</td>\n</tr>\n</tbody></table>\n<h3 id=\"渐进复杂度\"><a href=\"#渐进复杂度\" class=\"headerlink\" title=\"渐进复杂度\"></a>渐进复杂度</h3><table>\n<thead>\n<tr>\n<th align=\"center\">3n<sup>2</sup>+10n</th>\n<th align=\"center\">n<sup>2</sup>/10+2<sup>n</sup></th>\n<th align=\"center\">21+1/n</th>\n<th align=\"center\">logn<sup>3</sup></th>\n<th align=\"center\">10log3<sup>n</sup></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n<td align=\"center\">O(2<sup>n</sup>)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">O(n)</td>\n</tr>\n</tbody></table>\n<p>2 &lt; logn &lt;n<sup>2/3</sup> &lt; 20n &lt; 4n<sup>2</sup> &lt; 3<sup>n</sup> &lt; n!</p>\n<ul>\n<li>f(n)的阶 &lt;= g(n)的阶    =&gt;    f(n)=O(g(n))</li>\n<li>f(n)的阶 &gt;= g(n)的阶    =&gt;    f(n)=Ω(g(n))</li>\n<li>f(n) == g(n)    =&gt;    f(n)=θ(g(n))</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><h5 id=\"算法特性\"><a href=\"#算法特性\" class=\"headerlink\" title=\"算法特性\"></a>算法特性</h5><ul>\n<li>有穷性：算法的有穷性是指算法必须能在执行有限个步骤之后终止。</li>\n<li>确定性：算法的每一步骤必须有确切的定义。</li>\n<li>可行性：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成。</li>\n<li>输入输出：有0个或多个输入，有1个或多个输出。</li>\n</ul>\n<h5 id=\"好算法标准\"><a href=\"#好算法标准\" class=\"headerlink\" title=\"好算法标准\"></a>好算法标准</h5><p><code>高效率，低存储。</code></p>\n<p>正确性、易读性、健壮性、高效性、低存储性</p>\n<h3 id=\"分支限界法\"><a href=\"#分支限界法\" class=\"headerlink\" title=\"分支限界法\"></a>分支限界法</h3><h5 id=\"分支限界法与回溯法的区别\"><a href=\"#分支限界法与回溯法的区别\" class=\"headerlink\" title=\"分支限界法与回溯法的区别\"></a>分支限界法与回溯法的区别</h5><ul>\n<li><p>二者都是在问题的解空间数上搜索问题解的算法。</p>\n</li>\n<li><p>分支限界法采用广度优先或最小耗费优先方式生成解空间；回溯法采用深度优先方式生成解空间。</p>\n</li>\n<li><p>分支界限法一般用于求最优解；回溯法一般用于求全部解。</p>\n</li>\n<li><p>分支界限法需要额外辅助空间；回溯法不需要。</p>\n</li>\n</ul>\n<h5 id=\"队列式与优先队列式的区别\"><a href=\"#队列式与优先队列式的区别\" class=\"headerlink\" title=\"队列式与优先队列式的区别\"></a>队列式与优先队列式的区别</h5><ul>\n<li>队列式：将活结点组织成一个队列，按先进先出原则选取下一个节点。</li>\n<li>优先队列式：将活结点组织成一个优先队列，按优先级最高原则选取下一个节点。</li>\n</ul>\n","more":"<p>&lt;封面摄于浙江·嵊州的四明山，山颠为冰雪覆盖，北欧的感觉。&gt;</p>\n<h3 id=\"分治算法\"><a href=\"#分治算法\" class=\"headerlink\" title=\"分治算法\"></a>分治算法</h3><h5 id=\"线性时间选择\"><a href=\"#线性时间选择\" class=\"headerlink\" title=\"线性时间选择\"></a>线性时间选择</h5><p>O(n)</p>\n<pre><code class=\"c++\">//随机线性选择（伪代码），O(n)\n\nint partition (Type a[], int p, int r) &#123;\n  int i = p, j = r+1\n  Type x = a[p]    //第一个元素为基准\n  while (true) &#123;\n    while (a[++i] &lt; x &amp;&amp; i &lt; r)    //左标兵向右\n    while (a[--j] &gt; x)    //右标兵向左\n    if (i &gt;= j)\n      break\n    swap(a[i], a[j])    //交换位置\n  &#125;\n  a[p] = a[j]    //第一个元素和最小数交换位置\n  a[j] = x\n  return j    //返回基准位置\n&#125;\n\nint randomizedPartition (Type a[], int p, int r) &#123;\n  int i = random(p, r)\n  swap(a[i], a[p])    //将随机元素作为基准（第一个元素）\n  return partition(a, p, r)\n&#125;\n\nType randomizedSelect(Type a[], int p, int r, int k) &#123;    //第k小个元素\n  if (p == r)    //只有一个元素\n    return a[p]\n  int i = randomizedPartition(a, p ,r)    //i为随机基准位置\n  j = i-p+1    //计算数组a[p:i]个数（左边）\n  if (k &lt;= j)\n    return randomizedSelect(a, p, i, k)    //落在左边\n  else\n    return randomizedSelect(a, i+1, r, k-j)    //落在右边\n&#125;</code></pre>\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><h5 id=\"01背包问题\"><a href=\"#01背包问题\" class=\"headerlink\" title=\"01背包问题\"></a>01背包问题</h5><p>O(n)</p>\n<blockquote>\n<p>参考：<a href=\"https://yq.aliyun.com/articles/714964?spm=a2c4e.11153940.0.0.16233fa9KjyGn1&type=2\">算法题之动态规划-01背包问题</a></p>\n</blockquote>\n<pre><code class=\"c++\">void knapsack(Type v, int w, int c, int n, Type **m) &#123;     //价值，重量，容量，数量，矩阵\n  int jMax = min(w[n]-1, c)\n    for (int j = 0; j &lt;= jMax; j++)\n      m[n][j] = 0\n    for (int j = w[n]; j &lt;= c; j++)\n      m[n][j] = v[n]\n    for (int i = n-1; i &gt; 1; i==) &#123;\n      jMax = min(w[i] - 1, c)\n      for (int j = 0; j &lt;= jMax; j++)\n        m[i][j] = m[i+1][j]\n      for (int j =w [i]; j &lt;= c; j++)\n        m[i][j] = max(m[1][c], m[2][c-w[1]]+v[i])\n      m[1][c] = m[2][c]\n      if (c &gt;= w[1])\n        m[1][c] = max(m[1][c], m[2][c-w[1]]+v[1])\n    &#125;\n&#125;</code></pre>\n<pre><code class=\"javascript\">// 01背包问题，动态规划，O(n)\n\nvar knapsack = &#123;\n  getMaxValue: function (weight, value, n, w) &#123;    //各物品重量，各物品价值，物品数量，背包容量\n    var table = new Array(n)\n    for (var i = 0; i &lt; table.length; i++) &#123;\n      table[i] = new Array(w)\n      for (var j = 0; j &lt; table[i].length; j++)\n        table[i][j] = 0\n    &#125;\n    for (var i = 1; i &lt; n; i++) &#123;    //物品数量\n      for (var j = 1; j &lt; w; j++) &#123;    //背包容量\n        if (weight[i] &gt; j)\n          table[i][j] = table[i - 1][j]    //装不下(物品价值大于背包容量)\n        else\n          table[i][j] = Math.max(table[i - 1][j], table[i - 1][j - weight[i]] + value[i])    //装得下(max&#123;装，不装&#125;)\n      &#125;\n    &#125;\n    return table[n-1][w-1]\n  &#125;,\n  main: function () &#123;\n    var weight = new Array(6, 3, 5, 4, 6)\n    var value = new Array(2, 2, 6, 5, 4)\n    var n = 5,\n      w = 10\n    return this.getMaxValue(weight, value, n, w)\n  &#125;\n&#125;\nconsole.log(knapsack.main())</code></pre>\n<h3 id=\"回溯法\"><a href=\"#回溯法\" class=\"headerlink\" title=\"回溯法\"></a>回溯法</h3><h5 id=\"n皇后问题\"><a href=\"#n皇后问题\" class=\"headerlink\" title=\"n皇后问题\"></a>n皇后问题</h5><pre><code class=\"c++\">bool place(int t) &#123;\n    for (int i; i &lt; t; i++)\n    if ((x[i] == x[t]) || (abs(t-i) == abs(x[t]-x[i])))\n      return false\n  return true\n&#125;\n\nvoid backtrack(int t) &#123;\n  if (t &gt; n)\n    sum++\n  else &#123;\n    for (int i; i &lt; n; i++) &#123;\n      x[t] = i    //关键\n      if (place(t))\n        backtrack(t+1)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"javascript\">//n皇后问题，回溯法\n\nvar n = 4\nvar x = []\nfunction place(t) &#123;    //判断第t个皇后能否放在第i个位置\n  var flag = true\n  for (var j = 0; j &lt; t; j++) &#123;\n    if (x[t] === x[j] || t - j === Math.abs(x[t] - x[j])) &#123;    //判断与竖、撇捺是否有冲突\n      flag = false\n      break\n    &#125;\n  &#125;\n  return flag\n&#125;\nfunction backtrack(t) &#123;\n  if (t === n) &#123;    //当前位置到了叶节点输出一个解\n    console.log(x)\n  &#125; else &#123;\n    for (var i = 0; i &lt; n; i++) &#123;\n      x[t] = i\n      if (place(t)) &#123;\n        queen(t + 1)    //不冲突进行下一行搜索\n      &#125;\n    &#125;\n  &#125;\n&#125;\nbacktrack(0)</code></pre>\n<h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3><h5 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h5><p>O(n^2)</p>\n<p>MST性质（最小生成树定义）：假设G=(V, E)是一个连通网，U 是顶点集V的真子集。若(u, v )是一条具有最小权值的边，其中u∈U， v∈V-U，则必存在一棵包含边(u, v)的最小生成树。</p>\n<p>MST性质证明：假设G的任何一颗最小生成树都不含边(u, v)。将边(u, v)添加到G的一颗最小生成树上，将产生含有边(u, v)的圈，并且在这个圈上有一条不同于(u, v)的边(u’, v’)，使得u’∈U，v’∈V-U。将这条边(u’, v’)删去，得到G的另一颗生成树T’。因为c[u][v]&lt;=c[u’][v’]，所以T’的耗费&lt;=T的耗费。于是T’是一颗含有边(u, v)的最小生成树，与原假设矛盾，即证明MST成立。</p>\n<pre><code class=\"c++\">void prim(int n, Type **c) &#123;\n  Type lowcost[maxint]\n  int closet[maxint]\n  bool s[maxint]\n  s[1] = true\n  for (int i = 2; i &lt;= n; i++) &#123;\n    lowcost[i] = c[1][i]\n    closet[i] = 1\n    s[i] = false\n  &#125;\n  for (int i = 1; i &lt; n; i++) &#123;\n    Type min = INF\n    int j = 1\n    for (int k = 2; k &lt;= n; k++) &#123;\n      if ((lowcost[k] &lt; min) &amp;&amp; (!s[k])) &#123;\n        min = lowcost[k]\n        j = k\n      &#125;\n    &#125;\n    s[j] = true\n    for (int k = 2; k &lt;= n; k++) &#123;\n      if ((c[j][k] &lt; lowcost(k)) &amp;&amp; (!s[k])) &#123;\n        lowcost[k] = c[j][k]\n        closet[k] = j\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"javascript\">//最小生成树，prim算法（伪代码）\n\nfunction prim(int n, int u0, int c[N][N]) &#123;\n  s[u0] = true    //第一个点在U内\n  //初始化\n  for (int i; i &lt; n; i++) &#123;\n    if (i !== u0) &#123;\n      lowcost[i] = c[u0][i]    //最近权为到u0的权\n      closet[i] = u0    //最近点为u0\n      s[i] = false    //不在U内\n    &#125; else &#123;\n      lowcost[i] = 0\n    &#125;\n  &#125;\n  for (int i = 1; i &lt; n; i++) &#123;\n    int temp = INF    //权\n    int t = u0\n    for (int j = 1; j &lt; n; j++) &#123;\n      if ((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) &#123;    //不在U内且权更小\n        t = j\n        temp = lowcost[j]\n      &#125;\n    &#125;\n    if (t === u0)    //找不到最小路径点\n      break\n    s[t] = true    //加入U\n    //更新lowcost和closet\n    for (int j = 1; j &lt;= n; j++) &#123;\n      if ((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) &#123;    //不在U内且t到j的权小于最短权\n        lowcost[j] = c[t][j]\n        closest[j] = t\n      &#125;\n    &#125;\n  &#125;\n  //最小费用为lowcost之和\n&#125;</code></pre>\n<h3 id=\"排序算法比较\"><a href=\"#排序算法比较\" class=\"headerlink\" title=\"排序算法比较\"></a>排序算法比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">排序方式</th>\n<th align=\"center\">平均情况</th>\n<th align=\"center\">辅助空间</th>\n<th align=\"center\">稳定性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">冒泡排序</td>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">选择排序</td>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">插入排序</td>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">希尔排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">快速排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">归并排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(n)</td>\n<td align=\"center\">稳定</td>\n</tr>\n<tr>\n<td align=\"center\">堆排序</td>\n<td align=\"center\">O(nlogn)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">桶排序</td>\n<td align=\"center\">O(n+c)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">不稳定</td>\n</tr>\n<tr>\n<td align=\"center\">基数排序</td>\n<td align=\"center\">O(nlog(r)m)</td>\n<td align=\"center\">O(r)</td>\n<td align=\"center\">稳定</td>\n</tr>\n</tbody></table>\n<h3 id=\"渐进复杂度\"><a href=\"#渐进复杂度\" class=\"headerlink\" title=\"渐进复杂度\"></a>渐进复杂度</h3><table>\n<thead>\n<tr>\n<th align=\"center\">3n<sup>2</sup>+10n</th>\n<th align=\"center\">n<sup>2</sup>/10+2<sup>n</sup></th>\n<th align=\"center\">21+1/n</th>\n<th align=\"center\">logn<sup>3</sup></th>\n<th align=\"center\">10log3<sup>n</sup></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">O(n<sup>2</sup>)</td>\n<td align=\"center\">O(2<sup>n</sup>)</td>\n<td align=\"center\">O(1)</td>\n<td align=\"center\">O(logn)</td>\n<td align=\"center\">O(n)</td>\n</tr>\n</tbody></table>\n<p>2 &lt; logn &lt;n<sup>2/3</sup> &lt; 20n &lt; 4n<sup>2</sup> &lt; 3<sup>n</sup> &lt; n!</p>\n<ul>\n<li>f(n)的阶 &lt;= g(n)的阶    =&gt;    f(n)=O(g(n))</li>\n<li>f(n)的阶 &gt;= g(n)的阶    =&gt;    f(n)=Ω(g(n))</li>\n<li>f(n) == g(n)    =&gt;    f(n)=θ(g(n))</li>\n</ul>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><h5 id=\"算法特性\"><a href=\"#算法特性\" class=\"headerlink\" title=\"算法特性\"></a>算法特性</h5><ul>\n<li>有穷性：算法的有穷性是指算法必须能在执行有限个步骤之后终止。</li>\n<li>确定性：算法的每一步骤必须有确切的定义。</li>\n<li>可行性：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成。</li>\n<li>输入输出：有0个或多个输入，有1个或多个输出。</li>\n</ul>\n<h5 id=\"好算法标准\"><a href=\"#好算法标准\" class=\"headerlink\" title=\"好算法标准\"></a>好算法标准</h5><p><code>高效率，低存储。</code></p>\n<p>正确性、易读性、健壮性、高效性、低存储性</p>\n<h3 id=\"分支限界法\"><a href=\"#分支限界法\" class=\"headerlink\" title=\"分支限界法\"></a>分支限界法</h3><h5 id=\"分支限界法与回溯法的区别\"><a href=\"#分支限界法与回溯法的区别\" class=\"headerlink\" title=\"分支限界法与回溯法的区别\"></a>分支限界法与回溯法的区别</h5><ul>\n<li><p>二者都是在问题的解空间数上搜索问题解的算法。</p>\n</li>\n<li><p>分支限界法采用广度优先或最小耗费优先方式生成解空间；回溯法采用深度优先方式生成解空间。</p>\n</li>\n<li><p>分支界限法一般用于求最优解；回溯法一般用于求全部解。</p>\n</li>\n<li><p>分支界限法需要额外辅助空间；回溯法不需要。</p>\n</li>\n</ul>\n<h5 id=\"队列式与优先队列式的区别\"><a href=\"#队列式与优先队列式的区别\" class=\"headerlink\" title=\"队列式与优先队列式的区别\"></a>队列式与优先队列式的区别</h5><ul>\n<li>队列式：将活结点组织成一个队列，按先进先出原则选取下一个节点。</li>\n<li>优先队列式：将活结点组织成一个优先队列，按优先级最高原则选取下一个节点。</li>\n</ul>","categories":[{"name":"笔记","path":"api/categories/笔记.json"}],"tags":[{"name":"算法","path":"api/tags/算法.json"}]}