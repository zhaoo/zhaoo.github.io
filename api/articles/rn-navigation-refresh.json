{"title":"RN - 页面跳转后刷新内容","slug":"rn-navigation-refresh","date":"2020-03-28T07:41:17.000Z","updated":"2020-04-30T03:57:20.000Z","comments":true,"path":"api/articles/rn-navigation-refresh.json","realPath":"/2020/03/28/rn-navigation-refresh/","excerpt":"ReactNative中使用Navigation页面跳转后刷新内容的常用方法。","covers":null,"cover":"https://pic.izhaoo.com/20200404094306.jpg","content":"<p><code>ReactNative</code>中使用<code>Navigation</code>页面跳转后刷新内容的常用方法。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>最近准备实习面试，把一些原理性的内容学习了一遍，对前端的认识又上升了一个层次。顺便把之前的项目重构了一遍，过去的代码真是不堪入目。正如第一次面试时面试官说的，“基础的东西弄明白了，找Bug也会快一点”。</p>\n<p>之前做用户登录时遇到点小问题，登录成功后不刷新用户信息。逻辑如下：登录成功后获取到<code>token</code>，存入<code>redux</code>和<code>localStorage</code>，并且跳转到个人中心页面。个人中心页面在<code>componentDidMount</code>生命周期中请求后端获取用户信息并渲染。</p>\n<p>当时以为是<code>localStorage</code>的缘故，因为<code>ReactNative</code>中的<code>localStorage</code>是异步的，于是用<code>Promise</code>封装了一下，模拟成了同步，问题依然没有解决。后来发现，原来是<code>Navigation</code>跳转页面后不会触发<code>componentDidMount</code>生命周期，所以才没有渲染内容。</p>\n<h3 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h3><p>比较靠谱的方法是使用<code>React-Redux</code>来管理状态，执行顺序是<code>Connect (DATA AVAILABLE) -&gt; constructor &amp; componentWillMount &amp; componentDidMount</code>，即使在<code>RN</code>中没有<code>componentDidMount</code>也可以通过<code>connect</code>获取状态并更新。</p>\n<p>所以可以将用户信息保存到<code>redux</code>，然后设置<code>connect</code>，通过<code>props</code>获取用户信息并触发渲染。或者只保存<code>token</code>，然后在<code>componentWillReceiveProps</code>生命周期中使用<code>nextProps</code>获取到<code>token</code>，再请求后端获取用户信息再渲染。</p>\n<pre><code class=\"javascript\">import &#123;connect&#125; from &#39;react-redux&#39;;\n\nclass My extends Component &#123;\n  render() &#123;\n    const &#123;user&#125; = this.props;\n    if (user) &#123;\n      return (\n        &lt;View title=&quot;用户信息&quot; onPress=&#123;跳转编辑用户信息页面&#125; /&gt;\n      );\n    &#125; else &#123;\n      return (\n        &lt;View title=&quot;登录用户&quot; onPress=&#123;跳转登录页面&#125; /&gt;\n      );\n    &#125;\n  &#125;\n&#125;\n\nconst mapStateToProps = state =&gt; &#123;\n  return &#123;\n    token: state.user.token,\n    user: state.user.user,\n  &#125;;\n&#125;;\n\nexport default connect(mapStateToProps)(My);</code></pre>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>如果不想使用<code>Redux</code>，也可以设置回调函数，然后在<code>Navigation</code>中通过参数传递回调函数并触发刷新，类似于子组件与父组件通过回调函数通信。</p>\n<pre><code class=\"javascript\">// A组件\n\nexport default class A extends Component &#123;\n  refresh(state) &#123;\n    this.setState(&#123;state: state&#125;)\n  &#125;\n\n  render() &#123;\n    return (\n      &lt;Button\n          onPress=&#123; () =&gt; &#123;\n            this.props.navigation.navigate(&#39;B&#39;, &#123;\n              refresh: () =&gt; &#123; this.refresh() &#125;,\n            &#125;)\n          &#125;&#125;\n      /&gt;\n    )\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"javascript\">// B组件\n\nexport default class B extends Component &#123;\n  this.props.navigation.state.params.refresh(state)\n&#125;</code></pre>\n","more":"<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>最近准备实习面试，把一些原理性的内容学习了一遍，对前端的认识又上升了一个层次。顺便把之前的项目重构了一遍，过去的代码真是不堪入目。正如第一次面试时面试官说的，“基础的东西弄明白了，找Bug也会快一点”。</p>\n<p>之前做用户登录时遇到点小问题，登录成功后不刷新用户信息。逻辑如下：登录成功后获取到<code>token</code>，存入<code>redux</code>和<code>localStorage</code>，并且跳转到个人中心页面。个人中心页面在<code>componentDidMount</code>生命周期中请求后端获取用户信息并渲染。</p>\n<p>当时以为是<code>localStorage</code>的缘故，因为<code>ReactNative</code>中的<code>localStorage</code>是异步的，于是用<code>Promise</code>封装了一下，模拟成了同步，问题依然没有解决。后来发现，原来是<code>Navigation</code>跳转页面后不会触发<code>componentDidMount</code>生命周期，所以才没有渲染内容。</p>\n<h3 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h3><p>比较靠谱的方法是使用<code>React-Redux</code>来管理状态，执行顺序是<code>Connect (DATA AVAILABLE) -&gt; constructor &amp; componentWillMount &amp; componentDidMount</code>，即使在<code>RN</code>中没有<code>componentDidMount</code>也可以通过<code>connect</code>获取状态并更新。</p>\n<p>所以可以将用户信息保存到<code>redux</code>，然后设置<code>connect</code>，通过<code>props</code>获取用户信息并触发渲染。或者只保存<code>token</code>，然后在<code>componentWillReceiveProps</code>生命周期中使用<code>nextProps</code>获取到<code>token</code>，再请求后端获取用户信息再渲染。</p>\n<pre><code class=\"javascript\">import &#123;connect&#125; from &#39;react-redux&#39;;\n\nclass My extends Component &#123;\n  render() &#123;\n    const &#123;user&#125; = this.props;\n    if (user) &#123;\n      return (\n        &lt;View title=&quot;用户信息&quot; onPress=&#123;跳转编辑用户信息页面&#125; /&gt;\n      );\n    &#125; else &#123;\n      return (\n        &lt;View title=&quot;登录用户&quot; onPress=&#123;跳转登录页面&#125; /&gt;\n      );\n    &#125;\n  &#125;\n&#125;\n\nconst mapStateToProps = state =&gt; &#123;\n  return &#123;\n    token: state.user.token,\n    user: state.user.user,\n  &#125;;\n&#125;;\n\nexport default connect(mapStateToProps)(My);</code></pre>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>如果不想使用<code>Redux</code>，也可以设置回调函数，然后在<code>Navigation</code>中通过参数传递回调函数并触发刷新，类似于子组件与父组件通过回调函数通信。</p>\n<pre><code class=\"javascript\">// A组件\n\nexport default class A extends Component &#123;\n  refresh(state) &#123;\n    this.setState(&#123;state: state&#125;)\n  &#125;\n\n  render() &#123;\n    return (\n      &lt;Button\n          onPress=&#123; () =&gt; &#123;\n            this.props.navigation.navigate(&#39;B&#39;, &#123;\n              refresh: () =&gt; &#123; this.refresh() &#125;,\n            &#125;)\n          &#125;&#125;\n      /&gt;\n    )\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"javascript\">// B组件\n\nexport default class B extends Component &#123;\n  this.props.navigation.state.params.refresh(state)\n&#125;</code></pre>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"}]}