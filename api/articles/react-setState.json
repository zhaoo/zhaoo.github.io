{"title":"React - setState","slug":"react-setState","date":"2020-04-10T06:56:55.000Z","updated":"2020-08-01T08:39:30.000Z","comments":true,"path":"api/articles/react-setState.json","realPath":"/2020/04/10/react-setState/","excerpt":"React中，对于setState的理解，以及获取同步更新状态的方法。","covers":null,"cover":"https://pic.izhaoo.com/20200421201444.jpg","content":"<p>React中，对于<code>setState</code>的理解，以及获取同步更新状态的方法。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"异步原理\"><a href=\"#异步原理\" class=\"headerlink\" title=\"异步原理\"></a>异步原理</h3><p>之前看过一些文章，有这么个说法，<code>setState</code>在合成事件中是<code>“异步”更新</code>，在原生事件中是<code>“同步”更新</code>。这个说法没错，但总感觉怪怪的，直到看到了<code>鲨叔</code>的文章（文末链接），才彻底理解。</p>\n<blockquote>\n<p><code>批量更新</code>是因，<code>异步执行</code>是果。</p>\n</blockquote>\n<p>这里简单的提一下：在当前版本的<code>React</code>中，为了提升性能，会将多个<code>setState</code>进行合并更新，其实本身的代码上是<code>同步</code>的。只是<code>setState</code>和<code>获取状态</code>都是在<code>render()</code>前操作的，而合并更新又会进行一个短暂的调度延迟，所以我们获取<code>更新状态</code>的时候在感觉上是<code>“异步”</code>的。</p>\n<h3 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h3><h5 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h5><p><code>setState</code>的第二个参数可以传入一个<code>回调函数</code>，会在状态更新完毕后触发，即可实现同步流程。也可以在第一个<code>setState</code>的回调函数中嵌入第二个<code>setState</code>，形成链式调用链，顺序是可控的。</p>\n<pre><code class=\"javascript\">this.setState(&#123;\n  firstLoad: true,\n&#125;, () =&gt; &#123;\n  console.log(&#39;第一次更新完成&#39;)\n  this.setState(&#123;\n    secondLoad: true\n  &#125;, () =&gt; &#123;\n    console.log(&#39;第二次更新完成&#39;)\n  &#125;)\n&#125;);</code></pre>\n<h5 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h5><p>通过<code>回调函数</code>控制同步更新的方式会产生代码嵌套，如果嵌套层数过多会感觉不太直观，也就是<code>回调地狱</code>。因此，我们也可以通过封装一个<code>Promise</code>，使用<code>async/await</code>的方式来改造它，其实本质上还是用了上文的<code>回调函数</code>。</p>\n<pre><code class=\"javascript\">setStateAsync(state) &#123;\n  return new Promise((resolve) =&gt; &#123;\n    this.setState(state, resolve)\n  &#125;)\n&#125;\n\nasync componentDidMount() &#123;\n  const res = await fetch(&#39;/api/user/info&#39;)\n  const &#123; username &#125; = res\n  await this.setStateAsync(&#123; username: username &#125;)\n&#125;</code></pre>\n<h5 id=\"状态计算函数\"><a href=\"#状态计算函数\" class=\"headerlink\" title=\"状态计算函数\"></a>状态计算函数</h5><p>除了使用<code>回调函数</code>这种方式监听更新结果，我们也可以在<code>setState</code>的第一个参数中传入一个<code>状态计算函数</code>，而不是<code>普通对象</code>。函数中可以传入两个参数，<code>state</code>表示上一个状态值，<code>props</code>表示当前的状态。</p>\n<pre><code class=\"javascript\">this.setState((state, props) =&gt; (&#123;\n  counter: state.counter + props.increment\n&#125;))</code></pre>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5e54eb72e51d4526cf47fa56\">深入react的setState机制</a></p>\n</blockquote>\n","more":"<h3 id=\"异步原理\"><a href=\"#异步原理\" class=\"headerlink\" title=\"异步原理\"></a>异步原理</h3><p>之前看过一些文章，有这么个说法，<code>setState</code>在合成事件中是<code>“异步”更新</code>，在原生事件中是<code>“同步”更新</code>。这个说法没错，但总感觉怪怪的，直到看到了<code>鲨叔</code>的文章（文末链接），才彻底理解。</p>\n<blockquote>\n<p><code>批量更新</code>是因，<code>异步执行</code>是果。</p>\n</blockquote>\n<p>这里简单的提一下：在当前版本的<code>React</code>中，为了提升性能，会将多个<code>setState</code>进行合并更新，其实本身的代码上是<code>同步</code>的。只是<code>setState</code>和<code>获取状态</code>都是在<code>render()</code>前操作的，而合并更新又会进行一个短暂的调度延迟，所以我们获取<code>更新状态</code>的时候在感觉上是<code>“异步”</code>的。</p>\n<h3 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h3><h5 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h5><p><code>setState</code>的第二个参数可以传入一个<code>回调函数</code>，会在状态更新完毕后触发，即可实现同步流程。也可以在第一个<code>setState</code>的回调函数中嵌入第二个<code>setState</code>，形成链式调用链，顺序是可控的。</p>\n<pre><code class=\"javascript\">this.setState(&#123;\n  firstLoad: true,\n&#125;, () =&gt; &#123;\n  console.log(&#39;第一次更新完成&#39;)\n  this.setState(&#123;\n    secondLoad: true\n  &#125;, () =&gt; &#123;\n    console.log(&#39;第二次更新完成&#39;)\n  &#125;)\n&#125;);</code></pre>\n<h5 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h5><p>通过<code>回调函数</code>控制同步更新的方式会产生代码嵌套，如果嵌套层数过多会感觉不太直观，也就是<code>回调地狱</code>。因此，我们也可以通过封装一个<code>Promise</code>，使用<code>async/await</code>的方式来改造它，其实本质上还是用了上文的<code>回调函数</code>。</p>\n<pre><code class=\"javascript\">setStateAsync(state) &#123;\n  return new Promise((resolve) =&gt; &#123;\n    this.setState(state, resolve)\n  &#125;)\n&#125;\n\nasync componentDidMount() &#123;\n  const res = await fetch(&#39;/api/user/info&#39;)\n  const &#123; username &#125; = res\n  await this.setStateAsync(&#123; username: username &#125;)\n&#125;</code></pre>\n<h5 id=\"状态计算函数\"><a href=\"#状态计算函数\" class=\"headerlink\" title=\"状态计算函数\"></a>状态计算函数</h5><p>除了使用<code>回调函数</code>这种方式监听更新结果，我们也可以在<code>setState</code>的第一个参数中传入一个<code>状态计算函数</code>，而不是<code>普通对象</code>。函数中可以传入两个参数，<code>state</code>表示上一个状态值，<code>props</code>表示当前的状态。</p>\n<pre><code class=\"javascript\">this.setState((state, props) =&gt; (&#123;\n  counter: state.counter + props.increment\n&#125;))</code></pre>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5e54eb72e51d4526cf47fa56\">深入react的setState机制</a></p>\n</blockquote>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"React","path":"api/tags/React.json"}]}