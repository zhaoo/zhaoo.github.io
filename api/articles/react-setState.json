{"title":"React - setState","slug":"react-setState","date":"2020-04-10T06:56:55.000Z","updated":"2020-08-01T08:39:30.000Z","comments":true,"path":"api/articles/react-setState.json","realPath":"/2020/04/10/react-setState/","excerpt":"React中，对于setState的理解，以及获取同步更新状态的方法。","covers":null,"cover":"https://pic.izhaoo.com/20200421201444.jpg","content":"<p>React中，对于<code>setState</code>的理解，以及获取同步更新状态的方法。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"异步原理\"><a href=\"#异步原理\" class=\"headerlink\" title=\"异步原理\"></a>异步原理</h3><p>之前看过一些文章，有这么个说法，<code>setState</code>在合成事件中是<code>“异步”更新</code>，在原生事件中是<code>“同步”更新</code>。这个说法没错，但总感觉怪怪的，直到看到了<code>鲨叔</code>的文章（文末链接），才彻底理解。</p>\n<blockquote>\n<p><code>批量更新</code>是因，<code>异步执行</code>是果。</p>\n</blockquote>\n<p>这里简单的提一下：在当前版本的<code>React</code>中，为了提升性能，会将多个<code>setState</code>进行合并更新，其实本身的代码上是<code>同步</code>的。只是<code>setState</code>和<code>获取状态</code>都是在<code>render()</code>前操作的，而合并更新又会进行一个短暂的调度延迟，所以我们获取<code>更新状态</code>的时候在感觉上是<code>“异步”</code>的。</p>\n<h3 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h3><h5 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h5><p><code>setState</code>的第二个参数可以传入一个<code>回调函数</code>，会在状态更新完毕后触发，即可实现同步流程。也可以在第一个<code>setState</code>的回调函数中嵌入第二个<code>setState</code>，形成链式调用链，顺序是可控的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">this</span>.setState(&#123;<br>  <span class=\"hljs-attr\">firstLoad</span>: <span class=\"hljs-literal\">true</span>,<br>&#125;, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;第一次更新完成&#x27;</span>)<br>  <span class=\"hljs-built_in\">this</span>.setState(&#123;<br>    <span class=\"hljs-attr\">secondLoad</span>: <span class=\"hljs-literal\">true</span><br>  &#125;, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;第二次更新完成&#x27;</span>)<br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h5><p>通过<code>回调函数</code>控制同步更新的方式会产生代码嵌套，如果嵌套层数过多会感觉不太直观，也就是<code>回调地狱</code>。因此，我们也可以通过封装一个<code>Promise</code>，使用<code>async/await</code>的方式来改造它，其实本质上还是用了上文的<code>回调函数</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">setStateAsync</span>(<span class=\"hljs-params\">state</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.setState(state, resolve)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">&#x27;/api/user/info&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> &#123; username &#125; = res<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">this</span>.setStateAsync(&#123; <span class=\"hljs-attr\">username</span>: username &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"状态计算函数\"><a href=\"#状态计算函数\" class=\"headerlink\" title=\"状态计算函数\"></a>状态计算函数</h5><p>除了使用<code>回调函数</code>这种方式监听更新结果，我们也可以在<code>setState</code>的第一个参数中传入一个<code>状态计算函数</code>，而不是<code>普通对象</code>。函数中可以传入两个参数，<code>state</code>表示上一个状态值，<code>props</code>表示当前的状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">state, props</span>) =&gt;</span> (&#123;<br>  <span class=\"hljs-attr\">counter</span>: state.counter + props.increment<br>&#125;))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5e54eb72e51d4526cf47fa56\">深入react的setState机制</a></p>\n</blockquote>\n","more":"<h3 id=\"异步原理\"><a href=\"#异步原理\" class=\"headerlink\" title=\"异步原理\"></a>异步原理</h3><p>之前看过一些文章，有这么个说法，<code>setState</code>在合成事件中是<code>“异步”更新</code>，在原生事件中是<code>“同步”更新</code>。这个说法没错，但总感觉怪怪的，直到看到了<code>鲨叔</code>的文章（文末链接），才彻底理解。</p>\n<blockquote>\n<p><code>批量更新</code>是因，<code>异步执行</code>是果。</p>\n</blockquote>\n<p>这里简单的提一下：在当前版本的<code>React</code>中，为了提升性能，会将多个<code>setState</code>进行合并更新，其实本身的代码上是<code>同步</code>的。只是<code>setState</code>和<code>获取状态</code>都是在<code>render()</code>前操作的，而合并更新又会进行一个短暂的调度延迟，所以我们获取<code>更新状态</code>的时候在感觉上是<code>“异步”</code>的。</p>\n<h3 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h3><h5 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h5><p><code>setState</code>的第二个参数可以传入一个<code>回调函数</code>，会在状态更新完毕后触发，即可实现同步流程。也可以在第一个<code>setState</code>的回调函数中嵌入第二个<code>setState</code>，形成链式调用链，顺序是可控的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">this</span>.setState(&#123;<br>  <span class=\"hljs-attr\">firstLoad</span>: <span class=\"hljs-literal\">true</span>,<br>&#125;, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;第一次更新完成&#x27;</span>)<br>  <span class=\"hljs-built_in\">this</span>.setState(&#123;<br>    <span class=\"hljs-attr\">secondLoad</span>: <span class=\"hljs-literal\">true</span><br>  &#125;, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;第二次更新完成&#x27;</span>)<br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h5><p>通过<code>回调函数</code>控制同步更新的方式会产生代码嵌套，如果嵌套层数过多会感觉不太直观，也就是<code>回调地狱</code>。因此，我们也可以通过封装一个<code>Promise</code>，使用<code>async/await</code>的方式来改造它，其实本质上还是用了上文的<code>回调函数</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">setStateAsync</span>(<span class=\"hljs-params\">state</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.setState(state, resolve)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> fetch(<span class=\"hljs-string\">&#x27;/api/user/info&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> &#123; username &#125; = res<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">this</span>.setStateAsync(&#123; <span class=\"hljs-attr\">username</span>: username &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"状态计算函数\"><a href=\"#状态计算函数\" class=\"headerlink\" title=\"状态计算函数\"></a>状态计算函数</h5><p>除了使用<code>回调函数</code>这种方式监听更新结果，我们也可以在<code>setState</code>的第一个参数中传入一个<code>状态计算函数</code>，而不是<code>普通对象</code>。函数中可以传入两个参数，<code>state</code>表示上一个状态值，<code>props</code>表示当前的状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">this</span>.setState(<span class=\"hljs-function\">(<span class=\"hljs-params\">state, props</span>) =&gt;</span> (&#123;<br>  <span class=\"hljs-attr\">counter</span>: state.counter + props.increment<br>&#125;))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5e54eb72e51d4526cf47fa56\">深入react的setState机制</a></p>\n</blockquote>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"React","path":"api/tags/React.json"}]}