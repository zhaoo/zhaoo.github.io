{"title":"口袋拾荒 - 垃圾分类助手","slug":"ai-garbage-classification","date":"2020-08-02T09:46:38.000Z","updated":"2021-02-03T08:01:17.000Z","comments":true,"path":"api/articles/ai-garbage-classification.json","realPath":"/2020/08/02/ai-garbage-classification/","excerpt":"基于 Taro 开发的垃圾分类辅助小程序，支持拍照识别、关键词搜索、字典检索等功能。","covers":["https://pic.izhaoo.com/1596359686072.jpg"],"cover":"https://pic.izhaoo.com/20200228082224.jpg","content":"<p>基于 <code>Taro</code> 开发的垃圾分类辅助小程序，支持拍照识别、关键词搜索、字典检索等功能。</p>\n<span id=\"more\"></span>\n\n<p>&lt;封面摄于浙江·杭州的西溪湿地，与小潘同学秋游。&gt;</p>\n<blockquote>\n<p>GitHub: <a href=\"https://github.com/izhaoo/garbage-classification\">garbage-classification</a></p>\n</blockquote>\n<div align=\"center\">\n  <img  src=\"https://pic.izhaoo.com/1596359686072.jpg\"   width=\"350\" /><span class=\"image-caption\">口袋拾荒</span>\n</div>\n\n<h3 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h3><ul>\n<li>小程序: Taro, GraphQL (Apollo), TypeScript, React (Hooks), Canvas</li>\n<li>后台: AntDesign, TypeScript, React</li>\n<li>服务端: Nest.js, Mongoose, GraphQL （Apollo）, TypeScript, 百度AI</li>\n<li>爬虫: cheerio, superagent, Koa, Mongoose</li>\n</ul>\n<h5 id=\"Taro-图片（URL）-转-base64\"><a href=\"#Taro-图片（URL）-转-base64\" class=\"headerlink\" title=\"Taro 图片（URL） 转 base64\"></a>Taro 图片（URL） 转 base64</h5><p><strong>百度AI</strong> 接口接受 <code>base64</code> 形式的图片，并且识别主体内容和轮廓。所以我们需要通过相机拍照，以 <code>base64</code> 的形式上传到服务端。然而 <code>Taro.createCameraContext</code> 返回的是图片在本地缓存地址，而不是图片文件，无法转换为 <code>base64</code>，<code>Taro</code> 中也没相应的文档。后来发现，原来 <code>Taro</code> 是小程序的子集，在 <code>Taro</code> 中也能使用 <code>wx API</code>。</p>\n<pre><code class=\"javascript\">// func.ts\n\nexport function url2base64(url) &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    wx.getFileSystemManager().readFile(&#123;\n      filePath: url,\n      encoding: &#39;base64&#39;,\n      success: res =&gt; &#123;\n        resolve(res.data)\n      &#125;,\n      fail: (err) =&gt; &#123;\n        reject(err)\n      &#125;\n    &#125;)\n  &#125;)\n&#125;</code></pre>\n<pre><code class=\"javascript\">// page.ts\n\nimport &#123;url2base64&#125; from &#39;~/func.js&#39;\n\nonCamera = () =&gt; &#123;\n  const ctx = Taro.createCameraContext()\n  ctx.takePhoto(&#123;\n    quality: &#39;high&#39;,\n    success: async res =&gt; &#123;\n      const base64 = await url2base64(res.tempImagePath)\n      const &#123; width, height &#125; = await Taro.getImageInfo(&#123; src: res.tempImagePath &#125;)\n      this.handleCanvas(base64, res.tempImagePath, &#123; width, height &#125;)\n    &#125;\n  &#125;)\n&#125;</code></pre>\n<h5 id=\"Canvas-绘制物品轮廓（自适应设备）\"><a href=\"#Canvas-绘制物品轮廓（自适应设备）\" class=\"headerlink\" title=\"Canvas 绘制物品轮廓（自适应设备）\"></a>Canvas 绘制物品轮廓（自适应设备）</h5><blockquote>\n<p><a href=\"https://cloud.tencent.com/developer/article/1352187\">细说移动端 经典的REM布局 与 新秀VW布局</a></p>\n</blockquote>\n<p>将图片转为 <code>base64</code> 后就可以请求 <code>百度AI</code> 了，成功识别出了物品的名称（text），轮廓（四个坐标点），现在需要通过 <code>Canvas</code> 将它们绘制在画布中。</p>\n<p>遇到一个问题：图片在微信小程序IDE中调试没问题，但是一旦传到真机调试，比例就会失调，主要是因为文字和轮廓受设备分辨率影响进行了偏移。</p>\n<p>之前看过一篇文章，有个概念：<code>设备像素比 ＝ 物理像素 / 设备独立像素</code>。这里的偏移就是 <code>dpr</code> 导致的，所以我们只需要计算出 <code>dpr</code>，再将它缩放回来即可。（机智如我）</p>\n<p>通过以下代码可以获取页面的实际尺寸：</p>\n<pre><code class=\"javascript\">const window = Taro.getSystemInfo()\nconst w = window.windowWidth\nconst h = window.windowHeight</code></pre>\n<p>再将 <strong>页面尺寸</strong> 与 <strong>照片尺寸</strong> 做个除法计算即可：</p>\n<pre><code class=\"javascript\">handleCanvas = (base64, src, photo) =&gt; &#123;\n  //获取设备实际尺寸\n  const w = res.windowWidth\n  const h = res.windowHeight - 90\n  //计算缩放比\n  const scale = &#123;\n    w: w / photo.width,\n    h: h / photo.height\n  &#125;\n  const ctx = Taro.createCanvasContext(&#39;canvas&#39;, this.$scope)\n  Taro.getSystemInfo(&#123;\n    success: async res =&gt; &#123;\n      // 渲染图片\n      ctx.drawImage(src, 0, 0, w, h)\n      // 主体识别，获得轮廓\n      const subject: any = await baiduSubjectDetection(this.state.baiduToken, &#123;\n        image: base64\n      &#125;)\n      const &#123; height, width, top, left &#125; = subject.result\n      // 内容识别，获得物品名称\n      const advance: any = await baiduAdvancedGeneral(this.state.baiduToken, &#123;\n        image: base64\n      &#125;)\n      const &#123; keyword &#125; = advance.result[0]\n      //渲染轮廓和尺寸\n      this.setState(&#123; keyword: keyword &#125;)\n      ctx.setStrokeStyle(&quot;#00ff00&quot;)\n      ctx.setLineWidth(2)\n      ctx.rect(left, top, width, height)\n      //适配屏幕尺寸进行缩放\n      ctx.scale(scale.w, scale.h)\n      ctx.setFillStyle(&quot;#00ff00&quot;)\n      ctx.setFontSize(18 / scale.w)\n      ctx.fillText(keyword, left, (top + 30))\n      ctx.stroke()\n      ctx.draw()\n    &#125;\n  &#125;)\n&#125;</code></pre>\n<h5 id=\"Canvas-绘制海报并保存到相册\"><a href=\"#Canvas-绘制海报并保存到相册\" class=\"headerlink\" title=\"Canvas 绘制海报并保存到相册\"></a>Canvas 绘制海报并保存到相册</h5><p>推广页面的二维码海报也是用 <code>Canvas</code> 绘制的，实现了长按图片保存到相册功能，代码如下：</p>\n<pre><code class=\"javascript\">//获取画布尺寸\nconst window = Taro.getSystemInfoSync()\nconst w = window.windowWidth * 0.8\nconst h = window.windowWidth * 0.8 * 9 / 5\n\n//保存海报到相册\nconst handleSaveImage = async () =&gt; &#123;\n  //将 canvas 保存到缓存中\n  let res = await Taro.canvasToTempFilePath(&#123;\n    x: 0,\n    y: 0,\n    width: w,\n    height: h,\n    canvasId: &#39;canvas&#39;,\n    fileType: &#39;png&#39;\n  &#125;)\n  //将缓存中的图片保存到相册中\n  let saveRes = await Taro.saveImageToPhotosAlbum(&#123;\n    filePath: res.tempFilePath\n  &#125;)\n  if (saveRes.errMsg === &#39;saveImageToPhotosAlbum:ok&#39;) &#123;\n    Taro.showToast(&#123;\n      title: &#39;图片已保存到相册&#39;\n    &#125;)\n  &#125; else &#123;\n    Taro.showToast(&#123;\n      title: &#39;保存失败&#39;\n    &#125;)\n  &#125;\n&#125;\n\nconst renderCanvas = (text = &#39;快来扫一扫吧&#39;) =&gt; &#123;\n  const ctx = Taro.createCanvasContext(&#39;canvas&#39;, null)\n  //背景铺满\n  ctx.drawImage(background, 0, 0, w, h)\n  ctx.setFillStyle(&quot;#ffffff&quot;)\n  //文字居中\n  ctx.setFontSize(22)\n  ctx.setTextAlign(&#39;center&#39;)\n  ctx.fillText(&#39;口袋拾荒&#39;, w / 2, h - 200)\n  ctx.setFontSize(12)\n  ctx.fillText(`- $&#123;text&#125; -`, w / 2, h - 180)\n  ctx.draw()\n&#125;</code></pre>\n<p>by the way，文字居中官方文档中是用 <code>setTextAlign(&#39;center&#39;)</code> 实现的，但是实际却没有效果。因为它是以整个画布的宽度的一半的中心轴为基准线，我们还需要将文字的横轴移到画布中心轴：<code>ctx.fillText(text, w / 2, h)</code>。</p>\n<h5 id=\"数据爬虫\"><a href=\"#数据爬虫\" class=\"headerlink\" title=\"数据爬虫\"></a>数据爬虫</h5><p>爬虫功能很简单，用 <strong>superagent</strong> 库请求网站获取 <code>html</code> 文档，再用 <strong>cheerio</strong> 库解析标签清洗数据，最后用 <strong>mongoose</strong> 存到数据库中。</p>\n<pre><code class=\"javascript\">//爬取数据\nconst superagent = require(&#39;superagent&#39;)\nconst cheerio = require(&#39;cheerio&#39;)\n\nclass Eight &#123;\n  constructor() &#123;\n    this.url = &#123;\n      other: &#39;https://www.8684.cn/ljfl_glj&#39;,\n      food: &#39;https://www.8684.cn/ljfl_slj&#39;,\n      harmful: &#39;https://www.8684.cn/ljfl_yhlj&#39;,\n      recyclable: &#39;https://www.8684.cn/ljfl_khslj&#39;\n    &#125;\n  &#125;\n\n  parse = (body) =&gt; &#123;\n    const $ = cheerio.load(body.text)\n    let arr = []\n    $(&#39;.list-col4 li a&#39;).each((index, ele) =&gt; &#123;\n      arr.push($(ele).text())\n    &#125;)\n    return arr\n  &#125;\n\n  run = async () =&gt; &#123;\n    const &#123; url, parse &#125; = this\n    let data = []\n    for (const i in url) &#123;\n      const res = await superagent.get(url[i])\n      data.push(&#123;\n        key: i,\n        value: parse(res)\n      &#125;)\n    &#125;\n    return data\n  &#125;\n&#125;\n\nexports.Eight = Eight</code></pre>\n<pre><code class=\"javascript\">//存到数据库\n\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\nconst mongoose = require(&#39;mongoose&#39;)\nconst &#123; Eight &#125; = require(&#39;./source&#39;)\n\nconst config = &#123;\n  hostname: &#39;localhost&#39;,\n  port: 3000,\n&#125;\n\napp.use(async ctx =&gt; &#123;\n  ctx.body = &#39;Hello World&#39;\n&#125;)\n\napp.listen(config.port, config.hostname)\n\nconsole.info(&#39;Server is running at http://%s:%s . Press Ctrl+C to stop.&#39;, config.hostname, config.port)\n\nmongoose.connect(&#39;mongodb://localhost/garbage&#39;)\n\nconst Garbage = mongoose.model(&#39;Garbage&#39;, &#123; name: String, categoryId: String &#125;);\n\nconst eight = new Eight()\neight.run().then(res =&gt; &#123;\n  const data = res[0].value\n  for (const i of data) &#123;\n    Garbage.create(&#123;name:i, categoryId: &#39;5e427fe8558c2a31cd450fbc&#39;&#125;)\n  &#125;\n&#125;)</code></pre>\n<h5 id=\"Taro-封装-Apollo-请求库\"><a href=\"#Taro-封装-Apollo-请求库\" class=\"headerlink\" title=\"Taro 封装 Apollo 请求库\"></a>Taro 封装 Apollo 请求库</h5><p>简单封装一下 <code>GraphQL</code> 请求库，方便调用。</p>\n<pre><code class=\"javascript\">// /api/graphql.ts\n\nimport Taro from &#39;@tarojs/taro&#39;\nimport ApolloClient from &#39;apollo-boost&#39;\n\nconst uri = &#39;https://xxx.com/graphql&#39;\n\nconst fetch = (url, &#123; body: data, ...fetchOptions &#125;) =&gt; &#123;\n  return Taro.request(&#123; url, data, ...fetchOptions, dataType: &#39;txt&#39;, responseType: &#39;text&#39; &#125;)\n    .then((res) =&gt; &#123;\n      res.text = () =&gt; Promise.resolve(res.data)\n      return res\n    &#125;).catch(error =&gt; &#123;\n      console.error(error)\n    &#125;,\n  );\n&#125;\n\nexport default new ApolloClient(&#123; uri, fetch &#125;)</code></pre>\n<pre><code class=\"javascript\">// /api/gql.ts\n\nimport &#123; gql &#125; from &#39;apollo-boost&#39;\n\nexport const category = gql`\n  query &#123;\n    category &#123;\n      name\n      id\n      image\n    &#125;\n  &#125;\n`</code></pre>\n<pre><code class=\"javascript\">// page.ts\n\nimport &#123; category &#125; from &#39;~/api/gql&#39;\n\nconst res = await graphql.query(&#123; query: category &#125;)</code></pre>\n<h3 id=\"真机调试内网穿透\"><a href=\"#真机调试内网穿透\" class=\"headerlink\" title=\"真机调试内网穿透\"></a>真机调试内网穿透</h3><p>详见该文章 -&gt; <a href=\"https://www.izhaoo.com/2020/02/12/weapp-debug-https/\">小程序真机调试问题</a></p>\n","more":"<p>&lt;封面摄于浙江·杭州的西溪湿地，与小潘同学秋游。&gt;</p>\n<blockquote>\n<p>GitHub: <a href=\"https://github.com/izhaoo/garbage-classification\">garbage-classification</a></p>\n</blockquote>\n<div align=\"center\">\n  <img  src=\"https://pic.izhaoo.com/1596359686072.jpg\"   width=\"350\" /><span class=\"image-caption\">口袋拾荒</span>\n</div>\n\n<h3 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h3><ul>\n<li>小程序: Taro, GraphQL (Apollo), TypeScript, React (Hooks), Canvas</li>\n<li>后台: AntDesign, TypeScript, React</li>\n<li>服务端: Nest.js, Mongoose, GraphQL （Apollo）, TypeScript, 百度AI</li>\n<li>爬虫: cheerio, superagent, Koa, Mongoose</li>\n</ul>\n<h5 id=\"Taro-图片（URL）-转-base64\"><a href=\"#Taro-图片（URL）-转-base64\" class=\"headerlink\" title=\"Taro 图片（URL） 转 base64\"></a>Taro 图片（URL） 转 base64</h5><p><strong>百度AI</strong> 接口接受 <code>base64</code> 形式的图片，并且识别主体内容和轮廓。所以我们需要通过相机拍照，以 <code>base64</code> 的形式上传到服务端。然而 <code>Taro.createCameraContext</code> 返回的是图片在本地缓存地址，而不是图片文件，无法转换为 <code>base64</code>，<code>Taro</code> 中也没相应的文档。后来发现，原来 <code>Taro</code> 是小程序的子集，在 <code>Taro</code> 中也能使用 <code>wx API</code>。</p>\n<pre><code class=\"javascript\">// func.ts\n\nexport function url2base64(url) &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    wx.getFileSystemManager().readFile(&#123;\n      filePath: url,\n      encoding: &#39;base64&#39;,\n      success: res =&gt; &#123;\n        resolve(res.data)\n      &#125;,\n      fail: (err) =&gt; &#123;\n        reject(err)\n      &#125;\n    &#125;)\n  &#125;)\n&#125;</code></pre>\n<pre><code class=\"javascript\">// page.ts\n\nimport &#123;url2base64&#125; from &#39;~/func.js&#39;\n\nonCamera = () =&gt; &#123;\n  const ctx = Taro.createCameraContext()\n  ctx.takePhoto(&#123;\n    quality: &#39;high&#39;,\n    success: async res =&gt; &#123;\n      const base64 = await url2base64(res.tempImagePath)\n      const &#123; width, height &#125; = await Taro.getImageInfo(&#123; src: res.tempImagePath &#125;)\n      this.handleCanvas(base64, res.tempImagePath, &#123; width, height &#125;)\n    &#125;\n  &#125;)\n&#125;</code></pre>\n<h5 id=\"Canvas-绘制物品轮廓（自适应设备）\"><a href=\"#Canvas-绘制物品轮廓（自适应设备）\" class=\"headerlink\" title=\"Canvas 绘制物品轮廓（自适应设备）\"></a>Canvas 绘制物品轮廓（自适应设备）</h5><blockquote>\n<p><a href=\"https://cloud.tencent.com/developer/article/1352187\">细说移动端 经典的REM布局 与 新秀VW布局</a></p>\n</blockquote>\n<p>将图片转为 <code>base64</code> 后就可以请求 <code>百度AI</code> 了，成功识别出了物品的名称（text），轮廓（四个坐标点），现在需要通过 <code>Canvas</code> 将它们绘制在画布中。</p>\n<p>遇到一个问题：图片在微信小程序IDE中调试没问题，但是一旦传到真机调试，比例就会失调，主要是因为文字和轮廓受设备分辨率影响进行了偏移。</p>\n<p>之前看过一篇文章，有个概念：<code>设备像素比 ＝ 物理像素 / 设备独立像素</code>。这里的偏移就是 <code>dpr</code> 导致的，所以我们只需要计算出 <code>dpr</code>，再将它缩放回来即可。（机智如我）</p>\n<p>通过以下代码可以获取页面的实际尺寸：</p>\n<pre><code class=\"javascript\">const window = Taro.getSystemInfo()\nconst w = window.windowWidth\nconst h = window.windowHeight</code></pre>\n<p>再将 <strong>页面尺寸</strong> 与 <strong>照片尺寸</strong> 做个除法计算即可：</p>\n<pre><code class=\"javascript\">handleCanvas = (base64, src, photo) =&gt; &#123;\n  //获取设备实际尺寸\n  const w = res.windowWidth\n  const h = res.windowHeight - 90\n  //计算缩放比\n  const scale = &#123;\n    w: w / photo.width,\n    h: h / photo.height\n  &#125;\n  const ctx = Taro.createCanvasContext(&#39;canvas&#39;, this.$scope)\n  Taro.getSystemInfo(&#123;\n    success: async res =&gt; &#123;\n      // 渲染图片\n      ctx.drawImage(src, 0, 0, w, h)\n      // 主体识别，获得轮廓\n      const subject: any = await baiduSubjectDetection(this.state.baiduToken, &#123;\n        image: base64\n      &#125;)\n      const &#123; height, width, top, left &#125; = subject.result\n      // 内容识别，获得物品名称\n      const advance: any = await baiduAdvancedGeneral(this.state.baiduToken, &#123;\n        image: base64\n      &#125;)\n      const &#123; keyword &#125; = advance.result[0]\n      //渲染轮廓和尺寸\n      this.setState(&#123; keyword: keyword &#125;)\n      ctx.setStrokeStyle(&quot;#00ff00&quot;)\n      ctx.setLineWidth(2)\n      ctx.rect(left, top, width, height)\n      //适配屏幕尺寸进行缩放\n      ctx.scale(scale.w, scale.h)\n      ctx.setFillStyle(&quot;#00ff00&quot;)\n      ctx.setFontSize(18 / scale.w)\n      ctx.fillText(keyword, left, (top + 30))\n      ctx.stroke()\n      ctx.draw()\n    &#125;\n  &#125;)\n&#125;</code></pre>\n<h5 id=\"Canvas-绘制海报并保存到相册\"><a href=\"#Canvas-绘制海报并保存到相册\" class=\"headerlink\" title=\"Canvas 绘制海报并保存到相册\"></a>Canvas 绘制海报并保存到相册</h5><p>推广页面的二维码海报也是用 <code>Canvas</code> 绘制的，实现了长按图片保存到相册功能，代码如下：</p>\n<pre><code class=\"javascript\">//获取画布尺寸\nconst window = Taro.getSystemInfoSync()\nconst w = window.windowWidth * 0.8\nconst h = window.windowWidth * 0.8 * 9 / 5\n\n//保存海报到相册\nconst handleSaveImage = async () =&gt; &#123;\n  //将 canvas 保存到缓存中\n  let res = await Taro.canvasToTempFilePath(&#123;\n    x: 0,\n    y: 0,\n    width: w,\n    height: h,\n    canvasId: &#39;canvas&#39;,\n    fileType: &#39;png&#39;\n  &#125;)\n  //将缓存中的图片保存到相册中\n  let saveRes = await Taro.saveImageToPhotosAlbum(&#123;\n    filePath: res.tempFilePath\n  &#125;)\n  if (saveRes.errMsg === &#39;saveImageToPhotosAlbum:ok&#39;) &#123;\n    Taro.showToast(&#123;\n      title: &#39;图片已保存到相册&#39;\n    &#125;)\n  &#125; else &#123;\n    Taro.showToast(&#123;\n      title: &#39;保存失败&#39;\n    &#125;)\n  &#125;\n&#125;\n\nconst renderCanvas = (text = &#39;快来扫一扫吧&#39;) =&gt; &#123;\n  const ctx = Taro.createCanvasContext(&#39;canvas&#39;, null)\n  //背景铺满\n  ctx.drawImage(background, 0, 0, w, h)\n  ctx.setFillStyle(&quot;#ffffff&quot;)\n  //文字居中\n  ctx.setFontSize(22)\n  ctx.setTextAlign(&#39;center&#39;)\n  ctx.fillText(&#39;口袋拾荒&#39;, w / 2, h - 200)\n  ctx.setFontSize(12)\n  ctx.fillText(`- $&#123;text&#125; -`, w / 2, h - 180)\n  ctx.draw()\n&#125;</code></pre>\n<p>by the way，文字居中官方文档中是用 <code>setTextAlign(&#39;center&#39;)</code> 实现的，但是实际却没有效果。因为它是以整个画布的宽度的一半的中心轴为基准线，我们还需要将文字的横轴移到画布中心轴：<code>ctx.fillText(text, w / 2, h)</code>。</p>\n<h5 id=\"数据爬虫\"><a href=\"#数据爬虫\" class=\"headerlink\" title=\"数据爬虫\"></a>数据爬虫</h5><p>爬虫功能很简单，用 <strong>superagent</strong> 库请求网站获取 <code>html</code> 文档，再用 <strong>cheerio</strong> 库解析标签清洗数据，最后用 <strong>mongoose</strong> 存到数据库中。</p>\n<pre><code class=\"javascript\">//爬取数据\nconst superagent = require(&#39;superagent&#39;)\nconst cheerio = require(&#39;cheerio&#39;)\n\nclass Eight &#123;\n  constructor() &#123;\n    this.url = &#123;\n      other: &#39;https://www.8684.cn/ljfl_glj&#39;,\n      food: &#39;https://www.8684.cn/ljfl_slj&#39;,\n      harmful: &#39;https://www.8684.cn/ljfl_yhlj&#39;,\n      recyclable: &#39;https://www.8684.cn/ljfl_khslj&#39;\n    &#125;\n  &#125;\n\n  parse = (body) =&gt; &#123;\n    const $ = cheerio.load(body.text)\n    let arr = []\n    $(&#39;.list-col4 li a&#39;).each((index, ele) =&gt; &#123;\n      arr.push($(ele).text())\n    &#125;)\n    return arr\n  &#125;\n\n  run = async () =&gt; &#123;\n    const &#123; url, parse &#125; = this\n    let data = []\n    for (const i in url) &#123;\n      const res = await superagent.get(url[i])\n      data.push(&#123;\n        key: i,\n        value: parse(res)\n      &#125;)\n    &#125;\n    return data\n  &#125;\n&#125;\n\nexports.Eight = Eight</code></pre>\n<pre><code class=\"javascript\">//存到数据库\n\nconst Koa = require(&#39;koa&#39;)\nconst app = new Koa()\nconst mongoose = require(&#39;mongoose&#39;)\nconst &#123; Eight &#125; = require(&#39;./source&#39;)\n\nconst config = &#123;\n  hostname: &#39;localhost&#39;,\n  port: 3000,\n&#125;\n\napp.use(async ctx =&gt; &#123;\n  ctx.body = &#39;Hello World&#39;\n&#125;)\n\napp.listen(config.port, config.hostname)\n\nconsole.info(&#39;Server is running at http://%s:%s . Press Ctrl+C to stop.&#39;, config.hostname, config.port)\n\nmongoose.connect(&#39;mongodb://localhost/garbage&#39;)\n\nconst Garbage = mongoose.model(&#39;Garbage&#39;, &#123; name: String, categoryId: String &#125;);\n\nconst eight = new Eight()\neight.run().then(res =&gt; &#123;\n  const data = res[0].value\n  for (const i of data) &#123;\n    Garbage.create(&#123;name:i, categoryId: &#39;5e427fe8558c2a31cd450fbc&#39;&#125;)\n  &#125;\n&#125;)</code></pre>\n<h5 id=\"Taro-封装-Apollo-请求库\"><a href=\"#Taro-封装-Apollo-请求库\" class=\"headerlink\" title=\"Taro 封装 Apollo 请求库\"></a>Taro 封装 Apollo 请求库</h5><p>简单封装一下 <code>GraphQL</code> 请求库，方便调用。</p>\n<pre><code class=\"javascript\">// /api/graphql.ts\n\nimport Taro from &#39;@tarojs/taro&#39;\nimport ApolloClient from &#39;apollo-boost&#39;\n\nconst uri = &#39;https://xxx.com/graphql&#39;\n\nconst fetch = (url, &#123; body: data, ...fetchOptions &#125;) =&gt; &#123;\n  return Taro.request(&#123; url, data, ...fetchOptions, dataType: &#39;txt&#39;, responseType: &#39;text&#39; &#125;)\n    .then((res) =&gt; &#123;\n      res.text = () =&gt; Promise.resolve(res.data)\n      return res\n    &#125;).catch(error =&gt; &#123;\n      console.error(error)\n    &#125;,\n  );\n&#125;\n\nexport default new ApolloClient(&#123; uri, fetch &#125;)</code></pre>\n<pre><code class=\"javascript\">// /api/gql.ts\n\nimport &#123; gql &#125; from &#39;apollo-boost&#39;\n\nexport const category = gql`\n  query &#123;\n    category &#123;\n      name\n      id\n      image\n    &#125;\n  &#125;\n`</code></pre>\n<pre><code class=\"javascript\">// page.ts\n\nimport &#123; category &#125; from &#39;~/api/gql&#39;\n\nconst res = await graphql.query(&#123; query: category &#125;)</code></pre>\n<h3 id=\"真机调试内网穿透\"><a href=\"#真机调试内网穿透\" class=\"headerlink\" title=\"真机调试内网穿透\"></a>真机调试内网穿透</h3><p>详见该文章 -&gt; <a href=\"https://www.izhaoo.com/2020/02/12/weapp-debug-https/\">小程序真机调试问题</a></p>","categories":[{"name":"项目","path":"api/categories/项目.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"}]}