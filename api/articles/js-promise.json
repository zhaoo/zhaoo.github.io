{"title":"JavaScript - Promise","slug":"js-promise","date":"2020-07-17T09:22:41.000Z","updated":"2020-08-01T08:57:56.000Z","comments":true,"path":"api/articles/js-promise.json","realPath":"/2020/07/17/js-promise/","excerpt":"承诺我已说出口。","covers":["https://pic.izhaoo.com/wa.png","https://pic.izhaoo.com/show-me-your-code.gif"],"cover":"https://pic.izhaoo.com/20200717172841.jpg","content":"<p>承诺我已说出口。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"面试环节\"><a href=\"#面试环节\" class=\"headerlink\" title=\"面试环节\"></a>面试环节</h3><p>先来看一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;外部promise&quot;</span>);<br>  resolve();<br>&#125;)<br>  .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;外部第一个then&quot;</span>);<br>    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部promise&quot;</span>);<br>      resolve();<br>    &#125;)<br>      .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部第一个then&quot;</span>);<br>      &#125;)<br>      .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部第二个then&quot;</span>);<br>      &#125;);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部promise2&quot;</span>);<br>      resolve();<br>    &#125;)<br>      .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部第一个then2&quot;</span>);<br>      &#125;)<br>      .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部第二个then2&quot;</span>);<br>      &#125;);<br>  &#125;)<br>  .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;外部第二个then&quot;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>Are you ok ? 恭喜你被谷歌录取了 : 行了行了下一位</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><p>首先我们先来了解一下引入 <code>Promise</code> 的必要性。</p>\n<h5 id=\"回调地狱\"><a href=\"#回调地狱\" class=\"headerlink\" title=\"回调地狱\"></a>回调地狱</h5><p>曾几何时<del>（现在也是）</del>，我们的异步代码是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">post(<span class=\"hljs-string\">&#x27;/user/login&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> err;<br>  get(<span class=\"hljs-string\">&#x27;/user/info&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> err;<br>    post(<span class=\"hljs-string\">&#x27;/articles/create&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> err;<br>      get(<span class=\"hljs-string\">&#x27;/articles/list&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>        ...<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这就是大家津津乐道的 <strong>回调地狱</strong> 了，主要有以下几个问题：</p>\n<ol>\n<li>嵌套太深，逻辑复杂：每层的回调函数的业务逻辑都依赖于上层执行的返回结果，嵌套层次多了之后，代码可读性很差。</li>\n<li>错误处理麻烦：每层的回调函数都需要传入两个状态（失败、成功），且每一层都需要对错误进行单独处理，没有统一的错误处理机制。</li>\n<li>上下文环境乱：有的时候我们想处理上层环境（调用 <code>this</code>），却发现绑定不到，只能使用 <code>var _this = this;</code> 这样的 hack 方法。</li>\n</ol>\n<h5 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h5><p>这时候天空一声巨响，<code>Promise</code> 闪亮登场，救人民与水深火热之中。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//用 Promise 封装接口</span><br><span class=\"hljs-keyword\">const</span> post = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    post(url, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data</span>) =&gt;</span> &#123;<br>      err &amp;&amp; reject(err)<br>      resolve(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-comment\">//调用逻辑</span><br>post(<span class=\"hljs-string\">&#x27;/user/login&#x27;</span>)<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> get(<span class=\"hljs-string\">&#x27;/user/info&#x27;</span>))<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> post(<span class=\"hljs-string\">&#x27;/articles/create&#x27;</span>))<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> get(<span class=\"hljs-string\">&#x27;/articles/list&#x27;</span>))<br>  .then(...)<br>  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;报错了啦：&#x27;</span> + err))<br></code></pre></td></tr></table></figure>\n\n<p>这不是好起来了嘛：</p>\n<ol>\n<li>干掉了嵌套调用，采用了链式挂载，逻辑上清晰了一些。</li>\n<li>合并处理错误，在最后统一 <code>catch</code> 并执行。</li>\n</ol>\n<h5 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async / await\"></a>async / await</h5><p>Emmm，还不是一坨代码。好吧，再来看看终极方案 <code>async/await</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">do</span> = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-keyword\">await</span> post(<span class=\"hljs-string\">&#x27;/user/login&#x27;</span>);<br>    <span class=\"hljs-keyword\">const</span> userInfo = <span class=\"hljs-keyword\">await</span> get(<span class=\"hljs-string\">&#x27;/user/info&#x27;</span>);<br>    <span class=\"hljs-keyword\">const</span> createArticleResult = <span class=\"hljs-keyword\">await</span> post(<span class=\"hljs-string\">&#x27;/articles/create&#x27;</span>);<br>    <span class=\"hljs-keyword\">const</span> articlesList = <span class=\"hljs-keyword\">await</span> get(<span class=\"hljs-string\">&#x27;/articles/list&#x27;</span>);<br>    ...<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;又报错了啦：&#x27;</span> + err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>直接屏蔽了异步逻辑，改用同步方式。</p>\n<p><img  src=\"https://pic.izhaoo.com/wa.png\"  ><span class=\"image-caption\">wo</span></p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - MDN</a></p>\n</blockquote>\n<p>工欲善其事，必先利其器。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>那么 <code>Promise</code> 是如何工作的呢？主要是采用了 <strong>延迟绑定</strong> 和 <strong>返值穿透</strong> 两种思想。</p>\n<h5 id=\"延迟绑定\"><a href=\"#延迟绑定\" class=\"headerlink\" title=\"延迟绑定\"></a>延迟绑定</h5><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123; resolve(<span class=\"hljs-string\">&#x27;ok&#x27;</span>) &#125;)<br><br>...<br><br>p.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123; <span class=\"hljs-built_in\">console</span>.log(value) &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>可以看到先创建了应该 <code>Promise</code> 对象，此时还没有绑定 <code>回调函数</code>。创建完对象之后，可以处理其他代码逻辑。直到调用 <code>then</code> 处理执行逻辑的时候，我们才将 <code>回调函数</code> 进行绑定。<strong>创建对象</strong> 和 <strong>绑定回调</strong> 实现了分离解耦。</p>\n<h5 id=\"返值穿透\"><a href=\"#返值穿透\" class=\"headerlink\" title=\"返值穿透\"></a>返值穿透</h5><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class=\"hljs-number\">1</span>)<br>&#125;)<br><br><span class=\"hljs-keyword\">const</span> p2 = p1.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(value + <span class=\"hljs-number\">1</span>)<br>  &#125;)<br>  <span class=\"hljs-keyword\">return</span> p2<br>&#125;)<br><br>p2.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(value)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，在 <code>p1</code> 的回调函数中我们创建了一个新的 <code>Promise</code> 对象 <code>p2</code>，将它 <code>return</code> 到了最外层并被接受。每层回调函数的返回值始终可以穿透到最外层，这样就可以保证 <code>返回值</code> 始终可控，不会陷入循环中。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p><img  src=\"https://pic.izhaoo.com/show-me-your-code.gif\"  ><span class=\"image-caption\">上代码啊</span></p>\n<p>其实经典方法的实现原理都大同小异：状态流传递、队列缓存回调……</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">&#x27;PENDING&#x27;</span><br><span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">&#x27;FULFILLED&#x27;</span><br><span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">&#x27;REJECTED&#x27;</span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyPromise</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">handle</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>._status = PENDING<br>    <span class=\"hljs-built_in\">this</span>._value = <span class=\"hljs-literal\">undefined</span><br>    <span class=\"hljs-comment\">//回调函数队列</span><br>    <span class=\"hljs-built_in\">this</span>._fulfilledQueues = []<br>    <span class=\"hljs-built_in\">this</span>._rejectedQueues = []<br>    <span class=\"hljs-comment\">//执行handle</span><br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      handle(<span class=\"hljs-built_in\">this</span>._resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>._reject.bind(<span class=\"hljs-built_in\">this</span>))<br>    &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>      <span class=\"hljs-built_in\">this</span>._reject(err)<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// resovle时执行的函数</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">_resolve</span>(<span class=\"hljs-params\">val</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span><br>    <span class=\"hljs-built_in\">this</span>._status = FULFILLED<br>    <span class=\"hljs-built_in\">this</span>._value = val<br>  &#125;<br><br>  <span class=\"hljs-comment\">// reject时执行的函数</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">_reject</span>(<span class=\"hljs-params\">err</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span><br>    <span class=\"hljs-built_in\">this</span>._status = REJECTED<br>    <span class=\"hljs-built_in\">this</span>._value = err<br>  &#125;<br><br>  <span class=\"hljs-comment\">// then方法</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">then</span>(<span class=\"hljs-params\">onFulfilled, onRejected</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; _value, _status &#125; = <span class=\"hljs-built_in\">this</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-comment\">//成功时执行的函数</span><br>      <span class=\"hljs-keyword\">let</span> fulfilled = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>          <span class=\"hljs-keyword\">let</span> res = onFulfilled(value);<br>          <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) &#123;<br>            <span class=\"hljs-comment\">// 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调</span><br>            res.then(onFulfilledNext, onRejectedNext)<br>          &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span><br>            onFulfilledNext(res)<br>          &#125;<br>        &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>          onRejectedNext(err)<br>        &#125;<br>      &#125;<br>      <span class=\"hljs-comment\">//失败时执行的函数</span><br>      <span class=\"hljs-keyword\">let</span> rejected = <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>          <span class=\"hljs-keyword\">let</span> res = onRejected(error);<br>          <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) &#123;<br>            <span class=\"hljs-comment\">// 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调</span><br>            res.then(onFulfilledNext, onRejectedNext)<br>          &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span><br>            onFulfilledNext(res)<br>          &#125;<br>        &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>          onRejectedNext(err)<br>        &#125;<br>      &#125;<br>      <span class=\"hljs-keyword\">switch</span> (_status) &#123;<br>        <span class=\"hljs-comment\">//状态为pending时将回调函数推入队列进行缓存</span><br>        <span class=\"hljs-keyword\">case</span> PENDING:<br>          <span class=\"hljs-built_in\">this</span>._fulfilledQueues.push(fulfilled)<br>          <span class=\"hljs-built_in\">this</span>._rejectedQueues.push(rejected)<br>          <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-comment\">//状态改变时执行回调函数</span><br>        <span class=\"hljs-keyword\">case</span> FULFILLED:<br>          fulfilled(_value)<br>          <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-keyword\">case</span> REJECTED:<br>          rejected(_value)<br>          <span class=\"hljs-keyword\">break</span><br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5dcb775c518825574d214b89\">大厂面试必考知识点：Promise 注册微任务和执行过程</a></p>\n</blockquote>\n","more":"<h3 id=\"面试环节\"><a href=\"#面试环节\" class=\"headerlink\" title=\"面试环节\"></a>面试环节</h3><p>先来看一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;外部promise&quot;</span>);<br>  resolve();<br>&#125;)<br>  .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;外部第一个then&quot;</span>);<br>    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部promise&quot;</span>);<br>      resolve();<br>    &#125;)<br>      .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部第一个then&quot;</span>);<br>      &#125;)<br>      .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部第二个then&quot;</span>);<br>      &#125;);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部promise2&quot;</span>);<br>      resolve();<br>    &#125;)<br>      .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部第一个then2&quot;</span>);<br>      &#125;)<br>      .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;内部第二个then2&quot;</span>);<br>      &#125;);<br>  &#125;)<br>  .then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;外部第二个then&quot;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>Are you ok ? 恭喜你被谷歌录取了 : 行了行了下一位</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><p>首先我们先来了解一下引入 <code>Promise</code> 的必要性。</p>\n<h5 id=\"回调地狱\"><a href=\"#回调地狱\" class=\"headerlink\" title=\"回调地狱\"></a>回调地狱</h5><p>曾几何时<del>（现在也是）</del>，我们的异步代码是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">post(<span class=\"hljs-string\">&#x27;/user/login&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> err;<br>  get(<span class=\"hljs-string\">&#x27;/user/info&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> err;<br>    post(<span class=\"hljs-string\">&#x27;/articles/create&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> err;<br>      get(<span class=\"hljs-string\">&#x27;/articles/list&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>        ...<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这就是大家津津乐道的 <strong>回调地狱</strong> 了，主要有以下几个问题：</p>\n<ol>\n<li>嵌套太深，逻辑复杂：每层的回调函数的业务逻辑都依赖于上层执行的返回结果，嵌套层次多了之后，代码可读性很差。</li>\n<li>错误处理麻烦：每层的回调函数都需要传入两个状态（失败、成功），且每一层都需要对错误进行单独处理，没有统一的错误处理机制。</li>\n<li>上下文环境乱：有的时候我们想处理上层环境（调用 <code>this</code>），却发现绑定不到，只能使用 <code>var _this = this;</code> 这样的 hack 方法。</li>\n</ol>\n<h5 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h5><p>这时候天空一声巨响，<code>Promise</code> 闪亮登场，救人民与水深火热之中。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//用 Promise 封装接口</span><br><span class=\"hljs-keyword\">const</span> post = <span class=\"hljs-function\">(<span class=\"hljs-params\">url</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    post(url, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data</span>) =&gt;</span> &#123;<br>      err &amp;&amp; reject(err)<br>      resolve(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-comment\">//调用逻辑</span><br>post(<span class=\"hljs-string\">&#x27;/user/login&#x27;</span>)<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> get(<span class=\"hljs-string\">&#x27;/user/info&#x27;</span>))<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> post(<span class=\"hljs-string\">&#x27;/articles/create&#x27;</span>))<br>  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> get(<span class=\"hljs-string\">&#x27;/articles/list&#x27;</span>))<br>  .then(...)<br>  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;报错了啦：&#x27;</span> + err))<br></code></pre></td></tr></table></figure>\n\n<p>这不是好起来了嘛：</p>\n<ol>\n<li>干掉了嵌套调用，采用了链式挂载，逻辑上清晰了一些。</li>\n<li>合并处理错误，在最后统一 <code>catch</code> 并执行。</li>\n</ol>\n<h5 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async / await\"></a>async / await</h5><p>Emmm，还不是一坨代码。好吧，再来看看终极方案 <code>async/await</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">do</span> = <span class=\"hljs-keyword\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> token = <span class=\"hljs-keyword\">await</span> post(<span class=\"hljs-string\">&#x27;/user/login&#x27;</span>);<br>    <span class=\"hljs-keyword\">const</span> userInfo = <span class=\"hljs-keyword\">await</span> get(<span class=\"hljs-string\">&#x27;/user/info&#x27;</span>);<br>    <span class=\"hljs-keyword\">const</span> createArticleResult = <span class=\"hljs-keyword\">await</span> post(<span class=\"hljs-string\">&#x27;/articles/create&#x27;</span>);<br>    <span class=\"hljs-keyword\">const</span> articlesList = <span class=\"hljs-keyword\">await</span> get(<span class=\"hljs-string\">&#x27;/articles/list&#x27;</span>);<br>    ...<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;又报错了啦：&#x27;</span> + err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>直接屏蔽了异步逻辑，改用同步方式。</p>\n<p><img  src=\"https://pic.izhaoo.com/wa.png\"  ><span class=\"image-caption\">wo</span></p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - MDN</a></p>\n</blockquote>\n<p>工欲善其事，必先利其器。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>那么 <code>Promise</code> 是如何工作的呢？主要是采用了 <strong>延迟绑定</strong> 和 <strong>返值穿透</strong> 两种思想。</p>\n<h5 id=\"延迟绑定\"><a href=\"#延迟绑定\" class=\"headerlink\" title=\"延迟绑定\"></a>延迟绑定</h5><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123; resolve(<span class=\"hljs-string\">&#x27;ok&#x27;</span>) &#125;)<br><br>...<br><br>p.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123; <span class=\"hljs-built_in\">console</span>.log(value) &#125;)<br></code></pre></td></tr></table></figure>\n\n<p>可以看到先创建了应该 <code>Promise</code> 对象，此时还没有绑定 <code>回调函数</code>。创建完对象之后，可以处理其他代码逻辑。直到调用 <code>then</code> 处理执行逻辑的时候，我们才将 <code>回调函数</code> 进行绑定。<strong>创建对象</strong> 和 <strong>绑定回调</strong> 实现了分离解耦。</p>\n<h5 id=\"返值穿透\"><a href=\"#返值穿透\" class=\"headerlink\" title=\"返值穿透\"></a>返值穿透</h5><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class=\"hljs-number\">1</span>)<br>&#125;)<br><br><span class=\"hljs-keyword\">const</span> p2 = p1.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(value + <span class=\"hljs-number\">1</span>)<br>  &#125;)<br>  <span class=\"hljs-keyword\">return</span> p2<br>&#125;)<br><br>p2.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(value)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，在 <code>p1</code> 的回调函数中我们创建了一个新的 <code>Promise</code> 对象 <code>p2</code>，将它 <code>return</code> 到了最外层并被接受。每层回调函数的返回值始终可以穿透到最外层，这样就可以保证 <code>返回值</code> 始终可控，不会陷入循环中。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p><img  src=\"https://pic.izhaoo.com/show-me-your-code.gif\"  ><span class=\"image-caption\">上代码啊</span></p>\n<p>其实经典方法的实现原理都大同小异：状态流传递、队列缓存回调……</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> PENDING = <span class=\"hljs-string\">&#x27;PENDING&#x27;</span><br><span class=\"hljs-keyword\">const</span> FULFILLED = <span class=\"hljs-string\">&#x27;FULFILLED&#x27;</span><br><span class=\"hljs-keyword\">const</span> REJECTED = <span class=\"hljs-string\">&#x27;REJECTED&#x27;</span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyPromise</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">handle</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>._status = PENDING<br>    <span class=\"hljs-built_in\">this</span>._value = <span class=\"hljs-literal\">undefined</span><br>    <span class=\"hljs-comment\">//回调函数队列</span><br>    <span class=\"hljs-built_in\">this</span>._fulfilledQueues = []<br>    <span class=\"hljs-built_in\">this</span>._rejectedQueues = []<br>    <span class=\"hljs-comment\">//执行handle</span><br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      handle(<span class=\"hljs-built_in\">this</span>._resolve.bind(<span class=\"hljs-built_in\">this</span>), <span class=\"hljs-built_in\">this</span>._reject.bind(<span class=\"hljs-built_in\">this</span>))<br>    &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>      <span class=\"hljs-built_in\">this</span>._reject(err)<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// resovle时执行的函数</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">_resolve</span>(<span class=\"hljs-params\">val</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span><br>    <span class=\"hljs-built_in\">this</span>._status = FULFILLED<br>    <span class=\"hljs-built_in\">this</span>._value = val<br>  &#125;<br><br>  <span class=\"hljs-comment\">// reject时执行的函数</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">_reject</span>(<span class=\"hljs-params\">err</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>._status !== PENDING) <span class=\"hljs-keyword\">return</span><br>    <span class=\"hljs-built_in\">this</span>._status = REJECTED<br>    <span class=\"hljs-built_in\">this</span>._value = err<br>  &#125;<br><br>  <span class=\"hljs-comment\">// then方法</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">then</span>(<span class=\"hljs-params\">onFulfilled, onRejected</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; _value, _status &#125; = <span class=\"hljs-built_in\">this</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyPromise(<span class=\"hljs-function\">(<span class=\"hljs-params\">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-comment\">//成功时执行的函数</span><br>      <span class=\"hljs-keyword\">let</span> fulfilled = <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>          <span class=\"hljs-keyword\">let</span> res = onFulfilled(value);<br>          <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) &#123;<br>            <span class=\"hljs-comment\">// 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调</span><br>            res.then(onFulfilledNext, onRejectedNext)<br>          &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span><br>            onFulfilledNext(res)<br>          &#125;<br>        &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>          onRejectedNext(err)<br>        &#125;<br>      &#125;<br>      <span class=\"hljs-comment\">//失败时执行的函数</span><br>      <span class=\"hljs-keyword\">let</span> rejected = <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>          <span class=\"hljs-keyword\">let</span> res = onRejected(error);<br>          <span class=\"hljs-keyword\">if</span> (res <span class=\"hljs-keyword\">instanceof</span> MyPromise) &#123;<br>            <span class=\"hljs-comment\">// 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调</span><br>            res.then(onFulfilledNext, onRejectedNext)<br>          &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span><br>            onFulfilledNext(res)<br>          &#125;<br>        &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>          onRejectedNext(err)<br>        &#125;<br>      &#125;<br>      <span class=\"hljs-keyword\">switch</span> (_status) &#123;<br>        <span class=\"hljs-comment\">//状态为pending时将回调函数推入队列进行缓存</span><br>        <span class=\"hljs-keyword\">case</span> PENDING:<br>          <span class=\"hljs-built_in\">this</span>._fulfilledQueues.push(fulfilled)<br>          <span class=\"hljs-built_in\">this</span>._rejectedQueues.push(rejected)<br>          <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-comment\">//状态改变时执行回调函数</span><br>        <span class=\"hljs-keyword\">case</span> FULFILLED:<br>          fulfilled(_value)<br>          <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-keyword\">case</span> REJECTED:<br>          rejected(_value)<br>          <span class=\"hljs-keyword\">break</span><br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5dcb775c518825574d214b89\">大厂面试必考知识点：Promise 注册微任务和执行过程</a></p>\n</blockquote>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"js","path":"api/tags/js.json"}]}