{"title":"JavaScript - Promise","slug":"js-promise","date":"2020-07-17T09:22:41.000Z","updated":"2020-08-01T08:57:56.000Z","comments":true,"path":"api/articles/js-promise.json","realPath":"/2020/07/17/js-promise/","excerpt":"承诺我已说出口。","covers":["https://pic.izhaoo.com/wa.png","https://pic.izhaoo.com/show-me-your-code.gif"],"cover":"https://pic.izhaoo.com/20200717172841.jpg","content":"<p>承诺我已说出口。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"面试环节\"><a href=\"#面试环节\" class=\"headerlink\" title=\"面试环节\"></a>面试环节</h3><p>先来看一段代码：</p>\n<pre><code class=\"javascript\">new Promise((resolve, reject) =&gt; &#123;\n  console.log(&quot;外部promise&quot;);\n  resolve();\n&#125;)\n  .then(() =&gt; &#123;\n    console.log(&quot;外部第一个then&quot;);\n    new Promise((resolve, reject) =&gt; &#123;\n      console.log(&quot;内部promise&quot;);\n      resolve();\n    &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;内部第一个then&quot;);\n      &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;内部第二个then&quot;);\n      &#125;);\n    return new Promise((resolve, reject) =&gt; &#123;\n      console.log(&quot;内部promise2&quot;);\n      resolve();\n    &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;内部第一个then2&quot;);\n      &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;内部第二个then2&quot;);\n      &#125;);\n  &#125;)\n  .then(() =&gt; &#123;\n    console.log(&quot;外部第二个then&quot;);\n  &#125;);</code></pre>\n<p>Are you ok ? 恭喜你被谷歌录取了 : 行了行了下一位</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><p>首先我们先来了解一下引入 <code>Promise</code> 的必要性。</p>\n<h5 id=\"回调地狱\"><a href=\"#回调地狱\" class=\"headerlink\" title=\"回调地狱\"></a>回调地狱</h5><p>曾几何时<del>（现在也是）</del>，我们的异步代码是这样的：</p>\n<pre><code class=\"javascript\">post(&#39;/user/login&#39;, function (err, data) &#123;\n  if (err) return err;\n  get(&#39;/user/info&#39;, function (err, data) &#123;\n    if (err) return err;\n    post(&#39;/articles/create&#39;, function (err, data) &#123;\n      if (err) return err;\n      get(&#39;/articles/list&#39;, function (err, data) &#123;\n        ...\n      &#125;);\n    &#125;);\n  &#125;);\n&#125;);</code></pre>\n<p>这就是大家津津乐道的 <strong>回调地狱</strong> 了，主要有以下几个问题：</p>\n<ol>\n<li>嵌套太深，逻辑复杂：每层的回调函数的业务逻辑都依赖于上层执行的返回结果，嵌套层次多了之后，代码可读性很差。</li>\n<li>错误处理麻烦：每层的回调函数都需要传入两个状态（失败、成功），且每一层都需要对错误进行单独处理，没有统一的错误处理机制。</li>\n<li>上下文环境乱：有的时候我们想处理上层环境（调用 <code>this</code>），却发现绑定不到，只能使用 <code>var _this = this;</code> 这样的 hack 方法。</li>\n</ol>\n<h5 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h5><p>这时候天空一声巨响，<code>Promise</code> 闪亮登场，救人民与水深火热之中。代码如下：</p>\n<pre><code class=\"javascript\">//用 Promise 封装接口\nconst post = (url) =&gt; &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    post(url, (err, data) =&gt; &#123;\n      err &amp;&amp; reject(err)\n      resolve(data)\n    &#125;)\n  &#125;)\n&#125;\n\n//调用逻辑\npost(&#39;/user/login&#39;)\n  .then(data =&gt; get(&#39;/user/info&#39;))\n  .then(data =&gt; post(&#39;/articles/create&#39;))\n  .then(data =&gt; get(&#39;/articles/list&#39;))\n  .then(...)\n  .catch(err =&gt; console.error(&#39;报错了啦：&#39; + err))</code></pre>\n<p>这不是好起来了嘛：</p>\n<ol>\n<li>干掉了嵌套调用，采用了链式挂载，逻辑上清晰了一些。</li>\n<li>合并处理错误，在最后统一 <code>catch</code> 并执行。</li>\n</ol>\n<h5 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async / await\"></a>async / await</h5><p>Emmm，还不是一坨代码。好吧，再来看看终极方案 <code>async/await</code>：</p>\n<pre><code class=\"javascript\">const do = async () =&gt; &#123;\n  try &#123;\n    const token = await post(&#39;/user/login&#39;);\n    const userInfo = await get(&#39;/user/info&#39;);\n    const createArticleResult = await post(&#39;/articles/create&#39;);\n    const articlesList = await get(&#39;/articles/list&#39;);\n    ...\n  &#125; catch (err) &#123;\n    console.error(&#39;又报错了啦：&#39; + err)\n  &#125;\n&#125;</code></pre>\n<p>直接屏蔽了异步逻辑，改用同步方式。</p>\n<p><img  src=\"https://pic.izhaoo.com/wa.png\"  ><span class=\"image-caption\">wo</span></p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - MDN</a></p>\n</blockquote>\n<p>工欲善其事，必先利其器。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>那么 <code>Promise</code> 是如何工作的呢？主要是采用了 <strong>延迟绑定</strong> 和 <strong>返值穿透</strong> 两种思想。</p>\n<h5 id=\"延迟绑定\"><a href=\"#延迟绑定\" class=\"headerlink\" title=\"延迟绑定\"></a>延迟绑定</h5><pre><code class=\"javascript\">const p = new Promise((resolve, reject) =&gt; &#123; resolve(&#39;ok&#39;) &#125;)\n\n...\n\np.then((value) =&gt; &#123; console.log(value) &#125;)</code></pre>\n<p>可以看到先创建了应该 <code>Promise</code> 对象，此时还没有绑定 <code>回调函数</code>。创建完对象之后，可以处理其他代码逻辑。直到调用 <code>then</code> 处理执行逻辑的时候，我们才将 <code>回调函数</code> 进行绑定。<strong>创建对象</strong> 和 <strong>绑定回调</strong> 实现了分离解耦。</p>\n<h5 id=\"返值穿透\"><a href=\"#返值穿透\" class=\"headerlink\" title=\"返值穿透\"></a>返值穿透</h5><pre><code class=\"javascript\">const p1 = new Promise((resolve, reject) =&gt; &#123;\n  resolve(1)\n&#125;)\n\nconst p2 = p1.then((value) =&gt; &#123;\n  const p2 = new Promise((resolve, reject) =&gt; &#123;\n    resolve(value + 1)\n  &#125;)\n  return p2\n&#125;)\n\np2.then((value) =&gt; &#123;\n  console.log(value)\n&#125;)</code></pre>\n<p>可以看到，在 <code>p1</code> 的回调函数中我们创建了一个新的 <code>Promise</code> 对象 <code>p2</code>，将它 <code>return</code> 到了最外层并被接受。每层回调函数的返回值始终可以穿透到最外层，这样就可以保证 <code>返回值</code> 始终可控，不会陷入循环中。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p><img  src=\"https://pic.izhaoo.com/show-me-your-code.gif\"  ><span class=\"image-caption\">上代码啊</span></p>\n<p>其实经典方法的实现原理都大同小异：状态流传递、队列缓存回调……</p>\n<pre><code class=\"javascript\">const PENDING = &#39;PENDING&#39;\nconst FULFILLED = &#39;FULFILLED&#39;\nconst REJECTED = &#39;REJECTED&#39;\n\nclass MyPromise &#123;\n  constructor(handle) &#123;\n    this._status = PENDING\n    this._value = undefined\n    //回调函数队列\n    this._fulfilledQueues = []\n    this._rejectedQueues = []\n    //执行handle\n    try &#123;\n      handle(this._resolve.bind(this), this._reject.bind(this))\n    &#125; catch (err) &#123;\n      this._reject(err)\n    &#125;\n  &#125;\n\n  // resovle时执行的函数\n  _resolve(val) &#123;\n    if (this._status !== PENDING) return\n    this._status = FULFILLED\n    this._value = val\n  &#125;\n\n  // reject时执行的函数\n  _reject(err) &#123;\n    if (this._status !== PENDING) return\n    this._status = REJECTED\n    this._value = err\n  &#125;\n\n  // then方法\n  then(onFulfilled, onRejected) &#123;\n    const &#123; _value, _status &#125; = this\n    return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123;\n      //成功时执行的函数\n      let fulfilled = value =&gt; &#123;\n        try &#123;\n          let res = onFulfilled(value);\n          if (res instanceof MyPromise) &#123;\n            // 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调\n            res.then(onFulfilledNext, onRejectedNext)\n          &#125; else &#123;\n            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数\n            onFulfilledNext(res)\n          &#125;\n        &#125; catch (err) &#123;\n          onRejectedNext(err)\n        &#125;\n      &#125;\n      //失败时执行的函数\n      let rejected = error =&gt; &#123;\n        try &#123;\n          let res = onRejected(error);\n          if (res instanceof MyPromise) &#123;\n            // 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调\n            res.then(onFulfilledNext, onRejectedNext)\n          &#125; else &#123;\n            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数\n            onFulfilledNext(res)\n          &#125;\n        &#125; catch (err) &#123;\n          onRejectedNext(err)\n        &#125;\n      &#125;\n      switch (_status) &#123;\n        //状态为pending时将回调函数推入队列进行缓存\n        case PENDING:\n          this._fulfilledQueues.push(fulfilled)\n          this._rejectedQueues.push(rejected)\n          break\n        //状态改变时执行回调函数\n        case FULFILLED:\n          fulfilled(_value)\n          break\n        case REJECTED:\n          rejected(_value)\n          break\n      &#125;\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5dcb775c518825574d214b89\">大厂面试必考知识点：Promise 注册微任务和执行过程</a></p>\n</blockquote>\n","more":"<h3 id=\"面试环节\"><a href=\"#面试环节\" class=\"headerlink\" title=\"面试环节\"></a>面试环节</h3><p>先来看一段代码：</p>\n<pre><code class=\"javascript\">new Promise((resolve, reject) =&gt; &#123;\n  console.log(&quot;外部promise&quot;);\n  resolve();\n&#125;)\n  .then(() =&gt; &#123;\n    console.log(&quot;外部第一个then&quot;);\n    new Promise((resolve, reject) =&gt; &#123;\n      console.log(&quot;内部promise&quot;);\n      resolve();\n    &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;内部第一个then&quot;);\n      &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;内部第二个then&quot;);\n      &#125;);\n    return new Promise((resolve, reject) =&gt; &#123;\n      console.log(&quot;内部promise2&quot;);\n      resolve();\n    &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;内部第一个then2&quot;);\n      &#125;)\n      .then(() =&gt; &#123;\n        console.log(&quot;内部第二个then2&quot;);\n      &#125;);\n  &#125;)\n  .then(() =&gt; &#123;\n    console.log(&quot;外部第二个then&quot;);\n  &#125;);</code></pre>\n<p>Are you ok ? 恭喜你被谷歌录取了 : 行了行了下一位</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><p>首先我们先来了解一下引入 <code>Promise</code> 的必要性。</p>\n<h5 id=\"回调地狱\"><a href=\"#回调地狱\" class=\"headerlink\" title=\"回调地狱\"></a>回调地狱</h5><p>曾几何时<del>（现在也是）</del>，我们的异步代码是这样的：</p>\n<pre><code class=\"javascript\">post(&#39;/user/login&#39;, function (err, data) &#123;\n  if (err) return err;\n  get(&#39;/user/info&#39;, function (err, data) &#123;\n    if (err) return err;\n    post(&#39;/articles/create&#39;, function (err, data) &#123;\n      if (err) return err;\n      get(&#39;/articles/list&#39;, function (err, data) &#123;\n        ...\n      &#125;);\n    &#125;);\n  &#125;);\n&#125;);</code></pre>\n<p>这就是大家津津乐道的 <strong>回调地狱</strong> 了，主要有以下几个问题：</p>\n<ol>\n<li>嵌套太深，逻辑复杂：每层的回调函数的业务逻辑都依赖于上层执行的返回结果，嵌套层次多了之后，代码可读性很差。</li>\n<li>错误处理麻烦：每层的回调函数都需要传入两个状态（失败、成功），且每一层都需要对错误进行单独处理，没有统一的错误处理机制。</li>\n<li>上下文环境乱：有的时候我们想处理上层环境（调用 <code>this</code>），却发现绑定不到，只能使用 <code>var _this = this;</code> 这样的 hack 方法。</li>\n</ol>\n<h5 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h5><p>这时候天空一声巨响，<code>Promise</code> 闪亮登场，救人民与水深火热之中。代码如下：</p>\n<pre><code class=\"javascript\">//用 Promise 封装接口\nconst post = (url) =&gt; &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    post(url, (err, data) =&gt; &#123;\n      err &amp;&amp; reject(err)\n      resolve(data)\n    &#125;)\n  &#125;)\n&#125;\n\n//调用逻辑\npost(&#39;/user/login&#39;)\n  .then(data =&gt; get(&#39;/user/info&#39;))\n  .then(data =&gt; post(&#39;/articles/create&#39;))\n  .then(data =&gt; get(&#39;/articles/list&#39;))\n  .then(...)\n  .catch(err =&gt; console.error(&#39;报错了啦：&#39; + err))</code></pre>\n<p>这不是好起来了嘛：</p>\n<ol>\n<li>干掉了嵌套调用，采用了链式挂载，逻辑上清晰了一些。</li>\n<li>合并处理错误，在最后统一 <code>catch</code> 并执行。</li>\n</ol>\n<h5 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async / await\"></a>async / await</h5><p>Emmm，还不是一坨代码。好吧，再来看看终极方案 <code>async/await</code>：</p>\n<pre><code class=\"javascript\">const do = async () =&gt; &#123;\n  try &#123;\n    const token = await post(&#39;/user/login&#39;);\n    const userInfo = await get(&#39;/user/info&#39;);\n    const createArticleResult = await post(&#39;/articles/create&#39;);\n    const articlesList = await get(&#39;/articles/list&#39;);\n    ...\n  &#125; catch (err) &#123;\n    console.error(&#39;又报错了啦：&#39; + err)\n  &#125;\n&#125;</code></pre>\n<p>直接屏蔽了异步逻辑，改用同步方式。</p>\n<p><img  src=\"https://pic.izhaoo.com/wa.png\"  ><span class=\"image-caption\">wo</span></p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - MDN</a></p>\n</blockquote>\n<p>工欲善其事，必先利其器。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>那么 <code>Promise</code> 是如何工作的呢？主要是采用了 <strong>延迟绑定</strong> 和 <strong>返值穿透</strong> 两种思想。</p>\n<h5 id=\"延迟绑定\"><a href=\"#延迟绑定\" class=\"headerlink\" title=\"延迟绑定\"></a>延迟绑定</h5><pre><code class=\"javascript\">const p = new Promise((resolve, reject) =&gt; &#123; resolve(&#39;ok&#39;) &#125;)\n\n...\n\np.then((value) =&gt; &#123; console.log(value) &#125;)</code></pre>\n<p>可以看到先创建了应该 <code>Promise</code> 对象，此时还没有绑定 <code>回调函数</code>。创建完对象之后，可以处理其他代码逻辑。直到调用 <code>then</code> 处理执行逻辑的时候，我们才将 <code>回调函数</code> 进行绑定。<strong>创建对象</strong> 和 <strong>绑定回调</strong> 实现了分离解耦。</p>\n<h5 id=\"返值穿透\"><a href=\"#返值穿透\" class=\"headerlink\" title=\"返值穿透\"></a>返值穿透</h5><pre><code class=\"javascript\">const p1 = new Promise((resolve, reject) =&gt; &#123;\n  resolve(1)\n&#125;)\n\nconst p2 = p1.then((value) =&gt; &#123;\n  const p2 = new Promise((resolve, reject) =&gt; &#123;\n    resolve(value + 1)\n  &#125;)\n  return p2\n&#125;)\n\np2.then((value) =&gt; &#123;\n  console.log(value)\n&#125;)</code></pre>\n<p>可以看到，在 <code>p1</code> 的回调函数中我们创建了一个新的 <code>Promise</code> 对象 <code>p2</code>，将它 <code>return</code> 到了最外层并被接受。每层回调函数的返回值始终可以穿透到最外层，这样就可以保证 <code>返回值</code> 始终可控，不会陷入循环中。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><p><img  src=\"https://pic.izhaoo.com/show-me-your-code.gif\"  ><span class=\"image-caption\">上代码啊</span></p>\n<p>其实经典方法的实现原理都大同小异：状态流传递、队列缓存回调……</p>\n<pre><code class=\"javascript\">const PENDING = &#39;PENDING&#39;\nconst FULFILLED = &#39;FULFILLED&#39;\nconst REJECTED = &#39;REJECTED&#39;\n\nclass MyPromise &#123;\n  constructor(handle) &#123;\n    this._status = PENDING\n    this._value = undefined\n    //回调函数队列\n    this._fulfilledQueues = []\n    this._rejectedQueues = []\n    //执行handle\n    try &#123;\n      handle(this._resolve.bind(this), this._reject.bind(this))\n    &#125; catch (err) &#123;\n      this._reject(err)\n    &#125;\n  &#125;\n\n  // resovle时执行的函数\n  _resolve(val) &#123;\n    if (this._status !== PENDING) return\n    this._status = FULFILLED\n    this._value = val\n  &#125;\n\n  // reject时执行的函数\n  _reject(err) &#123;\n    if (this._status !== PENDING) return\n    this._status = REJECTED\n    this._value = err\n  &#125;\n\n  // then方法\n  then(onFulfilled, onRejected) &#123;\n    const &#123; _value, _status &#125; = this\n    return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123;\n      //成功时执行的函数\n      let fulfilled = value =&gt; &#123;\n        try &#123;\n          let res = onFulfilled(value);\n          if (res instanceof MyPromise) &#123;\n            // 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调\n            res.then(onFulfilledNext, onRejectedNext)\n          &#125; else &#123;\n            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数\n            onFulfilledNext(res)\n          &#125;\n        &#125; catch (err) &#123;\n          onRejectedNext(err)\n        &#125;\n      &#125;\n      //失败时执行的函数\n      let rejected = error =&gt; &#123;\n        try &#123;\n          let res = onRejected(error);\n          if (res instanceof MyPromise) &#123;\n            // 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调\n            res.then(onFulfilledNext, onRejectedNext)\n          &#125; else &#123;\n            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数\n            onFulfilledNext(res)\n          &#125;\n        &#125; catch (err) &#123;\n          onRejectedNext(err)\n        &#125;\n      &#125;\n      switch (_status) &#123;\n        //状态为pending时将回调函数推入队列进行缓存\n        case PENDING:\n          this._fulfilledQueues.push(fulfilled)\n          this._rejectedQueues.push(rejected)\n          break\n        //状态改变时执行回调函数\n        case FULFILLED:\n          fulfilled(_value)\n          break\n        case REJECTED:\n          rejected(_value)\n          break\n      &#125;\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5dcb775c518825574d214b89\">大厂面试必考知识点：Promise 注册微任务和执行过程</a></p>\n</blockquote>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"js","path":"api/tags/js.json"}]}