{"title":"JavaScript - 设计模式","slug":"design-pattern-note","date":"2020-02-29T01:58:17.000Z","updated":"2020-05-22T02:29:34.000Z","comments":true,"path":"api/articles/design-pattern-note.json","realPath":"/2020/02/29/design-pattern-note/","excerpt":"摘录JavaScript常用设计模式，其实这些平时有意无意都在使用，借着面试机会整理一下。","covers":null,"cover":"https://pic.izhaoo.com/20200228081718.jpg","content":"<p>摘录<code>JavaScript</code>常用设计模式，其实这些平时有意无意都在使用，借着面试机会整理一下。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"行为类\"><a href=\"#行为类\" class=\"headerlink\" title=\"行为类\"></a>行为类</h1><h3 id=\"发布-订阅模式-Publish-Subscribe\"><a href=\"#发布-订阅模式-Publish-Subscribe\" class=\"headerlink\" title=\"发布-订阅模式 Publish-Subscribe\"></a>发布-订阅模式 Publish-Subscribe</h3><pre><code class=\"javascript\"></code></pre>\n<h1 id=\"创建类\"><a href=\"#创建类\" class=\"headerlink\" title=\"创建类\"></a>创建类</h1><h3 id=\"构造器模式-Constructor\"><a href=\"#构造器模式-Constructor\" class=\"headerlink\" title=\"构造器模式 Constructor\"></a>构造器模式 Constructor</h3><p>类似于面向对象中的构造器，由于ES5中没有很好的对象概念，现以函数的形式模拟，本质一样。</p>\n<pre><code class=\"javascript\">// ES5\n\nfunction Student(name, gender) &#123;\n  this.name = name;\n  this.gender = gender\n  this.print = function () &#123;\n    console.log(&#39;姓名:&#39; + this.name + &#39;性别:&#39; + this.gender);\n  &#125;\n&#125;\n\nvar zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);\nvar pp = new Student(&#39;小欣&#39;, &#39;female&#39;);\n\nzhaoo.print();\npp.print();</code></pre>\n<pre><code class=\"javascript\">// ES6\n\nclass Student &#123;\n  constructor(name, gender) &#123;\n    this.name = name;\n    this.gender = gender;\n  &#125;\n\n  print = () =&gt; &#123;\n    console.log(`姓名:$&#123;this.name&#125;性别:$&#123;this.gender&#125;`);\n  &#125;\n&#125;\n\nconst zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);\nconst pp = new Student(&#39;小欣&#39;, &#39;female&#39;);\n\nzhaoo.print();\npp.print();</code></pre>\n<h3 id=\"原型模式-Prototype\"><a href=\"#原型模式-Prototype\" class=\"headerlink\" title=\"原型模式 Prototype\"></a>原型模式 Prototype</h3><p>之前对象中，每创建一个实例，内部都会实例化一份<code>print</code>函数，造成资源浪费。现使用<code>prototype</code>构造对象原型，相当于对<code>print</code>函数的一个引用，进行了优化。</p>\n<pre><code class=\"javascript\">// ES5\n\nfunction Student(name, gender) &#123;\n  this.name = name;\n  this.gender = gender\n&#125;\n\nStudent.prototype.print = function () &#123;\n  console.log(&#39;姓名:&#39; + this.name + &#39;性别:&#39; + this.gender);\n&#125;\n\nvar zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);\nvar pp = new Student(&#39;小欣&#39;, &#39;female&#39;);\n\nzhaoo.print();\npp.print();</code></pre>\n<h3 id=\"建造者模式-Builder\"><a href=\"#建造者模式-Builder\" class=\"headerlink\" title=\"建造者模式 Builder\"></a>建造者模式 Builder</h3><p>在对象外封装一层构建器，作为基层控制者，使用<code>set</code>、<code>get</code>等方法创建获取内部变量。在对象内部可以方便对成员变量进行操纵、校验等操作，更加灵活、规范。</p>\n<pre><code class=\"javascript\">// ES5\n\nvar failCount = 0;\n\nfunction Student() &#123;&#125;\n\nfunction StudentBuilder() &#123;\n  this.student = new Student();\n\n  StudentBuilder.prototype.setName = function (name) &#123;\n    this.student.name = name;\n  &#125;\n\n  StudentBuilder.prototype.setScore = function (score) &#123;\n    if (typeof score !== Number)\n      throw (&#39;score 输入类型错误&#39;);\n    this.student.score = score;\n  &#125;\n\n  StudentBuilder.prototype.build = function () &#123;\n    if (this.student.score &lt; 60)\n      failCount++;\n    return this.student;\n  &#125;\n&#125;\n\nvar builder = new StudentBuilder();\nbuilder.setName(&#39;小兆&#39;);\nbuilder.setScore(90);\nvar zhaoo = builder.build();\n\nvar builder = new StudentBuilder();\nbuilder.setName(&#39;小欣&#39;);\nbuilder.setScore(59);\nvar pp = builder.build();\n\nconsole.log(&#39;挂科人数:&#39; + failCount);</code></pre>\n<pre><code class=\"javascript\">// ES6\n\nlet failCount = 0;\n\nclass Student &#123;&#125;\n\nclass StudentBuilder &#123;\n  constructor() &#123;\n    this.student = new Student();\n  &#125;\n\n  setName(name) &#123;\n    this.student.name = name;\n  &#125;\n\n  setScore(score) &#123;\n    if (typeof score !== Number)\n      throw (&#39;score 输入类型错误&#39;);\n    this.student.score = score;\n  &#125;\n\n  build() &#123;\n    if (this.student.score &lt; 60)\n      failCount++;\n    return this.student;\n  &#125;\n&#125;\n\nconst builder = new StudentBuilder();\nbuilder.setName(&#39;小兆&#39;);\nbuilder.setScore(90);\nconst zhaoo = builder.build();\n\nconst builder = new StudentBuilder();\nbuilder.setName(&#39;小欣&#39;);\nbuilder.setScore(59);\nconst pp = builder.build();\n\nconsole.log(&#39;挂科人数:&#39; + failCount);</code></pre>\n<h3 id=\"工厂模式-Factory\"><a href=\"#工厂模式-Factory\" class=\"headerlink\" title=\"工厂模式 Factory\"></a>工厂模式 Factory</h3><p>包装并返回对象。</p>\n<pre><code class=\"javascript\">// ES5\n\nfunction Student(name, subjects) &#123;\n  this.name = name;\n  this.subjects = subjects;\n&#125;\n\nfunction factory(name, type) &#123;\n  switch (type) &#123;\n    case &#39;软件工程&#39;:\n      return new Student(name, [&#39;数据结构&#39;, &#39;设计模式&#39;, &#39;算法设计&#39;]);\n      break;\n    case &#39;城乡规划&#39;:\n      return new Student(name, [&#39;城市道路与交通规划&#39;, &#39;村镇规划设计&#39;, &#39;城市建设史与规划史&#39;]);\n      break;\n    default:\n      throw &#39;没这个专业，别瞎填&#39;;\n  &#125;\n&#125;\n\nvar zhaoo = factory(&#39;小兆&#39;, &#39;软件工程&#39;);\nvar pp = factory(&#39;小欣&#39;, &#39;城乡规划&#39;);</code></pre>\n<pre><code class=\"javascript\">// ES6\n\nclass Student &#123;\n  constructor(name, subjects) &#123;\n    this.name = name;\n    this.subjects = subjects;\n  &#125;\n&#125;\n\nconst factory = (name, type) =&gt; &#123;\n  switch (type) &#123;\n    case &#39;软件工程&#39;:\n      return new Student(name, [&#39;数据结构&#39;, &#39;设计模式&#39;, &#39;算法设计&#39;]);\n      break;\n    case &#39;城乡规划&#39;:\n      return new Student(name, [&#39;城市道路与交通规划&#39;, &#39;村镇规划设计&#39;, &#39;城市建设史与规划史&#39;]);\n      break;\n    default:\n      throw &#39;没这个专业，别瞎填&#39;;\n  &#125;\n&#125;\n\nconst zhaoo = factory(&#39;小兆&#39;, &#39;软件工程&#39;);\nconst pp = factory(&#39;小欣&#39;, &#39;城乡规划&#39;);</code></pre>\n<h3 id=\"抽象工程模式-AbstractFactory\"><a href=\"#抽象工程模式-AbstractFactory\" class=\"headerlink\" title=\"抽象工程模式 AbstractFactory\"></a>抽象工程模式 AbstractFactory</h3><p>工厂外再包一层工厂，用于上产工厂。</p>\n<pre><code class=\"javascript\">function Student() &#123;\n  this.intro = &#39;我是个学生&#39;;\n&#125;\n\nfunction Teacher() &#123;\n  this.intro = &#39;我是个老师&#39;;\n&#125;\n\nfunction StudentFactory() &#123;\n  return new Student();\n&#125;\n\nfunction TeacherFactory() &#123;\n  return new Teacher();\n&#125;\n\nfunction Producer(factory) &#123;\n  switch (factory) &#123;\n    case &#39;student&#39;:\n      return StudentFactory;\n      break;\n    case &#39;teacher&#39;:\n      return TeacherFactory;\n      break;\n    default:\n      throw &#39;没这个工厂&#39;;\n      break;\n  &#125;\n&#125;\n\nvar sFactory = Producer(&#39;student&#39;);\nvar zhaoo = factory(&#39;小兆&#39;);\nvar tFactory = Producer(&#39;teacher&#39;);\nvar pp = factory(&#39;小潘&#39;);</code></pre>\n<h3 id=\"单例模式-Singleton\"><a href=\"#单例模式-Singleton\" class=\"headerlink\" title=\"单例模式 Singleton\"></a>单例模式 Singleton</h3><p>避免重复创建，实例化对象前先判断是已实例化。</p>\n<pre><code class=\"javascript\">// ES5\n\nfunction Singleton() &#123;\n  if (Singleton.instance)\n    return Singleton.instance;\n  else &#123;\n    this.countdown = 60;\n    Singleton.instance = this;\n  &#125;\n&#125;\n\nvar s1 = new Singleton();\nvar s2 = new new Singleton();</code></pre>\n<pre><code class=\"javascript\">// ES6\n\nclass Singleton &#123;\n  constructor () &#123;\n    if (Singleton.instance)\n      return Singleton.instance;\n    else &#123;\n      this.countdown = 60;\n      Singleton.instance = this;\n    &#125;\n  &#125;\n&#125;\n\nconst s1 = new Singleton();\nconst s2 = new new Singleton();</code></pre>\n<p>未完待续……</p>\n","more":"<h1 id=\"行为类\"><a href=\"#行为类\" class=\"headerlink\" title=\"行为类\"></a>行为类</h1><h3 id=\"发布-订阅模式-Publish-Subscribe\"><a href=\"#发布-订阅模式-Publish-Subscribe\" class=\"headerlink\" title=\"发布-订阅模式 Publish-Subscribe\"></a>发布-订阅模式 Publish-Subscribe</h3><pre><code class=\"javascript\"></code></pre>\n<h1 id=\"创建类\"><a href=\"#创建类\" class=\"headerlink\" title=\"创建类\"></a>创建类</h1><h3 id=\"构造器模式-Constructor\"><a href=\"#构造器模式-Constructor\" class=\"headerlink\" title=\"构造器模式 Constructor\"></a>构造器模式 Constructor</h3><p>类似于面向对象中的构造器，由于ES5中没有很好的对象概念，现以函数的形式模拟，本质一样。</p>\n<pre><code class=\"javascript\">// ES5\n\nfunction Student(name, gender) &#123;\n  this.name = name;\n  this.gender = gender\n  this.print = function () &#123;\n    console.log(&#39;姓名:&#39; + this.name + &#39;性别:&#39; + this.gender);\n  &#125;\n&#125;\n\nvar zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);\nvar pp = new Student(&#39;小欣&#39;, &#39;female&#39;);\n\nzhaoo.print();\npp.print();</code></pre>\n<pre><code class=\"javascript\">// ES6\n\nclass Student &#123;\n  constructor(name, gender) &#123;\n    this.name = name;\n    this.gender = gender;\n  &#125;\n\n  print = () =&gt; &#123;\n    console.log(`姓名:$&#123;this.name&#125;性别:$&#123;this.gender&#125;`);\n  &#125;\n&#125;\n\nconst zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);\nconst pp = new Student(&#39;小欣&#39;, &#39;female&#39;);\n\nzhaoo.print();\npp.print();</code></pre>\n<h3 id=\"原型模式-Prototype\"><a href=\"#原型模式-Prototype\" class=\"headerlink\" title=\"原型模式 Prototype\"></a>原型模式 Prototype</h3><p>之前对象中，每创建一个实例，内部都会实例化一份<code>print</code>函数，造成资源浪费。现使用<code>prototype</code>构造对象原型，相当于对<code>print</code>函数的一个引用，进行了优化。</p>\n<pre><code class=\"javascript\">// ES5\n\nfunction Student(name, gender) &#123;\n  this.name = name;\n  this.gender = gender\n&#125;\n\nStudent.prototype.print = function () &#123;\n  console.log(&#39;姓名:&#39; + this.name + &#39;性别:&#39; + this.gender);\n&#125;\n\nvar zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);\nvar pp = new Student(&#39;小欣&#39;, &#39;female&#39;);\n\nzhaoo.print();\npp.print();</code></pre>\n<h3 id=\"建造者模式-Builder\"><a href=\"#建造者模式-Builder\" class=\"headerlink\" title=\"建造者模式 Builder\"></a>建造者模式 Builder</h3><p>在对象外封装一层构建器，作为基层控制者，使用<code>set</code>、<code>get</code>等方法创建获取内部变量。在对象内部可以方便对成员变量进行操纵、校验等操作，更加灵活、规范。</p>\n<pre><code class=\"javascript\">// ES5\n\nvar failCount = 0;\n\nfunction Student() &#123;&#125;\n\nfunction StudentBuilder() &#123;\n  this.student = new Student();\n\n  StudentBuilder.prototype.setName = function (name) &#123;\n    this.student.name = name;\n  &#125;\n\n  StudentBuilder.prototype.setScore = function (score) &#123;\n    if (typeof score !== Number)\n      throw (&#39;score 输入类型错误&#39;);\n    this.student.score = score;\n  &#125;\n\n  StudentBuilder.prototype.build = function () &#123;\n    if (this.student.score &lt; 60)\n      failCount++;\n    return this.student;\n  &#125;\n&#125;\n\nvar builder = new StudentBuilder();\nbuilder.setName(&#39;小兆&#39;);\nbuilder.setScore(90);\nvar zhaoo = builder.build();\n\nvar builder = new StudentBuilder();\nbuilder.setName(&#39;小欣&#39;);\nbuilder.setScore(59);\nvar pp = builder.build();\n\nconsole.log(&#39;挂科人数:&#39; + failCount);</code></pre>\n<pre><code class=\"javascript\">// ES6\n\nlet failCount = 0;\n\nclass Student &#123;&#125;\n\nclass StudentBuilder &#123;\n  constructor() &#123;\n    this.student = new Student();\n  &#125;\n\n  setName(name) &#123;\n    this.student.name = name;\n  &#125;\n\n  setScore(score) &#123;\n    if (typeof score !== Number)\n      throw (&#39;score 输入类型错误&#39;);\n    this.student.score = score;\n  &#125;\n\n  build() &#123;\n    if (this.student.score &lt; 60)\n      failCount++;\n    return this.student;\n  &#125;\n&#125;\n\nconst builder = new StudentBuilder();\nbuilder.setName(&#39;小兆&#39;);\nbuilder.setScore(90);\nconst zhaoo = builder.build();\n\nconst builder = new StudentBuilder();\nbuilder.setName(&#39;小欣&#39;);\nbuilder.setScore(59);\nconst pp = builder.build();\n\nconsole.log(&#39;挂科人数:&#39; + failCount);</code></pre>\n<h3 id=\"工厂模式-Factory\"><a href=\"#工厂模式-Factory\" class=\"headerlink\" title=\"工厂模式 Factory\"></a>工厂模式 Factory</h3><p>包装并返回对象。</p>\n<pre><code class=\"javascript\">// ES5\n\nfunction Student(name, subjects) &#123;\n  this.name = name;\n  this.subjects = subjects;\n&#125;\n\nfunction factory(name, type) &#123;\n  switch (type) &#123;\n    case &#39;软件工程&#39;:\n      return new Student(name, [&#39;数据结构&#39;, &#39;设计模式&#39;, &#39;算法设计&#39;]);\n      break;\n    case &#39;城乡规划&#39;:\n      return new Student(name, [&#39;城市道路与交通规划&#39;, &#39;村镇规划设计&#39;, &#39;城市建设史与规划史&#39;]);\n      break;\n    default:\n      throw &#39;没这个专业，别瞎填&#39;;\n  &#125;\n&#125;\n\nvar zhaoo = factory(&#39;小兆&#39;, &#39;软件工程&#39;);\nvar pp = factory(&#39;小欣&#39;, &#39;城乡规划&#39;);</code></pre>\n<pre><code class=\"javascript\">// ES6\n\nclass Student &#123;\n  constructor(name, subjects) &#123;\n    this.name = name;\n    this.subjects = subjects;\n  &#125;\n&#125;\n\nconst factory = (name, type) =&gt; &#123;\n  switch (type) &#123;\n    case &#39;软件工程&#39;:\n      return new Student(name, [&#39;数据结构&#39;, &#39;设计模式&#39;, &#39;算法设计&#39;]);\n      break;\n    case &#39;城乡规划&#39;:\n      return new Student(name, [&#39;城市道路与交通规划&#39;, &#39;村镇规划设计&#39;, &#39;城市建设史与规划史&#39;]);\n      break;\n    default:\n      throw &#39;没这个专业，别瞎填&#39;;\n  &#125;\n&#125;\n\nconst zhaoo = factory(&#39;小兆&#39;, &#39;软件工程&#39;);\nconst pp = factory(&#39;小欣&#39;, &#39;城乡规划&#39;);</code></pre>\n<h3 id=\"抽象工程模式-AbstractFactory\"><a href=\"#抽象工程模式-AbstractFactory\" class=\"headerlink\" title=\"抽象工程模式 AbstractFactory\"></a>抽象工程模式 AbstractFactory</h3><p>工厂外再包一层工厂，用于上产工厂。</p>\n<pre><code class=\"javascript\">function Student() &#123;\n  this.intro = &#39;我是个学生&#39;;\n&#125;\n\nfunction Teacher() &#123;\n  this.intro = &#39;我是个老师&#39;;\n&#125;\n\nfunction StudentFactory() &#123;\n  return new Student();\n&#125;\n\nfunction TeacherFactory() &#123;\n  return new Teacher();\n&#125;\n\nfunction Producer(factory) &#123;\n  switch (factory) &#123;\n    case &#39;student&#39;:\n      return StudentFactory;\n      break;\n    case &#39;teacher&#39;:\n      return TeacherFactory;\n      break;\n    default:\n      throw &#39;没这个工厂&#39;;\n      break;\n  &#125;\n&#125;\n\nvar sFactory = Producer(&#39;student&#39;);\nvar zhaoo = factory(&#39;小兆&#39;);\nvar tFactory = Producer(&#39;teacher&#39;);\nvar pp = factory(&#39;小潘&#39;);</code></pre>\n<h3 id=\"单例模式-Singleton\"><a href=\"#单例模式-Singleton\" class=\"headerlink\" title=\"单例模式 Singleton\"></a>单例模式 Singleton</h3><p>避免重复创建，实例化对象前先判断是已实例化。</p>\n<pre><code class=\"javascript\">// ES5\n\nfunction Singleton() &#123;\n  if (Singleton.instance)\n    return Singleton.instance;\n  else &#123;\n    this.countdown = 60;\n    Singleton.instance = this;\n  &#125;\n&#125;\n\nvar s1 = new Singleton();\nvar s2 = new new Singleton();</code></pre>\n<pre><code class=\"javascript\">// ES6\n\nclass Singleton &#123;\n  constructor () &#123;\n    if (Singleton.instance)\n      return Singleton.instance;\n    else &#123;\n      this.countdown = 60;\n      Singleton.instance = this;\n    &#125;\n  &#125;\n&#125;\n\nconst s1 = new Singleton();\nconst s2 = new new Singleton();</code></pre>\n<p>未完待续……</p>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}