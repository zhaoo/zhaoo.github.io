{"title":"React - 生命周期","slug":"react-lifecycle","date":"2020-05-17T10:48:06.000Z","updated":"2020-05-20T02:09:44.000Z","comments":true,"path":"api/articles/react-lifecycle.json","realPath":"/2020/05/17/react-lifecycle/","excerpt":"对 React 中 生命周期 的一些理解。","covers":null,"cover":"https://pic.izhaoo.com/2020051895102.jpg","content":"<p>对 React 中 <code>生命周期</code> 的一些理解。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"v16-0-前的生命周期\"><a href=\"#v16-0-前的生命周期\" class=\"headerlink\" title=\"v16.0 前的生命周期\"></a>v16.0 前的生命周期</h1><p><strong>组件挂载：</strong> componentWillMount -&gt; render -&gt; componentDidMount</p>\n<p><strong>组件更新（state 变化）：</strong> shoudlComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p>\n<p><strong>组件更新（props 变化）：</strong> componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p>\n<p><strong>组件销毁：</strong> componentWillUnmount</p>\n<h3 id=\"Initialization-初始化阶段\"><a href=\"#Initialization-初始化阶段\" class=\"headerlink\" title=\"Initialization (初始化阶段)\"></a>Initialization (初始化阶段)</h3><h5 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h5><p><strong>触发时机：</strong></p>\n<p>子组件实例化时。</p>\n<p><strong>解析：</strong></p>\n<p>实际上将 <code>constructor</code> 作为生命周期钩子这一说法并不确切。<code>constructor</code> 作为 class(ES6) 中的 <em>构造方法</em> ，通过 <code>new</code> 关键字创建对象实例时会自动调用，用于返回实例对象（this）。React 的生命周期定义在 <code>Component</code> 这个基类中，在执行 <code>constructor()</code> 后组件才会继承 <code>Component</code> 基类，才可以使用这些生命周期方法。所以 <code>hooks</code> 范式中没有生命周期，因为没有使用对象（返回函数组件）。</p>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li><p><code>super(props)</code> 用于调用父组件（基类）的构造方法，并将父组件的 <code>props</code> 注入给子组件。</p>\n</li>\n<li><p>在 <code>this.state</code> 中可以初始化 <code>state</code> 内容。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>(props);<br>    <span class=\"hljs-built_in\">this</span>.state = &#123;<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;anonymous&#x27;</span>,<br>      <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;male&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Mounting-挂载阶段\"><a href=\"#Mounting-挂载阶段\" class=\"headerlink\" title=\"Mounting (挂载阶段)\"></a>Mounting (挂载阶段)</h3><p>该阶段在组件第一次挂载时触发，只会执行一次。</p>\n<h5 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount()\"></a>componentWillMount()</h5><p><strong>触发时机：</strong></p>\n<p>组件挂在到 DOM <em>前</em> 执行，只会执行一次。</p>\n<p><strong>解析：</strong></p>\n<p><em>不建议</em> 在该阶段请求网络数据，因为一般网络请求都是以 <em>异步</em> 的方式进行，不能保证在 <code>render()</code> 前就完成，可能还没获取到数据就已经执行了渲染操作。至于初始化 <code>state</code>，可以，但没必要，因为放到 <code>constructor</code> 更直观且主流。</p>\n<p><strong>使用场景：</strong></p>\n<p>不过 <code>componentWillMount</code> 也不是一无是处，在服务端渲染（SSR）中生命周期不全，<code>componentWillMount</code> 是唯一的生命周期钩子。</p>\n<h5 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h5><p>第一次渲染。</p>\n<h5 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount()\"></a>componentDidMount()</h5><p><strong>触发时机：</strong></p>\n<p>组件挂在到 DOM <em>后</em> 执行，只会触发一次。</p>\n<p><strong>解析：</strong></p>\n<p>在该阶段执行网络请求最合理，因为这时候已经完成渲染，有足够的时间去执行 <em>异步请求</em>，能够保证数据安全，且获取数据后一般会进行 <code>setState()</code> 操作，触发重渲染。</p>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li><p>执行网络请求，获取远程数据。</p>\n</li>\n<li><p>使用 <code>setState()</code> 保存状态，触发重渲染。</p>\n</li>\n<li><p>使用 <code>ref</code> 操作 DOM，因为这时候组件已经挂载到 DOM 上了。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> getUserInfo();<br>  <span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">userInfo</span>: res.data &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Updation-更新阶段\"><a href=\"#Updation-更新阶段\" class=\"headerlink\" title=\"Updation (更新阶段)\"></a>Updation (更新阶段)</h3><p>该阶段在组件 <code>state</code> 或 <code>props</code> 改变时触发，可能触发多次。</p>\n<h5 id=\"componentWillReceiveProps-nextProps\"><a href=\"#componentWillReceiveProps-nextProps\" class=\"headerlink\" title=\"componentWillReceiveProps(nextProps)\"></a>componentWillReceiveProps(nextProps)</h5><p><strong>触发时机：</strong></p>\n<p>组件挂载完成后，接收到新的 <code>props</code> 时触发，此时还没有触发重渲染。</p>\n<p><strong>解析：</strong></p>\n<p>可以通过 <code>this.props</code> 获取之前的属性，通过 <code>nextProps</code> 获取之后的属性，进行对比或其他操作。由于此时还没有触发重渲染，所以可以将一些 <em>网络请求</em> 放到这里执行，减轻负担，达到一定的优化效果。</p>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li><p>对比 <code>this.props</code> 和 <code>nextProps</code>，执行后续操作。</p>\n</li>\n<li><p>子组件发起 <em>网络请求</em>。</p>\n</li>\n</ol>\n<h5 id=\"shouldComponentUpdate-nextProps-nextState\"><a href=\"#shouldComponentUpdate-nextProps-nextState\" class=\"headerlink\" title=\"shouldComponentUpdate(nextProps, nextState)\"></a>shouldComponentUpdate(nextProps, nextState)</h5><p><strong>触发时机：</strong></p>\n<p>组件挂载完成后，在接收到新的 <code>state</code> 或 <code>props</code> 时触发。</p>\n<p><strong>解析：</strong></p>\n<p>可以通过对比 <code>this.state</code> 和 <code>nextState</code>，或 <code>this.props</code> 和 <code>nextProps</code> 是否发生变化，返回一个 <code>boolean</code> 值决定是否重渲染（返回 <code>true</code> 表示本次允许重渲染，返回 <code>false</code> 表示本次不允许重渲染），从而达到性能优化的目的。建议只进行浅比较（不递归比较嵌套对象），因为比较层级过多的话消耗掉会大于重渲染，得不偿失。在 React 15.3 后引入了 <code>PureComponent</code>，代替了 <code>shouldComponentUpdate</code> 自动进行 <em>浅比较</em> 判断 <code>state</code> 或 <code>props</code> 是否更新，从而优化性能，不过它只对子组件生效。</p>\n<p><strong>使用场景：</strong></p>\n<p>判断 <code>state</code> 或 <code>props</code> 是否更新，从而决定是否渲染，达到性能优化的目的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">shouldComponentUpdate</span>(<span class=\"hljs-params\">nextProps, nextState</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> nextState.user !== <span class=\"hljs-built_in\">this</span>.state.user<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"componentWillUpdate-nextProps-nextState\"><a href=\"#componentWillUpdate-nextProps-nextState\" class=\"headerlink\" title=\"componentWillUpdate(nextProps, nextState)\"></a>componentWillUpdate(nextProps, nextState)</h5><p><strong>触发时机：</strong></p>\n<p><code>state</code> 或 <code>props</code> 发生变化时，重渲染 <em>前</em> 触发。</p>\n<p><strong>解析：</strong></p>\n<p><em>不能</em> 在这个生命周期调用 <code>setState()</code>，因为每次调用 <code>setState()</code> 触发重渲染都会经过这一生命周期，周而复始引起死循环。另外，若是 <code>shouldComponentUpdate</code> 返回了 <code>fasle</code> 阻止了重渲染，则不会触发 <code>componentWillUpdate</code>。</p>\n<p><strong>使用场景：</strong></p>\n<p>可以做一些动画或 DOM 的初始化。</p>\n<h5 id=\"render-1\"><a href=\"#render-1\" class=\"headerlink\" title=\"render()\"></a>render()</h5><p>重渲染。</p>\n<h5 id=\"componentDidUpdate-prevProps-prevState\"><a href=\"#componentDidUpdate-prevProps-prevState\" class=\"headerlink\" title=\"componentDidUpdate(prevProps, prevState)\"></a>componentDidUpdate(prevProps, prevState)</h5><p><strong>触发时机：</strong></p>\n<p>组件更新，重渲染 <em>后</em> 触发。</p>\n<p><strong>解析：</strong></p>\n<p>若是 <code>shouldComponentUpdate</code> 返回了 <code>fasle</code> 阻止了重渲染，也不会执行到这一步。</p>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li>使用 <code>ref</code> 操作 DOM，因为这时候组件已经重渲染，且挂载到 DOM 上了。</li>\n</ol>\n<p><strong>解析：</strong></p>\n<h3 id=\"Unmounting-卸载阶段\"><a href=\"#Unmounting-卸载阶段\" class=\"headerlink\" title=\"Unmounting (卸载阶段)\"></a>Unmounting (卸载阶段)</h3><p>该阶段在组件销毁时触发，只会触发一次。</p>\n<h5 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount()\"></a>componentWillUnmount()</h5><p><strong>触发时机：</strong></p>\n<p>在组件卸载之前执行。</p>\n<p><strong>解析：</strong></p>\n<p>由于是单页面应用（SPA），在路由跳转后，页面内的一些 <em>事件订阅</em> 或 <em>定时操作</em> 并不会主动销毁，任然留在内存中继续执行。此时会引发内存泄漏，影响性能；此外，由于组件已经销毁，<code>this</code> 已经解除链接，获取不到相关引用变量， 会造成 <code>underfined</code> 报错。</p>\n<p><strong>使用场景：</strong></p>\n<p>执行一些必要的清理操作，例如 <code>clearInterval()</code> 、 <code>clearTimeout()</code>等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">componentWillUnmount</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-built_in\">this</span>.timer &amp;&amp; <span class=\"hljs-built_in\">clearTimeout</span>(<span class=\"hljs-built_in\">this</span>.timer);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"v16-0-后的生命周期\"><a href=\"#v16-0-后的生命周期\" class=\"headerlink\" title=\"v16.0 后的生命周期\"></a>v16.0 后的生命周期</h1><p>在 React 16.0 之后，废除了 <code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code> 这三个生命周期，将在 17.0 之后移除。因为引入了 <code>fiber</code> 架构，<code>render()</code> 前一阶段可以被打断并且执行多次，导致这些生命周期变得不可控。不过为了平滑升级，暂时可以使用 <code>UNSAFE_componentWillMount</code>、<code>UNSAFE_componentWillUpdate</code>、<code>UNSAFE_componentWillReceiveProps</code> 代替。</p>\n<p>取而代之引入了两个新的生命周期：<code>getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code>。</p>\n<p><strong>组件挂载：</strong> getDerivedStateFromProps -&gt; render -&gt; componentDidMount</p>\n<p><strong>组件更新：</strong> getDerivedStateFromProps -&gt; shoudlComponentUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate</p>\n<p><strong>组件销毁：</strong> componentWillUnmount</p>\n<h5 id=\"static-getDerivedStateFromProps-nextProps-prevState\"><a href=\"#static-getDerivedStateFromProps-nextProps-prevState\" class=\"headerlink\" title=\"static getDerivedStateFromProps(nextProps, prevState)\"></a>static getDerivedStateFromProps(nextProps, prevState)</h5><p><strong>触发时机：</strong></p>\n<p>每次渲染前调用。（包括首次渲染和重渲染）</p>\n<p><strong>解析：</strong></p>\n<p>首先这是一个 <code>static</code> 方法，不能使用 <code>this</code> 访问对象属性，所以也就不能直接使用 <code>this.setState()</code> 方法了。该方法接受两个参数，<code>nextProps</code> 指接收的新属性，<code>prevState</code> 指当前状态，最后返回一个对象来更新当前 <code>state</code> 状态，如果不需要渲染则返回一个 <code>null</code>。本质上就是讲传入的 <code>props</code> 映射到 <code>state</code>。</p>\n<p><strong>使用场景：</strong></p>\n<p>替代之前的 <code>componentWillReceiveProps</code> 等生命周期。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromProps</span>(<span class=\"hljs-params\">nextProps, prevState</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123;username&#125; = nextProps;<br>  <span class=\"hljs-keyword\">if</span> (username !== prevState.username) &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      username,<br>    &#125;;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"getSnapshotBeforeUpdate-prevProps-prevState\"><a href=\"#getSnapshotBeforeUpdate-prevProps-prevState\" class=\"headerlink\" title=\"getSnapshotBeforeUpdate(prevProps, prevState)\"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h5><p><strong>触发时机：</strong></p>\n<p>在渲染后，<code>componentDidUpdate</code> 前调用。</p>\n<p><strong>解析：</strong></p>\n<p>该方法接受两个参数，<code>prevProps</code> 指当前属性，<code>prevState</code> 指当前状态，最后返回一个对象传递给 <code>componentDidUpdate</code>。</p>\n<p><strong>使用场景：</strong></p>\n<p>用于替代 <code>componentWillUpdate</code> 等生命周期。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/45091185\">React渲染原理</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000016494335?utm_source=tag-newest\">react如何通过shouldComponentUpdate来减少重复渲染</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://juejin.im/post/5b6f1800f265da282d45a79a\">我对 React v16.4 生命周期的理解</a></p>\n</blockquote>\n","more":"<h1 id=\"v16-0-前的生命周期\"><a href=\"#v16-0-前的生命周期\" class=\"headerlink\" title=\"v16.0 前的生命周期\"></a>v16.0 前的生命周期</h1><p><strong>组件挂载：</strong> componentWillMount -&gt; render -&gt; componentDidMount</p>\n<p><strong>组件更新（state 变化）：</strong> shoudlComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p>\n<p><strong>组件更新（props 变化）：</strong> componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p>\n<p><strong>组件销毁：</strong> componentWillUnmount</p>\n<h3 id=\"Initialization-初始化阶段\"><a href=\"#Initialization-初始化阶段\" class=\"headerlink\" title=\"Initialization (初始化阶段)\"></a>Initialization (初始化阶段)</h3><h5 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h5><p><strong>触发时机：</strong></p>\n<p>子组件实例化时。</p>\n<p><strong>解析：</strong></p>\n<p>实际上将 <code>constructor</code> 作为生命周期钩子这一说法并不确切。<code>constructor</code> 作为 class(ES6) 中的 <em>构造方法</em> ，通过 <code>new</code> 关键字创建对象实例时会自动调用，用于返回实例对象（this）。React 的生命周期定义在 <code>Component</code> 这个基类中，在执行 <code>constructor()</code> 后组件才会继承 <code>Component</code> 基类，才可以使用这些生命周期方法。所以 <code>hooks</code> 范式中没有生命周期，因为没有使用对象（返回函数组件）。</p>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li><p><code>super(props)</code> 用于调用父组件（基类）的构造方法，并将父组件的 <code>props</code> 注入给子组件。</p>\n</li>\n<li><p>在 <code>this.state</code> 中可以初始化 <code>state</code> 内容。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">props</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>(props);<br>    <span class=\"hljs-built_in\">this</span>.state = &#123;<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;anonymous&#x27;</span>,<br>      <span class=\"hljs-attr\">gender</span>: <span class=\"hljs-string\">&#x27;male&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Mounting-挂载阶段\"><a href=\"#Mounting-挂载阶段\" class=\"headerlink\" title=\"Mounting (挂载阶段)\"></a>Mounting (挂载阶段)</h3><p>该阶段在组件第一次挂载时触发，只会执行一次。</p>\n<h5 id=\"componentWillMount\"><a href=\"#componentWillMount\" class=\"headerlink\" title=\"componentWillMount()\"></a>componentWillMount()</h5><p><strong>触发时机：</strong></p>\n<p>组件挂在到 DOM <em>前</em> 执行，只会执行一次。</p>\n<p><strong>解析：</strong></p>\n<p><em>不建议</em> 在该阶段请求网络数据，因为一般网络请求都是以 <em>异步</em> 的方式进行，不能保证在 <code>render()</code> 前就完成，可能还没获取到数据就已经执行了渲染操作。至于初始化 <code>state</code>，可以，但没必要，因为放到 <code>constructor</code> 更直观且主流。</p>\n<p><strong>使用场景：</strong></p>\n<p>不过 <code>componentWillMount</code> 也不是一无是处，在服务端渲染（SSR）中生命周期不全，<code>componentWillMount</code> 是唯一的生命周期钩子。</p>\n<h5 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h5><p>第一次渲染。</p>\n<h5 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount()\"></a>componentDidMount()</h5><p><strong>触发时机：</strong></p>\n<p>组件挂在到 DOM <em>后</em> 执行，只会触发一次。</p>\n<p><strong>解析：</strong></p>\n<p>在该阶段执行网络请求最合理，因为这时候已经完成渲染，有足够的时间去执行 <em>异步请求</em>，能够保证数据安全，且获取数据后一般会进行 <code>setState()</code> 操作，触发重渲染。</p>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li><p>执行网络请求，获取远程数据。</p>\n</li>\n<li><p>使用 <code>setState()</code> 保存状态，触发重渲染。</p>\n</li>\n<li><p>使用 <code>ref</code> 操作 DOM，因为这时候组件已经挂载到 DOM 上了。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-title\">componentDidMount</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> getUserInfo();<br>  <span class=\"hljs-built_in\">this</span>.setState(&#123; <span class=\"hljs-attr\">userInfo</span>: res.data &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Updation-更新阶段\"><a href=\"#Updation-更新阶段\" class=\"headerlink\" title=\"Updation (更新阶段)\"></a>Updation (更新阶段)</h3><p>该阶段在组件 <code>state</code> 或 <code>props</code> 改变时触发，可能触发多次。</p>\n<h5 id=\"componentWillReceiveProps-nextProps\"><a href=\"#componentWillReceiveProps-nextProps\" class=\"headerlink\" title=\"componentWillReceiveProps(nextProps)\"></a>componentWillReceiveProps(nextProps)</h5><p><strong>触发时机：</strong></p>\n<p>组件挂载完成后，接收到新的 <code>props</code> 时触发，此时还没有触发重渲染。</p>\n<p><strong>解析：</strong></p>\n<p>可以通过 <code>this.props</code> 获取之前的属性，通过 <code>nextProps</code> 获取之后的属性，进行对比或其他操作。由于此时还没有触发重渲染，所以可以将一些 <em>网络请求</em> 放到这里执行，减轻负担，达到一定的优化效果。</p>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li><p>对比 <code>this.props</code> 和 <code>nextProps</code>，执行后续操作。</p>\n</li>\n<li><p>子组件发起 <em>网络请求</em>。</p>\n</li>\n</ol>\n<h5 id=\"shouldComponentUpdate-nextProps-nextState\"><a href=\"#shouldComponentUpdate-nextProps-nextState\" class=\"headerlink\" title=\"shouldComponentUpdate(nextProps, nextState)\"></a>shouldComponentUpdate(nextProps, nextState)</h5><p><strong>触发时机：</strong></p>\n<p>组件挂载完成后，在接收到新的 <code>state</code> 或 <code>props</code> 时触发。</p>\n<p><strong>解析：</strong></p>\n<p>可以通过对比 <code>this.state</code> 和 <code>nextState</code>，或 <code>this.props</code> 和 <code>nextProps</code> 是否发生变化，返回一个 <code>boolean</code> 值决定是否重渲染（返回 <code>true</code> 表示本次允许重渲染，返回 <code>false</code> 表示本次不允许重渲染），从而达到性能优化的目的。建议只进行浅比较（不递归比较嵌套对象），因为比较层级过多的话消耗掉会大于重渲染，得不偿失。在 React 15.3 后引入了 <code>PureComponent</code>，代替了 <code>shouldComponentUpdate</code> 自动进行 <em>浅比较</em> 判断 <code>state</code> 或 <code>props</code> 是否更新，从而优化性能，不过它只对子组件生效。</p>\n<p><strong>使用场景：</strong></p>\n<p>判断 <code>state</code> 或 <code>props</code> 是否更新，从而决定是否渲染，达到性能优化的目的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">shouldComponentUpdate</span>(<span class=\"hljs-params\">nextProps, nextState</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> nextState.user !== <span class=\"hljs-built_in\">this</span>.state.user<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"componentWillUpdate-nextProps-nextState\"><a href=\"#componentWillUpdate-nextProps-nextState\" class=\"headerlink\" title=\"componentWillUpdate(nextProps, nextState)\"></a>componentWillUpdate(nextProps, nextState)</h5><p><strong>触发时机：</strong></p>\n<p><code>state</code> 或 <code>props</code> 发生变化时，重渲染 <em>前</em> 触发。</p>\n<p><strong>解析：</strong></p>\n<p><em>不能</em> 在这个生命周期调用 <code>setState()</code>，因为每次调用 <code>setState()</code> 触发重渲染都会经过这一生命周期，周而复始引起死循环。另外，若是 <code>shouldComponentUpdate</code> 返回了 <code>fasle</code> 阻止了重渲染，则不会触发 <code>componentWillUpdate</code>。</p>\n<p><strong>使用场景：</strong></p>\n<p>可以做一些动画或 DOM 的初始化。</p>\n<h5 id=\"render-1\"><a href=\"#render-1\" class=\"headerlink\" title=\"render()\"></a>render()</h5><p>重渲染。</p>\n<h5 id=\"componentDidUpdate-prevProps-prevState\"><a href=\"#componentDidUpdate-prevProps-prevState\" class=\"headerlink\" title=\"componentDidUpdate(prevProps, prevState)\"></a>componentDidUpdate(prevProps, prevState)</h5><p><strong>触发时机：</strong></p>\n<p>组件更新，重渲染 <em>后</em> 触发。</p>\n<p><strong>解析：</strong></p>\n<p>若是 <code>shouldComponentUpdate</code> 返回了 <code>fasle</code> 阻止了重渲染，也不会执行到这一步。</p>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li>使用 <code>ref</code> 操作 DOM，因为这时候组件已经重渲染，且挂载到 DOM 上了。</li>\n</ol>\n<p><strong>解析：</strong></p>\n<h3 id=\"Unmounting-卸载阶段\"><a href=\"#Unmounting-卸载阶段\" class=\"headerlink\" title=\"Unmounting (卸载阶段)\"></a>Unmounting (卸载阶段)</h3><p>该阶段在组件销毁时触发，只会触发一次。</p>\n<h5 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount()\"></a>componentWillUnmount()</h5><p><strong>触发时机：</strong></p>\n<p>在组件卸载之前执行。</p>\n<p><strong>解析：</strong></p>\n<p>由于是单页面应用（SPA），在路由跳转后，页面内的一些 <em>事件订阅</em> 或 <em>定时操作</em> 并不会主动销毁，任然留在内存中继续执行。此时会引发内存泄漏，影响性能；此外，由于组件已经销毁，<code>this</code> 已经解除链接，获取不到相关引用变量， 会造成 <code>underfined</code> 报错。</p>\n<p><strong>使用场景：</strong></p>\n<p>执行一些必要的清理操作，例如 <code>clearInterval()</code> 、 <code>clearTimeout()</code>等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">componentWillUnmount</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>  <span class=\"hljs-built_in\">this</span>.timer &amp;&amp; <span class=\"hljs-built_in\">clearTimeout</span>(<span class=\"hljs-built_in\">this</span>.timer);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"v16-0-后的生命周期\"><a href=\"#v16-0-后的生命周期\" class=\"headerlink\" title=\"v16.0 后的生命周期\"></a>v16.0 后的生命周期</h1><p>在 React 16.0 之后，废除了 <code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code> 这三个生命周期，将在 17.0 之后移除。因为引入了 <code>fiber</code> 架构，<code>render()</code> 前一阶段可以被打断并且执行多次，导致这些生命周期变得不可控。不过为了平滑升级，暂时可以使用 <code>UNSAFE_componentWillMount</code>、<code>UNSAFE_componentWillUpdate</code>、<code>UNSAFE_componentWillReceiveProps</code> 代替。</p>\n<p>取而代之引入了两个新的生命周期：<code>getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code>。</p>\n<p><strong>组件挂载：</strong> getDerivedStateFromProps -&gt; render -&gt; componentDidMount</p>\n<p><strong>组件更新：</strong> getDerivedStateFromProps -&gt; shoudlComponentUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate</p>\n<p><strong>组件销毁：</strong> componentWillUnmount</p>\n<h5 id=\"static-getDerivedStateFromProps-nextProps-prevState\"><a href=\"#static-getDerivedStateFromProps-nextProps-prevState\" class=\"headerlink\" title=\"static getDerivedStateFromProps(nextProps, prevState)\"></a>static getDerivedStateFromProps(nextProps, prevState)</h5><p><strong>触发时机：</strong></p>\n<p>每次渲染前调用。（包括首次渲染和重渲染）</p>\n<p><strong>解析：</strong></p>\n<p>首先这是一个 <code>static</code> 方法，不能使用 <code>this</code> 访问对象属性，所以也就不能直接使用 <code>this.setState()</code> 方法了。该方法接受两个参数，<code>nextProps</code> 指接收的新属性，<code>prevState</code> 指当前状态，最后返回一个对象来更新当前 <code>state</code> 状态，如果不需要渲染则返回一个 <code>null</code>。本质上就是讲传入的 <code>props</code> 映射到 <code>state</code>。</p>\n<p><strong>使用场景：</strong></p>\n<p>替代之前的 <code>componentWillReceiveProps</code> 等生命周期。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getDerivedStateFromProps</span>(<span class=\"hljs-params\">nextProps, prevState</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123;username&#125; = nextProps;<br>  <span class=\"hljs-keyword\">if</span> (username !== prevState.username) &#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>      username,<br>    &#125;;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"getSnapshotBeforeUpdate-prevProps-prevState\"><a href=\"#getSnapshotBeforeUpdate-prevProps-prevState\" class=\"headerlink\" title=\"getSnapshotBeforeUpdate(prevProps, prevState)\"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h5><p><strong>触发时机：</strong></p>\n<p>在渲染后，<code>componentDidUpdate</code> 前调用。</p>\n<p><strong>解析：</strong></p>\n<p>该方法接受两个参数，<code>prevProps</code> 指当前属性，<code>prevState</code> 指当前状态，最后返回一个对象传递给 <code>componentDidUpdate</code>。</p>\n<p><strong>使用场景：</strong></p>\n<p>用于替代 <code>componentWillUpdate</code> 等生命周期。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/45091185\">React渲染原理</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000016494335?utm_source=tag-newest\">react如何通过shouldComponentUpdate来减少重复渲染</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://juejin.im/post/5b6f1800f265da282d45a79a\">我对 React v16.4 生命周期的理解</a></p>\n</blockquote>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"React","path":"api/tags/React.json"}]}