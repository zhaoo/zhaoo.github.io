{"title":"Django - 自定义模板标签","slug":"django-template-tags","date":"2018-09-01T11:44:44.000Z","updated":"2020-04-30T03:54:10.000Z","comments":true,"path":"api/articles/django-template-tags.json","realPath":"/2018/09/01/django-template-tags/","excerpt":"这几天一直在折腾Django的博客项目，今天本想着做完收尾工作就传到Gayhub上，没想到遇一大坑，各种填坑ing……","covers":null,"cover":"https://pic.izhaoo.com/20191211065828.jpg","content":"<p>这几天一直在折腾Django的博客项目，今天本想着做完收尾工作就传到Gayhub上，没想到遇一大坑，各种填坑ing……</p>\n<span id=\"more\"></span>\n\n<h1 id=\"挖坑\"><a href=\"#挖坑\" class=\"headerlink\" title=\"挖坑\"></a>挖坑</h1><p>先来简单介绍一下本人亲手挖的坑：</p>\n<p>本博客项目<code>templates</code>中的所有页面都通过<code>block</code>标签继承自<code>base.html</code>母模板。其中继承了<code>&lt;title&gt;</code>、<code>&lt;keywords&gt;</code>、<code>&lt;discription&gt;</code>等内容。开发阶段这些内容都是直接写死在<code>base.html</code>母模板中了，现在准备上线，总不能让用户（假设有用户）去模板中改吧？所以我得将它写到数据库中，让用户可以在后台方便地设置博客的<code>名称</code>、<code>关键词</code>、<code>描述</code>等内容，各大博客也都是这么做的。燃鹅，事情并非那么简单，随之而来的是各种坑，作为处女座代码狗，我TM必须解决……</p>\n<h1 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h1><p>尝试了各种方法之后，终于完美解决了问题。用到了自定义模板标签（simple_tag）这个方法。详细解释在后文（踩坑）中，这里只做演示：</p>\n<p>在<code>index</code>应用中新建<code>index_tags.py</code>文件：</p>\n<pre><code>from django import template    # 自定义模板是template类下的对象，所以先引入\nfrom index.models import Setting\n\nregister = template.Library()    # 为对象起个别名\n\n@register.simple_tag    # 定义标签的类型\ndef get_setting():    # 定义标签\n    return Setting.objects.last()    # 标签的作用，返回Setting数据库的一条记录</code></pre><p>在<code>blog</code>项目下的<code>setting.py</code>中改写以下几行：</p>\n<pre><code>TEMPLATES = [\n    &#123;\n        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,\n        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],\n        &#39;APP_DIRS&#39;: True,\n        &#39;OPTIONS&#39;: &#123;\n            &#39;context_processors&#39;: [\n                &#39;django.template.context_processors.debug&#39;,\n                &#39;django.template.context_processors.request&#39;,\n                &#39;django.contrib.auth.context_processors.auth&#39;,\n                &#39;django.contrib.messages.context_processors.messages&#39;,\n            ],\n            &#39;libraries&#39;: &#123;\n                &#39;index_tags&#39;:  &#39;index.index_tags&#39;,    # 注册index_tags这个库\n            &#125;\n        &#125;,\n    &#125;,\n]</code></pre><p>在<code>base.html</code>开头写上以下两行：</p>\n<pre><code>｛% load index_tags %｝    # 引入index_tags自定义库\n｛% get_setting as setting %｝    # 使用get_setting自定义模板函数，并定义别名为setting</code></pre><p>然后我们就可以在<code>base.html</code>母模板中使用<code>&#123;&#123; setting.title &#125;&#125;</code>、<code>&#123;&#123; setting.keywords &#125;&#125;</code>、<code>&#123;&#123; setting.discription &#125;&#125;</code>动态渲染数据库中的内容了。</p>\n<p>其他页面只需继承<code>base.html</code>页面即可。例如<code>文章页面</code>中，描述应该是该文章的摘要，我们就用<code>｛% block discription %｝ ｛% endblock %｝</code>重载母模板;而<code>标签页面</code>中，描述无需更改，那就什么都不做呗。</p>\n<h1 id=\"一号坑，重写视图函数\"><a href=\"#一号坑，重写视图函数\" class=\"headerlink\" title=\"一号坑，重写视图函数\"></a>一号坑，重写视图函数</h1><p>最简单的思路就是在<code>views.py</code>中的各个<code>视图函数</code>中调取数据库，然后再渲染到各个模板中，模板中再通过<code>block</code>标签重写这部分内容。不行，上帝告诉我，不能这么做。一次次地调数据库，渲染模板，重写模板，页面渲染速度拉下一大截。Veto!</p>\n<h1 id=\"二号坑，渲染母模板\"><a href=\"#二号坑，渲染母模板\" class=\"headerlink\" title=\"二号坑，渲染母模板\"></a>二号坑，渲染母模板</h1><p>稍微拐个弯，很自然的就能想到，我们只需要改写<code>base.html</code>母模板，动态渲染数据库中的内容即可。Yo, 看似很完美，Thinkphp中就可以用此方法完美解决。燃鹅，在Django中此路不通。因为Django的视图函数是接收到<code>request</code>请求后再进行后续的操作，我们的<code>base.html</code>是在模板中直接继承的，根本没有发送额外的请求，使用就不能单独的进行逻辑处理。Veto!！</p>\n<pre><code>def archive(request):\n    articles = Article.objects.order_by(&#39;-post_time&#39;).all()\n    return render(request, &#39;archive.html&#39;, &#123;&#39;articles&#39;: articles&#125;)\n\n# 例如这段代码是渲染文章内容的，可以看到必须要传入了一个请求（request）</code></pre><h1 id=\"三号坑，重写render方法\"><a href=\"#三号坑，重写render方法\" class=\"headerlink\" title=\"三号坑，重写render方法\"></a>三号坑，重写render方法</h1><p>终于百度到一条可行的解决方法，思路很清奇。重写Django框架中的render方法，让它能动态渲染<code>base.html</code>。确实很牛，从根本解决了问题，强烈建议Django官方填了这个坑。但是我这儿还是不想用，因为重写<code>render</code>方法之后我依然需要改动许多调用<code>render</code>的地方。Veto!!!</p>\n<p><a href=\"https://www.cnblogs.com/helloxiaoyu/p/8559206.html\">django解决其他页面继承不了base模板的动态数据的问题</a></p>\n<h1 id=\"四号坑，伪造请求\"><a href=\"#四号坑，伪造请求\" class=\"headerlink\" title=\"四号坑，伪造请求\"></a>四号坑，伪造请求</h1><p>前面不是提到Django需要请求才能渲染页面嘛，<code>base.html</code>又不能传入请求。突然想到，我们直接伪造一个请求传进去不就好了。奇技淫巧，还是不想这么干。Veto!!!!</p>\n<h1 id=\"五号坑，引入自定义模板标签\"><a href=\"#五号坑，引入自定义模板标签\" class=\"headerlink\" title=\"五号坑，引入自定义模板标签\"></a>五号坑，引入自定义模板标签</h1><p>终于，谷歌到了一个方法，引入自定义标签。简单解释一下，<code>base.html</code>在是可以使用模板标签的，像<code>｛% if %｝</code>、<code>｛% for %｝</code>这种。Django又提供了自定义模板标签，就是说我们可以自己造个模板标签，就叫<code>｛% get_setting %｝</code>吧，这个标签的功能就是从数据库获取<code>博客名称</code>、<code>博客关键词</code>（存在Setting这个数据表中）这些内容。<br>一切突然光明了~查了下官方文档，开始操作。</p>\n<p>在<code>index</code>这个应用中新建一个<code>index_tags.py</code>文件：</p>\n<pre><code># ！注意，此为错误示范\n\nfrom django import template    # 自定义模板是template类下的对象，所以先引入\nfrom index.models import Setting\n\nregister = template.Library()    # 为对象起个别名\n\n@register.template_tags    # 定义标签的类型\ndef get_setting():    # 定义标签\n    return Setting.objects.last()    # 标签的作用，返回Setting数据库的一条记录</code></pre><p>然后在<code>base.html</code>开头导入这个库：</p>\n<pre><code>｛% load index_tags %｝</code></pre><p>然后就报错了：</p>\n<pre><code>&#39;index_tags&#39; is not a registered tag library.</code></pre><p>什么鬼，照着官方文档的方法没错啊？逛了圈谷歌后才发现，原来在模板中引入自定义库前需要先到项目的<code>setting.py</code>中注册这个库。Django官方文档怎么没说啊啊啊。</p>\n<p>打开<code>blog</code>项目下的<code>setting.py</code>文件，改写如下几行：</p>\n<pre><code>TEMPLATES = [\n    &#123;\n        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,\n        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],\n        &#39;APP_DIRS&#39;: True,\n        &#39;OPTIONS&#39;: &#123;\n            &#39;context_processors&#39;: [\n                &#39;django.template.context_processors.debug&#39;,\n                &#39;django.template.context_processors.request&#39;,\n                &#39;django.contrib.auth.context_processors.auth&#39;,\n                &#39;django.contrib.messages.context_processors.messages&#39;,\n            ],\n            &#39;libraries&#39;: &#123;\n                &#39;index_tags&#39;:  &#39;index.index_tags&#39;,    # 注册index_tags这个库\n            &#125;\n        &#125;,\n    &#125;,\n]</code></pre><h1 id=\"六号坑，不存在分配标签\"><a href=\"#六号坑，不存在分配标签\" class=\"headerlink\" title=\"六号坑，不存在分配标签\"></a>六号坑，不存在分配标签</h1><p>先说明一下，Django中有三种自定义标签，分别是：</p>\n<ul>\n<li>simple_tag (简单标签)  – 单次使用只能返回一层数据。在这里就是说，不能从数据库中返回一条记录作为实例再渲染，只能分别定义N个简单标签分别渲染N条字段。</li>\n<li>inclusion_tag (内涵标签)  – 可以在标签中传入参数，这里没用。</li>\n<li>assignment_tag (分配标签) – 使用标签时可以定义别名，作为一个实例，然后可以渲染这个实例的各个对象。在这里就是说可以直接定义一个分配标签，然后在模板中定义一个别名“setting”，然后用 分配渲染。</li>\n</ul>\n<p>承接上文，我们注册了<code>index_tags.py</code>这个库后终于可以在模板引入了。在模板中使用自定义标签<code>｛% get_setting %｝</code>。又报错了：</p>\n<pre><code>AttributeError: &#39;Library&#39; object has no attribute &#39;assignment_tag&#39;</code></pre><p>什么鬼？找不到<code>assignment_tag</code>对象？？？还是照着官方的用法没错啊，网上也都是这个干的。走投无路，忍无可忍，翻了一下Django框架的源码。发现……<code>Django2</code>已经启用了<code>assignment_tag</code>和<code>inclusion_tag</code>标签，所有标签的功能都集中在了<code>simple_tag</code>上。想想也是啊，一个标签可以解决的事情，干嘛撑得用三个。Django官方改进功能值得表扬，但是你TM能不能顺便更新一下文档，您的最新文档不是误导我们嘛！差点气晕！Veto!!!!!!</p>\n<p>填完各种天坑之后，终于完美解决了这个问题，头发掉了一大把，还是很开心。呵呵……呵呵呵……真是醉了……承接上文[填坑]</p>\n","more":"<h1 id=\"挖坑\"><a href=\"#挖坑\" class=\"headerlink\" title=\"挖坑\"></a>挖坑</h1><p>先来简单介绍一下本人亲手挖的坑：</p>\n<p>本博客项目<code>templates</code>中的所有页面都通过<code>block</code>标签继承自<code>base.html</code>母模板。其中继承了<code>&lt;title&gt;</code>、<code>&lt;keywords&gt;</code>、<code>&lt;discription&gt;</code>等内容。开发阶段这些内容都是直接写死在<code>base.html</code>母模板中了，现在准备上线，总不能让用户（假设有用户）去模板中改吧？所以我得将它写到数据库中，让用户可以在后台方便地设置博客的<code>名称</code>、<code>关键词</code>、<code>描述</code>等内容，各大博客也都是这么做的。燃鹅，事情并非那么简单，随之而来的是各种坑，作为处女座代码狗，我TM必须解决……</p>\n<h1 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h1><p>尝试了各种方法之后，终于完美解决了问题。用到了自定义模板标签（simple_tag）这个方法。详细解释在后文（踩坑）中，这里只做演示：</p>\n<p>在<code>index</code>应用中新建<code>index_tags.py</code>文件：</p>\n<pre><code>from django import template    # 自定义模板是template类下的对象，所以先引入\nfrom index.models import Setting\n\nregister = template.Library()    # 为对象起个别名\n\n@register.simple_tag    # 定义标签的类型\ndef get_setting():    # 定义标签\n    return Setting.objects.last()    # 标签的作用，返回Setting数据库的一条记录</code></pre><p>在<code>blog</code>项目下的<code>setting.py</code>中改写以下几行：</p>\n<pre><code>TEMPLATES = [\n    &#123;\n        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,\n        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],\n        &#39;APP_DIRS&#39;: True,\n        &#39;OPTIONS&#39;: &#123;\n            &#39;context_processors&#39;: [\n                &#39;django.template.context_processors.debug&#39;,\n                &#39;django.template.context_processors.request&#39;,\n                &#39;django.contrib.auth.context_processors.auth&#39;,\n                &#39;django.contrib.messages.context_processors.messages&#39;,\n            ],\n            &#39;libraries&#39;: &#123;\n                &#39;index_tags&#39;:  &#39;index.index_tags&#39;,    # 注册index_tags这个库\n            &#125;\n        &#125;,\n    &#125;,\n]</code></pre><p>在<code>base.html</code>开头写上以下两行：</p>\n<pre><code>｛% load index_tags %｝    # 引入index_tags自定义库\n｛% get_setting as setting %｝    # 使用get_setting自定义模板函数，并定义别名为setting</code></pre><p>然后我们就可以在<code>base.html</code>母模板中使用<code>&#123;&#123; setting.title &#125;&#125;</code>、<code>&#123;&#123; setting.keywords &#125;&#125;</code>、<code>&#123;&#123; setting.discription &#125;&#125;</code>动态渲染数据库中的内容了。</p>\n<p>其他页面只需继承<code>base.html</code>页面即可。例如<code>文章页面</code>中，描述应该是该文章的摘要，我们就用<code>｛% block discription %｝ ｛% endblock %｝</code>重载母模板;而<code>标签页面</code>中，描述无需更改，那就什么都不做呗。</p>\n<h1 id=\"一号坑，重写视图函数\"><a href=\"#一号坑，重写视图函数\" class=\"headerlink\" title=\"一号坑，重写视图函数\"></a>一号坑，重写视图函数</h1><p>最简单的思路就是在<code>views.py</code>中的各个<code>视图函数</code>中调取数据库，然后再渲染到各个模板中，模板中再通过<code>block</code>标签重写这部分内容。不行，上帝告诉我，不能这么做。一次次地调数据库，渲染模板，重写模板，页面渲染速度拉下一大截。Veto!</p>\n<h1 id=\"二号坑，渲染母模板\"><a href=\"#二号坑，渲染母模板\" class=\"headerlink\" title=\"二号坑，渲染母模板\"></a>二号坑，渲染母模板</h1><p>稍微拐个弯，很自然的就能想到，我们只需要改写<code>base.html</code>母模板，动态渲染数据库中的内容即可。Yo, 看似很完美，Thinkphp中就可以用此方法完美解决。燃鹅，在Django中此路不通。因为Django的视图函数是接收到<code>request</code>请求后再进行后续的操作，我们的<code>base.html</code>是在模板中直接继承的，根本没有发送额外的请求，使用就不能单独的进行逻辑处理。Veto!！</p>\n<pre><code>def archive(request):\n    articles = Article.objects.order_by(&#39;-post_time&#39;).all()\n    return render(request, &#39;archive.html&#39;, &#123;&#39;articles&#39;: articles&#125;)\n\n# 例如这段代码是渲染文章内容的，可以看到必须要传入了一个请求（request）</code></pre><h1 id=\"三号坑，重写render方法\"><a href=\"#三号坑，重写render方法\" class=\"headerlink\" title=\"三号坑，重写render方法\"></a>三号坑，重写render方法</h1><p>终于百度到一条可行的解决方法，思路很清奇。重写Django框架中的render方法，让它能动态渲染<code>base.html</code>。确实很牛，从根本解决了问题，强烈建议Django官方填了这个坑。但是我这儿还是不想用，因为重写<code>render</code>方法之后我依然需要改动许多调用<code>render</code>的地方。Veto!!!</p>\n<p><a href=\"https://www.cnblogs.com/helloxiaoyu/p/8559206.html\">django解决其他页面继承不了base模板的动态数据的问题</a></p>\n<h1 id=\"四号坑，伪造请求\"><a href=\"#四号坑，伪造请求\" class=\"headerlink\" title=\"四号坑，伪造请求\"></a>四号坑，伪造请求</h1><p>前面不是提到Django需要请求才能渲染页面嘛，<code>base.html</code>又不能传入请求。突然想到，我们直接伪造一个请求传进去不就好了。奇技淫巧，还是不想这么干。Veto!!!!</p>\n<h1 id=\"五号坑，引入自定义模板标签\"><a href=\"#五号坑，引入自定义模板标签\" class=\"headerlink\" title=\"五号坑，引入自定义模板标签\"></a>五号坑，引入自定义模板标签</h1><p>终于，谷歌到了一个方法，引入自定义标签。简单解释一下，<code>base.html</code>在是可以使用模板标签的，像<code>｛% if %｝</code>、<code>｛% for %｝</code>这种。Django又提供了自定义模板标签，就是说我们可以自己造个模板标签，就叫<code>｛% get_setting %｝</code>吧，这个标签的功能就是从数据库获取<code>博客名称</code>、<code>博客关键词</code>（存在Setting这个数据表中）这些内容。<br>一切突然光明了~查了下官方文档，开始操作。</p>\n<p>在<code>index</code>这个应用中新建一个<code>index_tags.py</code>文件：</p>\n<pre><code># ！注意，此为错误示范\n\nfrom django import template    # 自定义模板是template类下的对象，所以先引入\nfrom index.models import Setting\n\nregister = template.Library()    # 为对象起个别名\n\n@register.template_tags    # 定义标签的类型\ndef get_setting():    # 定义标签\n    return Setting.objects.last()    # 标签的作用，返回Setting数据库的一条记录</code></pre><p>然后在<code>base.html</code>开头导入这个库：</p>\n<pre><code>｛% load index_tags %｝</code></pre><p>然后就报错了：</p>\n<pre><code>&#39;index_tags&#39; is not a registered tag library.</code></pre><p>什么鬼，照着官方文档的方法没错啊？逛了圈谷歌后才发现，原来在模板中引入自定义库前需要先到项目的<code>setting.py</code>中注册这个库。Django官方文档怎么没说啊啊啊。</p>\n<p>打开<code>blog</code>项目下的<code>setting.py</code>文件，改写如下几行：</p>\n<pre><code>TEMPLATES = [\n    &#123;\n        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,\n        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],\n        &#39;APP_DIRS&#39;: True,\n        &#39;OPTIONS&#39;: &#123;\n            &#39;context_processors&#39;: [\n                &#39;django.template.context_processors.debug&#39;,\n                &#39;django.template.context_processors.request&#39;,\n                &#39;django.contrib.auth.context_processors.auth&#39;,\n                &#39;django.contrib.messages.context_processors.messages&#39;,\n            ],\n            &#39;libraries&#39;: &#123;\n                &#39;index_tags&#39;:  &#39;index.index_tags&#39;,    # 注册index_tags这个库\n            &#125;\n        &#125;,\n    &#125;,\n]</code></pre><h1 id=\"六号坑，不存在分配标签\"><a href=\"#六号坑，不存在分配标签\" class=\"headerlink\" title=\"六号坑，不存在分配标签\"></a>六号坑，不存在分配标签</h1><p>先说明一下，Django中有三种自定义标签，分别是：</p>\n<ul>\n<li>simple_tag (简单标签)  – 单次使用只能返回一层数据。在这里就是说，不能从数据库中返回一条记录作为实例再渲染，只能分别定义N个简单标签分别渲染N条字段。</li>\n<li>inclusion_tag (内涵标签)  – 可以在标签中传入参数，这里没用。</li>\n<li>assignment_tag (分配标签) – 使用标签时可以定义别名，作为一个实例，然后可以渲染这个实例的各个对象。在这里就是说可以直接定义一个分配标签，然后在模板中定义一个别名“setting”，然后用 分配渲染。</li>\n</ul>\n<p>承接上文，我们注册了<code>index_tags.py</code>这个库后终于可以在模板引入了。在模板中使用自定义标签<code>｛% get_setting %｝</code>。又报错了：</p>\n<pre><code>AttributeError: &#39;Library&#39; object has no attribute &#39;assignment_tag&#39;</code></pre><p>什么鬼？找不到<code>assignment_tag</code>对象？？？还是照着官方的用法没错啊，网上也都是这个干的。走投无路，忍无可忍，翻了一下Django框架的源码。发现……<code>Django2</code>已经启用了<code>assignment_tag</code>和<code>inclusion_tag</code>标签，所有标签的功能都集中在了<code>simple_tag</code>上。想想也是啊，一个标签可以解决的事情，干嘛撑得用三个。Django官方改进功能值得表扬，但是你TM能不能顺便更新一下文档，您的最新文档不是误导我们嘛！差点气晕！Veto!!!!!!</p>\n<p>填完各种天坑之后，终于完美解决了这个问题，头发掉了一大把，还是很开心。呵呵……呵呵呵……真是醉了……承接上文[填坑]</p>","categories":[{"name":"后端","path":"api/categories/后端.json"}],"tags":[{"name":"框架","path":"api/tags/框架.json"},{"name":"后端","path":"api/tags/后端.json"}]}