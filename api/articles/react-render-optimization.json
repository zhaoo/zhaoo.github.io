{"title":"React - 渲染性能优化","slug":"react-render-optimization","date":"2020-08-01T08:38:35.000Z","updated":"2020-08-01T11:24:08.000Z","comments":true,"path":"api/articles/react-render-optimization.json","realPath":"/2020/08/01/react-render-optimization/","excerpt":"总结避免子组件不必要渲染的一些方法。","covers":null,"cover":"https://pic.izhaoo.com/20200718152348.jpg","content":"<p>总结避免子组件不必要渲染的一些方法。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>水文预警：看题目就知道，这篇是水文，写给自己的备忘录。</p>\n</blockquote>\n<p>在 <code>React</code> 中，父组件一旦渲染，子组件也会跟着重新渲染。（父债子还）</p>\n<p>试想在复杂业务场景下，一群子组件依赖于父组件，然后父组件有逻辑触发了渲染，一群子组件跟着渲染，这不是炸了。（杀鸡用牛刀）</p>\n<p>所以 <code>React</code> 性能优化的要素就是打断父子组件之间的强依赖关系，跳过不必要的重新渲染。但是当属性更新时，子组件又能进行及时响应并渲染。（指哪打哪）</p>\n<p>本文讨论在子组件控制重新渲染的一些方法。</p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p><code>shouldComponentUpdate</code> 是一个生命周期，在组件更新阶段中触发，用于判断组件是否需要渲染。</p>\n<p>组件更新：componentWillReceiveProps（接收属性） -&gt; <strong>shouldComponentUpdate（判断是否渲染）</strong> -&gt; componentWillUpdate -&gt; render（重新渲染） -&gt; componentDidUpdate</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">shouldComponentUpdate</span>(<span class=\"hljs-params\">nextProps, nextState</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (nextProps.user === <span class=\"hljs-built_in\">this</span>.props.user) &#123;  <span class=\"hljs-comment\">//属性没有改变</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;  <span class=\"hljs-comment\">//不渲染</span><br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;  <span class=\"hljs-comment\">//渲染</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//简写</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">shouldComponentUpdate</span>(<span class=\"hljs-params\">nextProps, nextState</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> nextProps !== <span class=\"hljs-built_in\">this</span>.props;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该生命周期方法接收两个变量，表示下一次渲染后的属性和变量；返回一个布尔值表示是否需要渲染。</p>\n<p>在方法中我们可以对 <code>nextProps（更新后属性）</code> 、 <code>this.props （当前属性）</code> 、 <code>nextState（更新后状态）</code> 、 <code>this.state （当前状态）</code> 进行一些判断，来决定是否需要重新渲染。当父组件传给子组件的属性没有发生变化时，子组件自然就不用重新渲染了，就达到了性能优化的效果。</p>\n<p>但是需要注意的是，深比较（递归遍历对象下面的所有属性）可能得不偿失，一套比较下来还要渲染，还不如直接渲染来的快。</p>\n<p>所以正确的食用方法如下：</p>\n<ul>\n<li>只进行浅比较，对比引用对象即可：<code>nextProps === this.props</code></li>\n<li>进行深层次控制，比如只对比其中一部分属性：<code>nextProps.username === this.props.username</code></li>\n<li>将对象转化为 <code>immutable</code> 对象进行比较。<del>但是 <code>js</code> 转 <code>immutable</code> 再转回 <code>js</code> 太麻烦了</del></li>\n</ul>\n<blockquote>\n<p><code>immutable.js</code> 是不可变数据集合，数据一旦创建就不能被修改，可以进行高效的惰性比较。</p>\n</blockquote>\n<h3 id=\"PureComponent\"><a href=\"#PureComponent\" class=\"headerlink\" title=\"PureComponent\"></a>PureComponent</h3><p>每个子组件都写一通 <code>shouldComponentUpdate</code> 也太麻烦了，所以 <code>React</code> 为我们准备了 <code>PureComponent</code> 组件，原型对象中默认实现了 <strong>浅比较</strong> 。</p>\n<p>By the way，若是在 <code>PureComponent</code> 使用了 <code>shouldComponentUpdate</code> ，该方法会被重写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123;PureComponent&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Child</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PureComponent</span></span>&#123;  <span class=\"hljs-comment\">//默认进行浅比较，决定是否重渲染</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>      ...<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述两种方式只适用于 <strong>对象式组件</strong>，对于 <strong>函数式组件</strong> 需要使用以下方法：</p>\n<h3 id=\"memo\"><a href=\"#memo\" class=\"headerlink\" title=\"memo\"></a>memo</h3><p><code>React.memo()</code> 是一个 HOC（高阶组件），传入两个参数：函数式组件、判断方法，返回被包裹后的对象。通过判断方法中返回的结果来决定是否需要重新渲染。</p>\n<p>第二个参数也可以不传，默认就是浅比较。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123; memo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> isEqual = <span class=\"hljs-function\">(<span class=\"hljs-params\">prevProps, nextProps</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> prevProps !== nextProps;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> memo(<span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    ...<br>  );<br>&#125;, isEqual);<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>Hooks</code> 特性后，<code>React.memo()</code> 方法就失效了。因为每次渲染返回的都是一个新闭包，不管怎么比较都是重新渲染。</p>\n<p>贴心的 <code>React</code> 团队提供了以下两个 <code>Hooks</code> 方法：</p>\n<h3 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h3><p><code>useMemo</code> 接受两个参数：函数 和 依赖项数组，返回缓存 <code>memoized</code> 值（个人理解是包装后的对象）。只有当依赖性数组中的某个值发生变化时，该函数才会重新渲染。</p>\n<p><code>useMemo</code> 的控制粒度更细，控制的是传入的函数，而不是整个组件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useMemo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Father = <span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> [username, setUsername] = useState(<span class=\"hljs-string\">&#x27;zhaoo&#x27;</span>);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> <span class=\"hljs-attr\">username</span>=<span class=\"hljs-string\">&#123;username&#125;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span>=&gt;</span>setUsername(username + &#x27;o&#x27;)&#125;&gt;改变用户名<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  )<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Child = <span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;--- component re-render ---&#x27;</span>);  <span class=\"hljs-comment\">//组件不会重新渲染</span><br>  <span class=\"hljs-keyword\">const</span> &#123;username&#125; = props;<br>  <span class=\"hljs-keyword\">return</span> useMemo(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;--- useMemo re-render ---&#x27;</span>);  <span class=\"hljs-comment\">//函数重新渲染</span><br>    <span class=\"hljs-keyword\">return</span> (<br>      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;username&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    )<br>  &#125;, [username]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"useCallback\"><a href=\"#useCallback\" class=\"headerlink\" title=\"useCallback\"></a>useCallback</h3><p><code>useCallback</code> 与 <code>useMemo</code> 类似，也接受两个参数：回调函数 和 依赖项数组，返回缓存 <code>memoized</code> 值。当依赖性数组中的某个值发生变化时，传入的回调函数被新的闭包函数取代。</p>\n<p>说白了就是，<code>useMemo</code> 中的函数直接运行，<code>useCallback</code> 返回的函数需要你手动跑。类比于 <code>call</code> 和 <code>bind</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useCallback &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Father = <span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> [username, setUsername] = useState(<span class=\"hljs-string\">&#x27;zhaoo&#x27;</span>);<br>  <span class=\"hljs-keyword\">const</span> handleClick = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    setUsername(username + <span class=\"hljs-string\">&#x27;o&#x27;</span>);<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> <span class=\"hljs-attr\">username</span>=<span class=\"hljs-string\">&#123;username&#125;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleClick&#125;</span>&gt;</span>改变用户名<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  )<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Child = <span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123;username&#125; = props;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;username&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上文只是对这些 API 过了一遍，还是乱讲的那种。不过产生了一些体会，只可意会不可言传。</p>\n<p>从 <strong>生命周期</strong> 到 <strong>Hooks</strong>，从 <strong>对象式组件</strong> 到 <strong>函数式组件</strong>，从 <strong>命令式</strong> 到 <strong>声明式</strong>，应该是思想上转变，以及为什么要引入 <code>Hooks</code>。</p>\n<p>而不是讨论 <code>useEffect</code> 中传什么参数可以模拟 <code>componentDidMount</code> 还是 <code>componentWillUnmount</code> 还是 <code>componentWillUpdate</code>。</p>\n","more":"<blockquote>\n<p>水文预警：看题目就知道，这篇是水文，写给自己的备忘录。</p>\n</blockquote>\n<p>在 <code>React</code> 中，父组件一旦渲染，子组件也会跟着重新渲染。（父债子还）</p>\n<p>试想在复杂业务场景下，一群子组件依赖于父组件，然后父组件有逻辑触发了渲染，一群子组件跟着渲染，这不是炸了。（杀鸡用牛刀）</p>\n<p>所以 <code>React</code> 性能优化的要素就是打断父子组件之间的强依赖关系，跳过不必要的重新渲染。但是当属性更新时，子组件又能进行及时响应并渲染。（指哪打哪）</p>\n<p>本文讨论在子组件控制重新渲染的一些方法。</p>\n<h3 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h3><p><code>shouldComponentUpdate</code> 是一个生命周期，在组件更新阶段中触发，用于判断组件是否需要渲染。</p>\n<p>组件更新：componentWillReceiveProps（接收属性） -&gt; <strong>shouldComponentUpdate（判断是否渲染）</strong> -&gt; componentWillUpdate -&gt; render（重新渲染） -&gt; componentDidUpdate</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">shouldComponentUpdate</span>(<span class=\"hljs-params\">nextProps, nextState</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (nextProps.user === <span class=\"hljs-built_in\">this</span>.props.user) &#123;  <span class=\"hljs-comment\">//属性没有改变</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;  <span class=\"hljs-comment\">//不渲染</span><br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;  <span class=\"hljs-comment\">//渲染</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//简写</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">shouldComponentUpdate</span>(<span class=\"hljs-params\">nextProps, nextState</span>)</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> nextProps !== <span class=\"hljs-built_in\">this</span>.props;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该生命周期方法接收两个变量，表示下一次渲染后的属性和变量；返回一个布尔值表示是否需要渲染。</p>\n<p>在方法中我们可以对 <code>nextProps（更新后属性）</code> 、 <code>this.props （当前属性）</code> 、 <code>nextState（更新后状态）</code> 、 <code>this.state （当前状态）</code> 进行一些判断，来决定是否需要重新渲染。当父组件传给子组件的属性没有发生变化时，子组件自然就不用重新渲染了，就达到了性能优化的效果。</p>\n<p>但是需要注意的是，深比较（递归遍历对象下面的所有属性）可能得不偿失，一套比较下来还要渲染，还不如直接渲染来的快。</p>\n<p>所以正确的食用方法如下：</p>\n<ul>\n<li>只进行浅比较，对比引用对象即可：<code>nextProps === this.props</code></li>\n<li>进行深层次控制，比如只对比其中一部分属性：<code>nextProps.username === this.props.username</code></li>\n<li>将对象转化为 <code>immutable</code> 对象进行比较。<del>但是 <code>js</code> 转 <code>immutable</code> 再转回 <code>js</code> 太麻烦了</del></li>\n</ul>\n<blockquote>\n<p><code>immutable.js</code> 是不可变数据集合，数据一旦创建就不能被修改，可以进行高效的惰性比较。</p>\n</blockquote>\n<h3 id=\"PureComponent\"><a href=\"#PureComponent\" class=\"headerlink\" title=\"PureComponent\"></a>PureComponent</h3><p>每个子组件都写一通 <code>shouldComponentUpdate</code> 也太麻烦了，所以 <code>React</code> 为我们准备了 <code>PureComponent</code> 组件，原型对象中默认实现了 <strong>浅比较</strong> 。</p>\n<p>By the way，若是在 <code>PureComponent</code> 使用了 <code>shouldComponentUpdate</code> ，该方法会被重写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123;PureComponent&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Child</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PureComponent</span></span>&#123;  <span class=\"hljs-comment\">//默认进行浅比较，决定是否重渲染</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> (<br>      ...<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述两种方式只适用于 <strong>对象式组件</strong>，对于 <strong>函数式组件</strong> 需要使用以下方法：</p>\n<h3 id=\"memo\"><a href=\"#memo\" class=\"headerlink\" title=\"memo\"></a>memo</h3><p><code>React.memo()</code> 是一个 HOC（高阶组件），传入两个参数：函数式组件、判断方法，返回被包裹后的对象。通过判断方法中返回的结果来决定是否需要重新渲染。</p>\n<p>第二个参数也可以不传，默认就是浅比较。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123; memo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> isEqual = <span class=\"hljs-function\">(<span class=\"hljs-params\">prevProps, nextProps</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> prevProps !== nextProps;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> memo(<span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    ...<br>  );<br>&#125;, isEqual);<br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>Hooks</code> 特性后，<code>React.memo()</code> 方法就失效了。因为每次渲染返回的都是一个新闭包，不管怎么比较都是重新渲染。</p>\n<p>贴心的 <code>React</code> 团队提供了以下两个 <code>Hooks</code> 方法：</p>\n<h3 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h3><p><code>useMemo</code> 接受两个参数：函数 和 依赖项数组，返回缓存 <code>memoized</code> 值（个人理解是包装后的对象）。只有当依赖性数组中的某个值发生变化时，该函数才会重新渲染。</p>\n<p><code>useMemo</code> 的控制粒度更细，控制的是传入的函数，而不是整个组件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useMemo &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Father = <span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> [username, setUsername] = useState(<span class=\"hljs-string\">&#x27;zhaoo&#x27;</span>);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> <span class=\"hljs-attr\">username</span>=<span class=\"hljs-string\">&#123;username&#125;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span>=&gt;</span>setUsername(username + &#x27;o&#x27;)&#125;&gt;改变用户名<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  )<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Child = <span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;--- component re-render ---&#x27;</span>);  <span class=\"hljs-comment\">//组件不会重新渲染</span><br>  <span class=\"hljs-keyword\">const</span> &#123;username&#125; = props;<br>  <span class=\"hljs-keyword\">return</span> useMemo(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;--- useMemo re-render ---&#x27;</span>);  <span class=\"hljs-comment\">//函数重新渲染</span><br>    <span class=\"hljs-keyword\">return</span> (<br>      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;username&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    )<br>  &#125;, [username]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"useCallback\"><a href=\"#useCallback\" class=\"headerlink\" title=\"useCallback\"></a>useCallback</h3><p><code>useCallback</code> 与 <code>useMemo</code> 类似，也接受两个参数：回调函数 和 依赖项数组，返回缓存 <code>memoized</code> 值。当依赖性数组中的某个值发生变化时，传入的回调函数被新的闭包函数取代。</p>\n<p>说白了就是，<code>useMemo</code> 中的函数直接运行，<code>useCallback</code> 返回的函数需要你手动跑。类比于 <code>call</code> 和 <code>bind</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123; useState, useCallback &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Father = <span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> [username, setUsername] = useState(<span class=\"hljs-string\">&#x27;zhaoo&#x27;</span>);<br>  <span class=\"hljs-keyword\">const</span> handleClick = useCallback(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    setUsername(username + <span class=\"hljs-string\">&#x27;o&#x27;</span>);<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Child</span> <span class=\"hljs-attr\">username</span>=<span class=\"hljs-string\">&#123;username&#125;</span> /&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;handleClick&#125;</span>&gt;</span>改变用户名<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>  )<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Child = <span class=\"hljs-function\">(<span class=\"hljs-params\">props = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123;username&#125; = props;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;username&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>上文只是对这些 API 过了一遍，还是乱讲的那种。不过产生了一些体会，只可意会不可言传。</p>\n<p>从 <strong>生命周期</strong> 到 <strong>Hooks</strong>，从 <strong>对象式组件</strong> 到 <strong>函数式组件</strong>，从 <strong>命令式</strong> 到 <strong>声明式</strong>，应该是思想上转变，以及为什么要引入 <code>Hooks</code>。</p>\n<p>而不是讨论 <code>useEffect</code> 中传什么参数可以模拟 <code>componentDidMount</code> 还是 <code>componentWillUnmount</code> 还是 <code>componentWillUpdate</code>。</p>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"React","path":"api/tags/React.json"}]}