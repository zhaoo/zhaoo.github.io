{"title":"JavaScript - 算法/数据结构","slug":"js-structure-algorithm","date":"2020-03-11T01:38:25.000Z","updated":"2020-05-22T02:27:14.000Z","comments":true,"path":"api/articles/js-structure-algorithm.json","realPath":"/2020/03/11/js-structure-algorithm/","excerpt":"JavaScript数据结构和算法，面试手撕代码。","covers":null,"cover":"https://pic.izhaoo.com/20191211065313.jpg","content":"<p>JavaScript数据结构和算法，面试手撕代码。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><p>这里基本语法选用<code>ES5</code>了，经测试<code>ES6</code>对性能影响蛮大的。</p>\n<p>测试性能: 在执行前打上<code>console.time(label)</code>，执行后打上<code>console.timeEnd(label)</code>。</p>\n<p>随机生成数组: </p>\n<pre><code class=\"javascript\">function randomArr(lower, upper, num) &#123;\n  var arr = []\n  for (var i = 0; i &lt; num; i++)\n    arr.push(Math.floor(Math.random() * (lower - upper) + upper))\n  return arr\n&#125;\n\nvar arr = randomArr(1, 100, 10000)</code></pre>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>156.190ms, O(n<sup>2</sup>), O(1), 稳定</p>\n<pre><code class=\"javascript\">function bubbleSort(arr) &#123;\n  var len = arr.length\n  for (var i = 0; i &lt; len; i++)\n    for (var j = 0; j &lt; len - i - 1; j++)\n      if (arr[j] &gt; arr[j + 1])\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]\n  return arr\n&#125;</code></pre>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>60.689ms, O(n<sup>2</sup>), O(1), 稳定</p>\n<pre><code class=\"javascript\">function selectSort(arr) &#123;\n  var len = arr.length\n  for (var i = 0; i &lt; len; i++) &#123;\n    var min = i\n    for (var j = i; j &lt; len; j++) &#123;\n      min = arr[j] &lt; arr[min] ? j : min\n    &#125;\n    [arr[i], arr[min]] = [arr[min], arr[i]]\n  &#125;\n  return arr\n&#125;</code></pre>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>14.673ms, O(nlog<sub>2</sub>n), O(nlog<sub>2</sub>n), 不稳定</p>\n<pre><code class=\"javascript\">function quickSort(arr) &#123;\n  if (arr.length &lt;= 1) return arr\n  var left = [], right = []\n  var pivot = Math.floor(arr.length / 2)\n  var pivotValue = arr.splice(pivot, 1)[0]\n  for (var i = 0; i &lt; arr.length; i++) &#123;\n    if (arr[i] &lt; pivotValue) &#123;\n      left.push(arr[i])\n    &#125; else &#123;\n      right.push(arr[i])\n    &#125;\n  &#125;\n  return [...quickSort(left), pivotValue, ...quickSort(right)]\n&#125;</code></pre>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>这里以n的阶乘为例。</p>\n<h3 id=\"普通递归\"><a href=\"#普通递归\" class=\"headerlink\" title=\"普通递归\"></a>普通递归</h3><pre><code class=\"javascript\">function factorial(n) &#123;\n  if (n === 0)\n    return 1\n  return n * factorial(n - 1)\n&#125;</code></pre>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>由于普通递归过程中，每次执行都会将调用过程压入<code>调用栈</code>中，如果N的技术比较大，可能会栈溢出，所以这里提供尾递归方式解决这个问题。</p>\n<pre><code class=\"javascript\">function factorial(n, total = 1) &#123;\n  if (n === 0)\n    return total\n  return factorial(n - 1, n * total)\n&#125;</code></pre>\n<p>注意！在<code>Node.js</code>中需要开启<code>harmony</code>模式实现尾递归，如下：</p>\n<pre><code class=\"bash\">node --harmony_tailcalls factorial.js</code></pre>\n<blockquote>\n<p><a href=\"https://github.com/HolyZheng/holyZheng-blog/issues/17\">尾递归优化探索</a></p>\n</blockquote>\n<h1 id=\"拷贝\"><a href=\"#拷贝\" class=\"headerlink\" title=\"拷贝\"></a>拷贝</h1><p>基本数据类型: <code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>null</code>, <code>symbol</code></p>\n<p>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。对其进行赋值时，拷贝的是值；修改后它的原始值是不会改变的。</p>\n<p>引用类型: <code>object</code>, <code>array</code></p>\n<p>引用类型是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。对其进行赋值时，拷贝的是地址空间；修改后它的原始值会一起改变。</p>\n<table>\n<thead>\n<tr>\n<th>—</th>\n<th>和原数据是否指向同一对象</th>\n<th>第一层数据为基本数据类型</th>\n<th>原数据中包含子对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>赋值</td>\n<td>是</td>\n<td>改变会使原数据一同改变</td>\n<td>改变会使原数据一同改变</td>\n</tr>\n<tr>\n<td>浅拷贝</td>\n<td>否</td>\n<td>改变不会使原数据一同改变</td>\n<td>改变会使原数据一同改变</td>\n</tr>\n<tr>\n<td>深拷贝</td>\n<td>否</td>\n<td>改变不会使原数据一同改变</td>\n<td>改变不会使原数据一同改变</td>\n</tr>\n</tbody></table>\n<p>示例对象:</p>\n<pre><code class=\"javascript\">const user = &#123;\n  name: &#39;zhaoo&#39;,\n  gender: 0,\n  social: &#123;\n    email: &#39;izhaoo@163.com&#39;,\n    qq: &#39;894519210&#39;,\n    wechat: undefined,\n  &#125;,\n  vip: null,\n  friendId: [1, 43, 23, 21]\n&#125;</code></pre>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><pre><code class=\"javascript\">user1 = user</code></pre>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><h5 id=\"assign\"><a href=\"#assign\" class=\"headerlink\" title=\"assign\"></a>assign</h5><pre><code class=\"javascript\">const user1 = Object.assign(&#123;&#125;, user)</code></pre>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><h5 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h5><pre><code class=\"javascript\">user1 = JSON.parse(JSON.stringify(user))</code></pre>\n<h5 id=\"递归遍历\"><a href=\"#递归遍历\" class=\"headerlink\" title=\"递归遍历\"></a>递归遍历</h5><pre><code class=\"javascript\">module.exports = function clone(target) &#123;\n  if (typeof target === &#39;object&#39;) &#123;\n    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;\n    for (const key in target) &#123;\n      cloneTarget[key] = clone(target[key]);\n    &#125;\n    return cloneTarget;\n  &#125; else &#123;\n    return target;\n  &#125;\n&#125;;</code></pre>\n<h1 id=\"防抖节流\"><a href=\"#防抖节流\" class=\"headerlink\" title=\"防抖节流\"></a>防抖节流</h1><h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行</p>\n<p>搜索补全</p>\n<pre><code class=\"javascript\">function debounce(fn) &#123;\n  let timeout = null;\n  return function() &#123;\n    clearTimeout(timeout);\n    timeout = setTimeout(() =&gt; &#123;\n      fn.call(this, arguments);\n    &#125;, 1000);\n  &#125;;\n&#125;</code></pre>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>指定时间间隔内只会执行一次任务</p>\n<p>懒加载监听滚动条位置、发送验证码计时器</p>\n<pre><code class=\"javascript\">function throttle(fn) &#123;\n  let canRun = true;\n  return function() &#123;\n    if(!canRun) &#123;\n      return;\n    &#125;\n    canRun = false;\n    setTimeout( () =&gt; &#123;\n      fn.call(this, arguments);\n      canRun = true;\n    &#125;, 1000);\n  &#125;;\n&#125;</code></pre>\n<h1 id=\"手写源码\"><a href=\"#手写源码\" class=\"headerlink\" title=\"手写源码\"></a>手写源码</h1><h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><pre><code class=\"javascript\">//每个函数有this和args两个默认参数\nFunction.prototype.myCall = function (context) &#123;\n  //传入的对象为空（null,number...）时指定为全局环境\n  var context = context || window\n  //用this获取调用myCall的函数\n  //fn.call(a, &#39;yck&#39;, &#39;24&#39;) =&gt; this = fn\n  context.fn = this\n  //args是伪数组，没有slice这个方法\n  var args = [...arguments].slice(1)\n  //执行并保存结果\n  var result = context.fn(...args)\n  //删除这个fn对象\n  delete context.fn\n  //返回结果\n  return result\n&#125;</code></pre>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><pre><code class=\"javascript\">Function.prototype.myApply = function (context) &#123;\n  var context = context || window\n  context.fn = this\n  var result\n  if (arguments[1]) &#123;\n    result = context.fn(...arguments[1])\n  &#125; else &#123;\n    result = context.fn()\n  &#125;\n  delete context.fn\n  return result\n&#125;</code></pre>\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><pre><code class=\"javascript\">Function.prototype.myBind = function (context) &#123;\n  // if (typeof this !== &#39;function&#39;) &#123;\n  //   throw new TypeError(&#39;Error&#39;)\n  // &#125;\n  var fn = this\n  var args = [...arguments].slice(1)\n  return function F() &#123;\n    if (this instanceof F) &#123;\n      return new fn(...args, ...arguments)\n    &#125;\n    return fn.apply(context, args.concat(...arguments))\n  &#125;\n&#125;</code></pre>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><pre><code class=\"javascript\">function new() &#123;\n  let obj = new Object()\n  let Constructor = [].shift.call(arguments)\n  obj.__proto__ = Constructor.prototype\n  let result = Constructor.apply(obj, arguments)\n  return typeof result === &#39;object&#39; ? result : obj\n&#125;\n\nfunction student(name, gender) &#123;\n  this.name = name\n  this.gender = gender\n&#125;\n\nvar zhaoo = new(student, &#39;zhaoo&#39;, &#39;male&#39;)</code></pre>\n<ol>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将步骤1新创建的对象作为this的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回this。</li>\n</ol>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>后进先出 (LIFO)</p>\n<pre><code class=\"javascript\">class Stack &#123;\n  constructor() &#123;\n    this.stack = []\n  &#125;\n  push(item) &#123;\n    this.stack.push(item)\n  &#125;\n  pop() &#123;\n    this.stack.pop()\n  &#125;\n  peek() &#123;\n    return this.stack[this.getCount() - 1]\n  &#125;\n  getCount() &#123;\n    return this.stack.length\n  &#125;\n  isEmpty() &#123;\n    return this.getCount() === 0\n  &#125;\n&#125;</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>先进先出 (FIFO)</p>\n<pre><code class=\"javascript\">class Queue &#123;\n  constructor() &#123;\n    this.queue = []\n  &#125;\n  enQueue(item) &#123;\n    this.queue.push(item)\n  &#125;\n  deQueue() &#123;\n    return this.queue.shift()  //使用数组比较消耗性能\n  &#125;\n  getHeader() &#123;\n    return this.queue[0]\n  &#125;\n  getLength() &#123;\n    return this.queue.length\n  &#125;\n  isEmpty() &#123;\n    return this.getLength() === 0\n  &#125;\n&#125;</code></pre>\n<h3 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h3><pre><code class=\"javascript\">class PriorityQueue &#123;\n  constructor() &#123;\n    this.queue = [&#123;\n      priority\n      value\n    &#125;]\n  &#125;\n  enQueue(item) &#123;\n    if (this.isEmpty()) &#123;\n      this.queue.push(item)\n    &#125; else &#123;\n      var flag = false;  //判断是否排队\n      for (let i = this.queue.length - 1; i &gt; 0; i--) &#123;\n        if (this.queue[i].priority &lt;= item.priority) &#123;\n          this.queue.splice(i, 0, item)\n          flag = true\n          break\n        &#125;\n      &#125;\n      //循环后未入队，优先级最大，插入到第一位\n      if (!flag) &#123;\n        this.queue.unshift(item);\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><pre><code class=\"javascript\">// 节点\nfunction Node (el) &#123;\n  this.el = el;\n  this.next = null;\n&#125;\n\n// 构造函数\nfunction Link () &#123;\n  this.head = new Node(&#39;head&#39;);\n&#125;\n\n// 链表结尾追加一个节点\nLink.prototype.append = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next != null) &#123;\n    currNode = currNode.next;\n  &#125;\n  currNode.next = new Node(el);\n&#125;\n\n// 按节点的值查找节点\nLink.prototype.find = function (el) &#123;\n  var currNode = this.head;\n  while (currNode &amp;&amp; currNode.el != el) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 插入一个节点\nLink.prototype.insert = function (newEl, oldEl) &#123;\n  var newNode = new Node(newEl);\n  var findNode = this.find(oldEl);\n  if (findNode) &#123;\n    newNode.next = findNode.next;\n    findNode.next = newNode;\n  &#125; else &#123;\n    throw new Error(&#39;找不到给定插入的节点&#39;);\n  &#125;\n&#125;\n\n// 展示链表中的元素\nLink.prototype.display = function () &#123;\n  var currNode = this.head.next;\n  while (currNode) &#123;\n    console.log(currNode.el);\n    currNode = currNode.next;\n  &#125;\n&#125;\n\n// 寻找给定节点的前一个节点\nLink.prototype.findPrev = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next &amp;&amp; currNode.next.el !== el) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 删除给定的节点\nLink.prototype.remove = function (el) &#123;\n  var prevNode = this.findPrev (el);\n  if (prevNode.next != null) &#123;\n    prevNode.next = prevNode.next.next;\n  &#125; else &#123;\n    throw new Error(&#39;找不到要删除的节点&#39;);\n  &#125;\n&#125;</code></pre>\n<h3 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h3><pre><code class=\"javascript\">\n// 双链表构造函数\nfunction DNode (el) &#123;\n  this.el = el;\n  this.prev = null;\n  this.next = null;\n&#125;\n\nfunction DLink() &#123;\n  this.head = new DNode(&#39;head&#39;);\n&#125;\n\n// 在链表结尾添加一个新的节点\nDLink.prototype.append = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next != null) &#123;\n    currNode = currNode.next;\n  &#125;\n  var newNode = new Node(el);\n  newNode.next = currNode.next;\n  newNode.prev = currNode;\n  currNode.next = newNode;\n&#125;\n\n// 根据节点的值查找链表节点\nDLink.prototype.find = function (el) &#123;\n  var currNode = this.head;\n  while (currNode &amp;&amp; currNode.el != el) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 插入一个节点\nDLink.prototype.insert = function (newEl, oldEl) &#123;\n  var newNode = new DNode(newEl);\n  var currNode = this.find(oldEl);\n  if (currNode) &#123;\n    newNode.next = currNode.next;\n    newNode.prev = currNode;\n    currNode.next = newNode;\n  &#125; else &#123;\n    throw new Error(&#39;未找到指定要插入节点位置对应的值！&#39;)\n  &#125;\n&#125;\n\n\n// 顺序展示链表节点\nDLink.prototype.display = function () &#123;\n  var currNode = this.head.next;\n  while (currNode) &#123;\n    console.log(currNode.el);\n    currNode = currNode.next;\n  &#125;\n&#125;\n\n// 查找最后一个节点\nDLink.prototype.findLast = function () &#123;\n  var currNode = this.head;\n  while (currNode.next != null) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 逆序展示链表节点\nDLink.prototype.dispReverse = function () &#123;\n  var currNode = this.head;\n  currNode = this.findLast();\n  while (currNode.prev != null) &#123;\n    console(currNode.el);\n    currNode = currNode.prev;\n  &#125;\n&#125;\n\n// 删除给定的节点\nDLink.prototype.remove = function (el) &#123;\n  var currNode = this.find(el);\n  if (currNode &amp;&amp; currNode.next != null) &#123;\n    currNode.prev.next = currNode.next;\n    currNode.next.prev = currNode.prev;\n    currNode.next = null;\n    currNode.previous = null;\n  &#125; else &#123;\n    throw new Error(&#39;找不到要删除对应的节点&#39;);\n  &#125;\n&#125;</code></pre>\n<h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><pre><code class=\"javascript\">// 循环链表构造函数\nfunction CLink() &#123;\n  this.head = new Node(&#39;head&#39;);\n  this.head.next = this.head;\n&#125;\n\n// 向循环链表结尾新增一个节点\nCLink.prototype.append = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next != null &amp;&amp; currNode.next != this.head) &#123;\n    currNode = currNode.next;\n  &#125;\n  var newNode = new Node(el);\n  newNode.next = currNode.next;\n  currNode.next = newNode;\n&#125;\n\n// 根据节点的值查找链表节点\nCLink.prototype.find = function (el) &#123;\n  var currNode = this.head;\n  while (currNode &amp;&amp; currNode.el != el &amp;&amp; currNode.next != this.head) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 插入一个节点\nCLink.prototype.insert = function (newEl, oldEl) &#123;\n  var newNode = new Node(newEl);\n  var currNode = this.find(oldEl);\n  if (currNode) &#123;\n    newNode.next = currNode.next;\n    currNode.next = newNode;\n  &#125; else &#123;\n    throw new Error(&#39;未找到指定要插入节点位置对应的值！&#39;);\n  &#125;\n&#125;\n\n// 展示链表元素节点\nCLink.prototype.display = function () &#123;\n  var currNode = this.head.next;\n  while (currNode &amp;&amp; currNode != this.head) &#123;\n    console.log(currNode.el);\n    currNode = currNode.next;\n  &#125;\n&#125;\n\n// 寻找前一个节点\nCLink.prototype.findPrev = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next &amp;&amp; currNode.next.el !== el) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 删除给定的节点\nCLink.prototype.remove = function (el) &#123;\n  var prevNode = this.findPrev(el);\n  if (prevNode.next != null) &#123;\n    prevNode.next = prevNode.next.next;\n  &#125; else &#123;\n    throw new Error(&#39;找不到要删除的节点&#39;);\n  &#125;\n&#125;</code></pre>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><pre><code class=\"javascript\">class Collection &#123;\n  constructor(data) &#123;\n    this.collection = new Set(data);\n  &#125;\n\n  add(data) &#123;\n    this.collection.add(data);\n  &#125;\n\n  get() &#123;\n    return this.collection;\n  &#125;\n\n  remove(data) &#123;\n    this.collection.remove(data);\n  &#125;\n\n  has(data) &#123;\n    return this.collection.has(data);\n  &#125;\n\n  size() &#123;\n    return this.collection.size;\n  &#125;\n\n  values() &#123;\n    return this.collection;\n  &#125;\n\n  union(collection) &#123;\n    let arr1 = Array.from(collection);\n    let arr2 = Array.from(this.collection);\n    return new Set(arr1.concat(arr2));\n  &#125;\n\n  intersect(collection) &#123;\n    let arr = new Set();\n    this.collection.forEach(element =&gt; &#123;\n      if (collection.has(element)) &#123;\n        arr.add(element);\n      &#125;\n    &#125;);\n    return arr;\n  &#125;\n\n  difference(collection) &#123;\n    let arr = new Set();\n    this.collection.forEach(element =&gt; &#123;\n      if (!collection.has(element)) &#123;\n        arr.add(element);\n      &#125;\n    &#125;);\n    return arr;\n  &#125;\n\n  sub(collection) &#123;\n    if (this.size() &lt; collection.size()) &#123;\n      return false;\n    &#125; else &#123;\n      let res = true;\n      collection.values().forEach(element =&gt; &#123;\n        if (!this.collection.has(element)) &#123;\n          res = false;\n        &#125;\n      &#125;);\n      return res;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"https://juejin.im/post/59ac1c4ef265da248e75892b#heading-6\">js 深拷贝 vs 浅拷贝</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1\">如何写出一个惊艳面试官的深拷贝?</a></p>\n</blockquote>\n","more":"<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><p>这里基本语法选用<code>ES5</code>了，经测试<code>ES6</code>对性能影响蛮大的。</p>\n<p>测试性能: 在执行前打上<code>console.time(label)</code>，执行后打上<code>console.timeEnd(label)</code>。</p>\n<p>随机生成数组: </p>\n<pre><code class=\"javascript\">function randomArr(lower, upper, num) &#123;\n  var arr = []\n  for (var i = 0; i &lt; num; i++)\n    arr.push(Math.floor(Math.random() * (lower - upper) + upper))\n  return arr\n&#125;\n\nvar arr = randomArr(1, 100, 10000)</code></pre>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>156.190ms, O(n<sup>2</sup>), O(1), 稳定</p>\n<pre><code class=\"javascript\">function bubbleSort(arr) &#123;\n  var len = arr.length\n  for (var i = 0; i &lt; len; i++)\n    for (var j = 0; j &lt; len - i - 1; j++)\n      if (arr[j] &gt; arr[j + 1])\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]\n  return arr\n&#125;</code></pre>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>60.689ms, O(n<sup>2</sup>), O(1), 稳定</p>\n<pre><code class=\"javascript\">function selectSort(arr) &#123;\n  var len = arr.length\n  for (var i = 0; i &lt; len; i++) &#123;\n    var min = i\n    for (var j = i; j &lt; len; j++) &#123;\n      min = arr[j] &lt; arr[min] ? j : min\n    &#125;\n    [arr[i], arr[min]] = [arr[min], arr[i]]\n  &#125;\n  return arr\n&#125;</code></pre>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>14.673ms, O(nlog<sub>2</sub>n), O(nlog<sub>2</sub>n), 不稳定</p>\n<pre><code class=\"javascript\">function quickSort(arr) &#123;\n  if (arr.length &lt;= 1) return arr\n  var left = [], right = []\n  var pivot = Math.floor(arr.length / 2)\n  var pivotValue = arr.splice(pivot, 1)[0]\n  for (var i = 0; i &lt; arr.length; i++) &#123;\n    if (arr[i] &lt; pivotValue) &#123;\n      left.push(arr[i])\n    &#125; else &#123;\n      right.push(arr[i])\n    &#125;\n  &#125;\n  return [...quickSort(left), pivotValue, ...quickSort(right)]\n&#125;</code></pre>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>这里以n的阶乘为例。</p>\n<h3 id=\"普通递归\"><a href=\"#普通递归\" class=\"headerlink\" title=\"普通递归\"></a>普通递归</h3><pre><code class=\"javascript\">function factorial(n) &#123;\n  if (n === 0)\n    return 1\n  return n * factorial(n - 1)\n&#125;</code></pre>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>由于普通递归过程中，每次执行都会将调用过程压入<code>调用栈</code>中，如果N的技术比较大，可能会栈溢出，所以这里提供尾递归方式解决这个问题。</p>\n<pre><code class=\"javascript\">function factorial(n, total = 1) &#123;\n  if (n === 0)\n    return total\n  return factorial(n - 1, n * total)\n&#125;</code></pre>\n<p>注意！在<code>Node.js</code>中需要开启<code>harmony</code>模式实现尾递归，如下：</p>\n<pre><code class=\"bash\">node --harmony_tailcalls factorial.js</code></pre>\n<blockquote>\n<p><a href=\"https://github.com/HolyZheng/holyZheng-blog/issues/17\">尾递归优化探索</a></p>\n</blockquote>\n<h1 id=\"拷贝\"><a href=\"#拷贝\" class=\"headerlink\" title=\"拷贝\"></a>拷贝</h1><p>基本数据类型: <code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>null</code>, <code>symbol</code></p>\n<p>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。对其进行赋值时，拷贝的是值；修改后它的原始值是不会改变的。</p>\n<p>引用类型: <code>object</code>, <code>array</code></p>\n<p>引用类型是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。对其进行赋值时，拷贝的是地址空间；修改后它的原始值会一起改变。</p>\n<table>\n<thead>\n<tr>\n<th>—</th>\n<th>和原数据是否指向同一对象</th>\n<th>第一层数据为基本数据类型</th>\n<th>原数据中包含子对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>赋值</td>\n<td>是</td>\n<td>改变会使原数据一同改变</td>\n<td>改变会使原数据一同改变</td>\n</tr>\n<tr>\n<td>浅拷贝</td>\n<td>否</td>\n<td>改变不会使原数据一同改变</td>\n<td>改变会使原数据一同改变</td>\n</tr>\n<tr>\n<td>深拷贝</td>\n<td>否</td>\n<td>改变不会使原数据一同改变</td>\n<td>改变不会使原数据一同改变</td>\n</tr>\n</tbody></table>\n<p>示例对象:</p>\n<pre><code class=\"javascript\">const user = &#123;\n  name: &#39;zhaoo&#39;,\n  gender: 0,\n  social: &#123;\n    email: &#39;izhaoo@163.com&#39;,\n    qq: &#39;894519210&#39;,\n    wechat: undefined,\n  &#125;,\n  vip: null,\n  friendId: [1, 43, 23, 21]\n&#125;</code></pre>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><pre><code class=\"javascript\">user1 = user</code></pre>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><h5 id=\"assign\"><a href=\"#assign\" class=\"headerlink\" title=\"assign\"></a>assign</h5><pre><code class=\"javascript\">const user1 = Object.assign(&#123;&#125;, user)</code></pre>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><h5 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h5><pre><code class=\"javascript\">user1 = JSON.parse(JSON.stringify(user))</code></pre>\n<h5 id=\"递归遍历\"><a href=\"#递归遍历\" class=\"headerlink\" title=\"递归遍历\"></a>递归遍历</h5><pre><code class=\"javascript\">module.exports = function clone(target) &#123;\n  if (typeof target === &#39;object&#39;) &#123;\n    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;\n    for (const key in target) &#123;\n      cloneTarget[key] = clone(target[key]);\n    &#125;\n    return cloneTarget;\n  &#125; else &#123;\n    return target;\n  &#125;\n&#125;;</code></pre>\n<h1 id=\"防抖节流\"><a href=\"#防抖节流\" class=\"headerlink\" title=\"防抖节流\"></a>防抖节流</h1><h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行</p>\n<p>搜索补全</p>\n<pre><code class=\"javascript\">function debounce(fn) &#123;\n  let timeout = null;\n  return function() &#123;\n    clearTimeout(timeout);\n    timeout = setTimeout(() =&gt; &#123;\n      fn.call(this, arguments);\n    &#125;, 1000);\n  &#125;;\n&#125;</code></pre>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>指定时间间隔内只会执行一次任务</p>\n<p>懒加载监听滚动条位置、发送验证码计时器</p>\n<pre><code class=\"javascript\">function throttle(fn) &#123;\n  let canRun = true;\n  return function() &#123;\n    if(!canRun) &#123;\n      return;\n    &#125;\n    canRun = false;\n    setTimeout( () =&gt; &#123;\n      fn.call(this, arguments);\n      canRun = true;\n    &#125;, 1000);\n  &#125;;\n&#125;</code></pre>\n<h1 id=\"手写源码\"><a href=\"#手写源码\" class=\"headerlink\" title=\"手写源码\"></a>手写源码</h1><h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><pre><code class=\"javascript\">//每个函数有this和args两个默认参数\nFunction.prototype.myCall = function (context) &#123;\n  //传入的对象为空（null,number...）时指定为全局环境\n  var context = context || window\n  //用this获取调用myCall的函数\n  //fn.call(a, &#39;yck&#39;, &#39;24&#39;) =&gt; this = fn\n  context.fn = this\n  //args是伪数组，没有slice这个方法\n  var args = [...arguments].slice(1)\n  //执行并保存结果\n  var result = context.fn(...args)\n  //删除这个fn对象\n  delete context.fn\n  //返回结果\n  return result\n&#125;</code></pre>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><pre><code class=\"javascript\">Function.prototype.myApply = function (context) &#123;\n  var context = context || window\n  context.fn = this\n  var result\n  if (arguments[1]) &#123;\n    result = context.fn(...arguments[1])\n  &#125; else &#123;\n    result = context.fn()\n  &#125;\n  delete context.fn\n  return result\n&#125;</code></pre>\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><pre><code class=\"javascript\">Function.prototype.myBind = function (context) &#123;\n  // if (typeof this !== &#39;function&#39;) &#123;\n  //   throw new TypeError(&#39;Error&#39;)\n  // &#125;\n  var fn = this\n  var args = [...arguments].slice(1)\n  return function F() &#123;\n    if (this instanceof F) &#123;\n      return new fn(...args, ...arguments)\n    &#125;\n    return fn.apply(context, args.concat(...arguments))\n  &#125;\n&#125;</code></pre>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><pre><code class=\"javascript\">function new() &#123;\n  let obj = new Object()\n  let Constructor = [].shift.call(arguments)\n  obj.__proto__ = Constructor.prototype\n  let result = Constructor.apply(obj, arguments)\n  return typeof result === &#39;object&#39; ? result : obj\n&#125;\n\nfunction student(name, gender) &#123;\n  this.name = name\n  this.gender = gender\n&#125;\n\nvar zhaoo = new(student, &#39;zhaoo&#39;, &#39;male&#39;)</code></pre>\n<ol>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将步骤1新创建的对象作为this的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回this。</li>\n</ol>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>后进先出 (LIFO)</p>\n<pre><code class=\"javascript\">class Stack &#123;\n  constructor() &#123;\n    this.stack = []\n  &#125;\n  push(item) &#123;\n    this.stack.push(item)\n  &#125;\n  pop() &#123;\n    this.stack.pop()\n  &#125;\n  peek() &#123;\n    return this.stack[this.getCount() - 1]\n  &#125;\n  getCount() &#123;\n    return this.stack.length\n  &#125;\n  isEmpty() &#123;\n    return this.getCount() === 0\n  &#125;\n&#125;</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>先进先出 (FIFO)</p>\n<pre><code class=\"javascript\">class Queue &#123;\n  constructor() &#123;\n    this.queue = []\n  &#125;\n  enQueue(item) &#123;\n    this.queue.push(item)\n  &#125;\n  deQueue() &#123;\n    return this.queue.shift()  //使用数组比较消耗性能\n  &#125;\n  getHeader() &#123;\n    return this.queue[0]\n  &#125;\n  getLength() &#123;\n    return this.queue.length\n  &#125;\n  isEmpty() &#123;\n    return this.getLength() === 0\n  &#125;\n&#125;</code></pre>\n<h3 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h3><pre><code class=\"javascript\">class PriorityQueue &#123;\n  constructor() &#123;\n    this.queue = [&#123;\n      priority\n      value\n    &#125;]\n  &#125;\n  enQueue(item) &#123;\n    if (this.isEmpty()) &#123;\n      this.queue.push(item)\n    &#125; else &#123;\n      var flag = false;  //判断是否排队\n      for (let i = this.queue.length - 1; i &gt; 0; i--) &#123;\n        if (this.queue[i].priority &lt;= item.priority) &#123;\n          this.queue.splice(i, 0, item)\n          flag = true\n          break\n        &#125;\n      &#125;\n      //循环后未入队，优先级最大，插入到第一位\n      if (!flag) &#123;\n        this.queue.unshift(item);\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><pre><code class=\"javascript\">// 节点\nfunction Node (el) &#123;\n  this.el = el;\n  this.next = null;\n&#125;\n\n// 构造函数\nfunction Link () &#123;\n  this.head = new Node(&#39;head&#39;);\n&#125;\n\n// 链表结尾追加一个节点\nLink.prototype.append = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next != null) &#123;\n    currNode = currNode.next;\n  &#125;\n  currNode.next = new Node(el);\n&#125;\n\n// 按节点的值查找节点\nLink.prototype.find = function (el) &#123;\n  var currNode = this.head;\n  while (currNode &amp;&amp; currNode.el != el) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 插入一个节点\nLink.prototype.insert = function (newEl, oldEl) &#123;\n  var newNode = new Node(newEl);\n  var findNode = this.find(oldEl);\n  if (findNode) &#123;\n    newNode.next = findNode.next;\n    findNode.next = newNode;\n  &#125; else &#123;\n    throw new Error(&#39;找不到给定插入的节点&#39;);\n  &#125;\n&#125;\n\n// 展示链表中的元素\nLink.prototype.display = function () &#123;\n  var currNode = this.head.next;\n  while (currNode) &#123;\n    console.log(currNode.el);\n    currNode = currNode.next;\n  &#125;\n&#125;\n\n// 寻找给定节点的前一个节点\nLink.prototype.findPrev = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next &amp;&amp; currNode.next.el !== el) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 删除给定的节点\nLink.prototype.remove = function (el) &#123;\n  var prevNode = this.findPrev (el);\n  if (prevNode.next != null) &#123;\n    prevNode.next = prevNode.next.next;\n  &#125; else &#123;\n    throw new Error(&#39;找不到要删除的节点&#39;);\n  &#125;\n&#125;</code></pre>\n<h3 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h3><pre><code class=\"javascript\">\n// 双链表构造函数\nfunction DNode (el) &#123;\n  this.el = el;\n  this.prev = null;\n  this.next = null;\n&#125;\n\nfunction DLink() &#123;\n  this.head = new DNode(&#39;head&#39;);\n&#125;\n\n// 在链表结尾添加一个新的节点\nDLink.prototype.append = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next != null) &#123;\n    currNode = currNode.next;\n  &#125;\n  var newNode = new Node(el);\n  newNode.next = currNode.next;\n  newNode.prev = currNode;\n  currNode.next = newNode;\n&#125;\n\n// 根据节点的值查找链表节点\nDLink.prototype.find = function (el) &#123;\n  var currNode = this.head;\n  while (currNode &amp;&amp; currNode.el != el) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 插入一个节点\nDLink.prototype.insert = function (newEl, oldEl) &#123;\n  var newNode = new DNode(newEl);\n  var currNode = this.find(oldEl);\n  if (currNode) &#123;\n    newNode.next = currNode.next;\n    newNode.prev = currNode;\n    currNode.next = newNode;\n  &#125; else &#123;\n    throw new Error(&#39;未找到指定要插入节点位置对应的值！&#39;)\n  &#125;\n&#125;\n\n\n// 顺序展示链表节点\nDLink.prototype.display = function () &#123;\n  var currNode = this.head.next;\n  while (currNode) &#123;\n    console.log(currNode.el);\n    currNode = currNode.next;\n  &#125;\n&#125;\n\n// 查找最后一个节点\nDLink.prototype.findLast = function () &#123;\n  var currNode = this.head;\n  while (currNode.next != null) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 逆序展示链表节点\nDLink.prototype.dispReverse = function () &#123;\n  var currNode = this.head;\n  currNode = this.findLast();\n  while (currNode.prev != null) &#123;\n    console(currNode.el);\n    currNode = currNode.prev;\n  &#125;\n&#125;\n\n// 删除给定的节点\nDLink.prototype.remove = function (el) &#123;\n  var currNode = this.find(el);\n  if (currNode &amp;&amp; currNode.next != null) &#123;\n    currNode.prev.next = currNode.next;\n    currNode.next.prev = currNode.prev;\n    currNode.next = null;\n    currNode.previous = null;\n  &#125; else &#123;\n    throw new Error(&#39;找不到要删除对应的节点&#39;);\n  &#125;\n&#125;</code></pre>\n<h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><pre><code class=\"javascript\">// 循环链表构造函数\nfunction CLink() &#123;\n  this.head = new Node(&#39;head&#39;);\n  this.head.next = this.head;\n&#125;\n\n// 向循环链表结尾新增一个节点\nCLink.prototype.append = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next != null &amp;&amp; currNode.next != this.head) &#123;\n    currNode = currNode.next;\n  &#125;\n  var newNode = new Node(el);\n  newNode.next = currNode.next;\n  currNode.next = newNode;\n&#125;\n\n// 根据节点的值查找链表节点\nCLink.prototype.find = function (el) &#123;\n  var currNode = this.head;\n  while (currNode &amp;&amp; currNode.el != el &amp;&amp; currNode.next != this.head) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 插入一个节点\nCLink.prototype.insert = function (newEl, oldEl) &#123;\n  var newNode = new Node(newEl);\n  var currNode = this.find(oldEl);\n  if (currNode) &#123;\n    newNode.next = currNode.next;\n    currNode.next = newNode;\n  &#125; else &#123;\n    throw new Error(&#39;未找到指定要插入节点位置对应的值！&#39;);\n  &#125;\n&#125;\n\n// 展示链表元素节点\nCLink.prototype.display = function () &#123;\n  var currNode = this.head.next;\n  while (currNode &amp;&amp; currNode != this.head) &#123;\n    console.log(currNode.el);\n    currNode = currNode.next;\n  &#125;\n&#125;\n\n// 寻找前一个节点\nCLink.prototype.findPrev = function (el) &#123;\n  var currNode = this.head;\n  while (currNode.next &amp;&amp; currNode.next.el !== el) &#123;\n    currNode = currNode.next;\n  &#125;\n  return currNode;\n&#125;\n\n// 删除给定的节点\nCLink.prototype.remove = function (el) &#123;\n  var prevNode = this.findPrev(el);\n  if (prevNode.next != null) &#123;\n    prevNode.next = prevNode.next.next;\n  &#125; else &#123;\n    throw new Error(&#39;找不到要删除的节点&#39;);\n  &#125;\n&#125;</code></pre>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><pre><code class=\"javascript\">class Collection &#123;\n  constructor(data) &#123;\n    this.collection = new Set(data);\n  &#125;\n\n  add(data) &#123;\n    this.collection.add(data);\n  &#125;\n\n  get() &#123;\n    return this.collection;\n  &#125;\n\n  remove(data) &#123;\n    this.collection.remove(data);\n  &#125;\n\n  has(data) &#123;\n    return this.collection.has(data);\n  &#125;\n\n  size() &#123;\n    return this.collection.size;\n  &#125;\n\n  values() &#123;\n    return this.collection;\n  &#125;\n\n  union(collection) &#123;\n    let arr1 = Array.from(collection);\n    let arr2 = Array.from(this.collection);\n    return new Set(arr1.concat(arr2));\n  &#125;\n\n  intersect(collection) &#123;\n    let arr = new Set();\n    this.collection.forEach(element =&gt; &#123;\n      if (collection.has(element)) &#123;\n        arr.add(element);\n      &#125;\n    &#125;);\n    return arr;\n  &#125;\n\n  difference(collection) &#123;\n    let arr = new Set();\n    this.collection.forEach(element =&gt; &#123;\n      if (!collection.has(element)) &#123;\n        arr.add(element);\n      &#125;\n    &#125;);\n    return arr;\n  &#125;\n\n  sub(collection) &#123;\n    if (this.size() &lt; collection.size()) &#123;\n      return false;\n    &#125; else &#123;\n      let res = true;\n      collection.values().forEach(element =&gt; &#123;\n        if (!this.collection.has(element)) &#123;\n          res = false;\n        &#125;\n      &#125;);\n      return res;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"https://juejin.im/post/59ac1c4ef265da248e75892b#heading-6\">js 深拷贝 vs 浅拷贝</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1\">如何写出一个惊艳面试官的深拷贝?</a></p>\n</blockquote>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"js","path":"api/tags/js.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"javascript","path":"api/tags/javascript.json"}]}