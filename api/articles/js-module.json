{"title":"JavaScript - 模块化","slug":"js-module","date":"2020-04-12T12:33:15.000Z","updated":"2020-05-05T01:36:04.000Z","comments":true,"path":"api/articles/js-module.json","realPath":"/2020/04/12/js-module/","excerpt":"关于JavaScript中模块化的一些总结。","covers":null,"cover":"https://pic.izhaoo.com/2020050593403.jpg","content":"<p>关于JavaScript中<code>模块化</code>的一些总结。</p>\n<span id=\"more\"></span>\n\n<p>在发开大型软件项目时，一般需要通过<code>模块化</code>来管理代码。将一段有逻辑联系的代码封装成<code>模块</code>，其内部数据与实现是私有的，将一些公用接口暴露出去，与其他模块进行通信，最后组织成程序。</p>\n<p>模块化的作用:</p>\n<ul>\n<li>避免命名冲突</li>\n<li>按需加载</li>\n<li>提高复用程度</li>\n<li>提高可维护性</li>\n</ul>\n<blockquote>\n<p>软件工程提倡<strong>高内聚，低耦合</strong>。</p>\n</blockquote>\n<p>目前流行的JS模块化规范有<code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>和<code>ES6模块</code>。通常将一个JS文件作为一个模块，向外暴露特定的变量和函数。</p>\n<h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3><p><code>Node</code>是<code>CommonJS</code>规范的主要实践者，通过<code>module</code>、<code>exports</code>、<code>require</code>等关键词实现<code>模块加载</code>和<code>模块定义</code>。</p>\n<p>在服务端一般模块文件都存在本地，读取速度比较快，所以使用同步加载方式一般没问题。</p>\n<p><code>CommonJS</code>以<strong>同步</strong>方式加载模块。</p>\n<h5 id=\"模块引用\"><a href=\"#模块引用\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h5><p>使用<code>require()</code>方法引入模块，传入的变量为模块标识符。</p>\n<p>在Node中有三种模块类型，<code>核心模块</code>、<code>文件模块</code>、<code>自定义模块</code>。</p>\n<ul>\n<li>核心模块: Node内置的一些模块，例如<code>http</code>、<code>fs</code>、<code>path</code>等，模块标识符为<strong>模块名称</strong>。在Node的源码编译过程中已经将这些模块编译为二进制代码，所以加载过程很快。</li>\n<li>文件模块: 一般为用户自己定义的一些模块，一个文件就是一个模块，模块标识符为<strong>文件路径</strong>。由于指明了文件加载路径，所以加载速度较快。</li>\n<li>自定义模块: 用户使用<code>npm</code>等包管理工具安装的模块，一般保存在<code>node_moudles</code>目录下，模块标识符为<strong>模块名称</strong>。由于需要按照<code>npm</code>的加载规则匹配模块，所以加载过程较慢。</li>\n</ul>\n<pre><code class=\"javascript\">//main.js\n\nvar http = require(&#39;http&#39;);  //引入核心模块\nvar math = require(&#39;./math&#39;);  //引入文件模块\nvar koa = require(&#39;koa&#39;);  //引入自定义模块\n\nconsole.log(math.add(1, 2));  //使用math模块，输出3</code></pre>\n<h5 id=\"模块定义\"><a href=\"#模块定义\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h5><p>对于文件模块，我们需要自己定义，一个文件就是一个模块。在CommonJS规范中<code>exports</code>对象是模块的唯一出口，定义导出的变量或方法。</p>\n<pre><code class=\"javascript\">//math.js\n\nexports.add = function (a, b) &#123;  //导出add方法\n  return a + b;\n&#125;\n\nexports.subtract = function (a, b) &#123;  //导出subtract方法\n  return a - b;\n&#125;</code></pre>\n<p>但是Node并不是完全按照CommonJS规范实现的，而是根据自身需要做了一些取舍，所以表现出一些特性。在Node中，我们更推荐使用<code>module.exports</code>来定义模块。</p>\n<pre><code class=\"javascript\">//math.js\n\nfunction add (a, b) &#123;\n  return a + b;\n&#125;\n\nfunction subtract (a, b) &#123;\n  return a - b;\n&#125;\n\nmodule.exports = &#123;\n  add: add,\n  subtract: subtract\n&#125;;</code></pre>\n<h5 id=\"module-exports-和-exports\"><a href=\"#module-exports-和-exports\" class=\"headerlink\" title=\"module.exports 和 exports\"></a>module.exports 和 exports</h5><p>在Node中，一个模块(文件)就是一个闭包，通过闭包机制实现了命名空间。</p>\n<pre><code class=\"javascript\">(function (exports, require, module, __filename, __dirname) &#123;\n  //code\n&#125;)();</code></pre>\n<p>每执行一个文件，就会自动创建一个<code>module</code>对象，而<code>module.exports</code>是其中的一个属性。所以<code>module.exports</code>才是真正的模块对象，<code>exports</code>只是对它的一个引用。</p>\n<p>因此，使用<code>module.exports</code>可以对该变量重新赋值，而使用<code>exports</code>不能进行重新赋值，只能对<code>exports</code>下的属性进行赋值，如<code>exports.add = add</code>。</p>\n<h3 id=\"ES6模块\"><a href=\"#ES6模块\" class=\"headerlink\" title=\"ES6模块\"></a>ES6模块</h3><p><code>ES6</code>标准在语法层面上实现了模块化，通过使用<code>import</code>和<code>export</code>实现<code>模块加载</code>和<code>模块定义</code>。由于是标准规范，使用在客户端和服务端都可以使用，一般是配合<code>webpack</code>等打包工具进行管理，因为现阶段<code>ES6</code>还需通过<code>babel</code>进行编码。</p>\n<p>不同于其他三种模块化方式，<code>ES6模块</code>是在<strong>编译过程中</strong>加载模块，而不是动态地引入一个对象。</p>\n<h5 id=\"模块定义-1\"><a href=\"#模块定义-1\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h5><p>使用<code>export</code>命令导出模块，也可以使用<code>export default</code>指定默认输出模块。</p>\n<pre><code class=\"javascript\">//math.js\n\nfunction add (a, b) &#123;\n  return a + b;\n&#125;\n\nfunction subtract (a, b) &#123;\n  return a - b;\n&#125;\n\nexport &#123;add, subtract&#125;  //输出函数</code></pre>\n<h5 id=\"模块引用-1\"><a href=\"#模块引用-1\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h5><p>使用<code>import</code>命令导入模块，可以使用<code>解构赋值</code>的方式导入。</p>\n<pre><code class=\"javascript\">import &#123;add, subtract&#125; from &#39;./math&#39;;  //引入add和subtract函数\n\nconsole.log(add(1, 2));  //使用add函数，输出3</code></pre>\n<h5 id=\"CommonJS-和-ES6模块\"><a href=\"#CommonJS-和-ES6模块\" class=\"headerlink\" title=\"CommonJS 和 ES6模块\"></a>CommonJS 和 ES6模块</h5><blockquote>\n<p>摘自 - 前端模块化：CommonJS,AMD,CMD,ES6</p>\n</blockquote>\n<h6 id=\"CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用\"><a href=\"#CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用\" class=\"headerlink\" title=\"CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用\"></a>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用</h6><ul>\n<li><code>CommonJS</code>模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li><code>ES6模块</code>的运行机制与<code>CommonJS</code>不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，<code>ES6</code>的<code>import</code>有点像<code>Unix</code>系统的<code>符号连接</code>，原始值变了，<code>import</code>加载的值也会跟着变。因此，<code>ES6模块</code>是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n<h6 id=\"CommonJS模块是运行时加载，ES6模块是编译时输出接口\"><a href=\"#CommonJS模块是运行时加载，ES6模块是编译时输出接口\" class=\"headerlink\" title=\"CommonJS模块是运行时加载，ES6模块是编译时输出接口\"></a>CommonJS模块是运行时加载，ES6模块是编译时输出接口</h6><ul>\n<li>运行时加载: <code>CommonJS</code>模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: <code>ES6模块</code>不是对象，而是通过<code>export</code>命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n<p><code>CommonJS</code>加载的是一个对象(即module.exports属性)，该对象只有在脚本运行完才会生成。而<code>ES6模块</code>不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p><code>require.js</code>是<code>AMD</code>规范的主要实践者，通过<code>define</code>定义模块、<code>require</code>引入模块。</p>\n<p>在客户端，一般是远程加载模块，受网络限制，使用异步方式更合理。</p>\n<p><code>AMD</code>以<strong>异步</strong>方式加载模块，推崇依赖前置，提前执行，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>\n<h5 id=\"模块引用-2\"><a href=\"#模块引用-2\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h5><p>首先需要在<code>HTML</code>中使用<code>&lt;script&gt;</code>引入<code>require.js</code>和主模块。</p>\n<pre><code class=\"html\">// HTML\n&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;  //引入require.js 和 main.js</code></pre>\n<p>使用<code>require.config()</code>引入模块文件，可以设置路径前缀、设置模块名称。再使用<code>require()</code>使用模块，如下方式设置别名。</p>\n<pre><code class=\"javascript\">//main.js\n\n//模块引入\nrequire.config(&#123;\n  baseUrl: &quot;js/lib&quot;,  //路径前缀\n  paths: &#123;\n    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js\n    &quot;underscore&quot;: &quot;underscore.min&quot;,\n    &quot;math&quot;: &quot;math&quot;\n  &#125;\n&#125;);\n\n//模块使用\nrequire([&quot;jquery&quot;, &quot;underscore&quot;, &quot;math&quot;], function($, _, math)&#123;  //使用别名\n  //code...\n  $(&quot;body&quot;).addClass(&quot;lock-screen&quot;);  //通过$别名使用jQuery\n  console.log(math.add(1, 2));  //通过math别名使用math模块，输出3\n&#125;);</code></pre>\n<h5 id=\"模块定义-2\"><a href=\"#模块定义-2\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h5><p>使用<code>define()</code>方法定义一个模块，模块内容放在<code>回调函数</code>中，并通过<code>return</code>抛出。</p>\n<pre><code class=\"javascript\">// math.js\n\n// 定义math模块\ndefine(function () &#123;\n  function add(x, y) &#123;\n    return x + y;\n  &#125;\n\n  function subtract (a, b) &#123;\n    return a - b;\n  &#125;\n\n  return &#123;\n    add: add,\n    subtract: subtract\n  &#125;;\n&#125;);\n\n// 定义一个依赖jQuery的模块\ndefine([&#39;jquery&#39;],function($)&#123;\n\n  function setClass() &#123;\n    $(&quot;body&quot;).addClass(&quot;lock-screen&quot;);\n  &#125;\n\n  return &#123;\n    setClass: setClass\n  &#125;;\n&#125;)</code></pre>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p><code>sea.js</code>是<code>CMD</code>规范的主要实践者，<code>CMD</code>吸收了<code>CommonJS</code>和<code>AMD</code>。</p>\n<p><code>CMD</code>以<strong>异步</strong>方式加载模块，推崇依赖就近，延迟执行，在代码中引入模块并运行。</p>\n<h5 id=\"模块引用-3\"><a href=\"#模块引用-3\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h5><p>首先需要在<code>HTML</code>中使用<code>&lt;script&gt;</code>引入<code>sea.js</code>和主模块。</p>\n<pre><code class=\"html\">// HTML\n&lt;script src=&quot;js/sea.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;  //引入sea.js 和 main.js</code></pre>\n<p>使用<code>define()</code>创建作用域，在<code>回调函数</code>(传入参数reuqire)中通过<code>require()</code>引入模块。</p>\n<pre><code class=\"javascript\">// main.js\n\ndefine(function (require) &#123;\n  var math = require(&#39;./math&#39;);\n  console.log(math.add(1, 2));  //使用math模块，输出3\n&#125;)</code></pre>\n<h5 id=\"模块定义-3\"><a href=\"#模块定义-3\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h5><pre><code class=\"javascript\">// math.js\n\ndefine(function (require, exports, module) &#123;\n  function add(x, y) &#123;\n    return x + y;\n  &#125;\n\n  function subtract (a, b) &#123;\n    return a - b;\n  &#125;\n\n  module.exports = &#123;\n    add: add,\n    subtract: subtract\n  &#125;\n&#125;)</code></pre>\n<h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>JS的全局变量其实是定义在一个window对象下的，例如<code>var history = 1;</code>其实是<code>var window.history = 1;</code>。然而，window对象又有许多的内置属性，如果我们自定义的属性刚好和内置属性重名的话，就会起冲突。</p>\n<p>因此，为了避免变量冲突，就有必要引入<code>命名空间</code>来隔离变量作用域，其实是用到<code>闭包</code>和<code>自触发函数</code>来模拟的。许多<code>模块化</code>的库都是基于这一原理。</p>\n<h5 id=\"自触发函数\"><a href=\"#自触发函数\" class=\"headerlink\" title=\"自触发函数\"></a>自触发函数</h5><p>先来看看<code>自触发函数</code>(IIFE)，在函数定义后立即触发。因为立即执行，后续一般不会再调用，所以可以使用匿名函数。</p>\n<pre><code class=\"javascript\">// Type 1, 没有匿名，但是立即触发\nstart();\nfunction start() &#123;\n  //...\n&#125;\n\n//Tpye 2\n(function () &#123;\n  //...\n&#125;)();\n\n//Type 3\n!function () &#123;\n  //...\n&#125;();\n\nTpye 4\n;(function() &#123;\n  //...\n&#125;)();</code></pre>\n<h5 id=\"命名空间-1\"><a href=\"#命名空间-1\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h5><p>结合<code>闭包</code>和<code>立即执行函数</code>，我们就可以很好的封装一个模块了。<code>闭包</code>用来限定作用域（命名空间），<code>立即执行函数</code>避免全局变量名字冲突。</p>\n<p><code>jQuery</code>就是用于以上两种机制，暴露出了一个<code>$</code>，来操作内部方法。</p>\n<p>以下例子，封住了<code>user</code>模块，解决变量冲突。</p>\n<pre><code class=\"javascript\">(function(window) &#123;\n  var name;\n\n  function getName() &#123;\n    return name;\n  &#125;\n\n  function setName(name) &#123;\n    name = name;\n  &#125;\n\n  window.user = &#123; getName, setName &#125;;\n&#125;)(window);\n\nuser.setName(&#39;zhaoo&#39;);\nconsole.log(user.getName()); // zhaoo</code></pre>\n<p>此外，ES6中的<code>let</code>和<code>const</code>可以产生一个块级作用域，其实也是用到了该原理。用<code>babel</code>编译后是如下ES5代码，是不是一目了然。</p>\n<pre><code class=\"javascript\">// ES6\n&#123;\n  let a = &quot;abc&quot;;\n&#125;;\nconsole.log(a);  // Error, a is not defind</code></pre>\n<pre><code class=\"javascript\">// ES5\n(function()&#123;\n  var a = &quot;abc&quot;;\n&#125;)();\nconsole.log(a);  // Error, a is not defind</code></pre>\n<p>命名空间模式也存在许多不足，一般在<code>ES5</code>年代比较多见。现在一般都是用<code>模块化</code>的方式直接引入文件模块了。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5aaa37c8f265da23945f365c#heading-4\">前端模块化：CommonJS,AMD,CMD,ES6</a></p>\n</blockquote>\n","more":"<p>在发开大型软件项目时，一般需要通过<code>模块化</code>来管理代码。将一段有逻辑联系的代码封装成<code>模块</code>，其内部数据与实现是私有的，将一些公用接口暴露出去，与其他模块进行通信，最后组织成程序。</p>\n<p>模块化的作用:</p>\n<ul>\n<li>避免命名冲突</li>\n<li>按需加载</li>\n<li>提高复用程度</li>\n<li>提高可维护性</li>\n</ul>\n<blockquote>\n<p>软件工程提倡<strong>高内聚，低耦合</strong>。</p>\n</blockquote>\n<p>目前流行的JS模块化规范有<code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>和<code>ES6模块</code>。通常将一个JS文件作为一个模块，向外暴露特定的变量和函数。</p>\n<h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3><p><code>Node</code>是<code>CommonJS</code>规范的主要实践者，通过<code>module</code>、<code>exports</code>、<code>require</code>等关键词实现<code>模块加载</code>和<code>模块定义</code>。</p>\n<p>在服务端一般模块文件都存在本地，读取速度比较快，所以使用同步加载方式一般没问题。</p>\n<p><code>CommonJS</code>以<strong>同步</strong>方式加载模块。</p>\n<h5 id=\"模块引用\"><a href=\"#模块引用\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h5><p>使用<code>require()</code>方法引入模块，传入的变量为模块标识符。</p>\n<p>在Node中有三种模块类型，<code>核心模块</code>、<code>文件模块</code>、<code>自定义模块</code>。</p>\n<ul>\n<li>核心模块: Node内置的一些模块，例如<code>http</code>、<code>fs</code>、<code>path</code>等，模块标识符为<strong>模块名称</strong>。在Node的源码编译过程中已经将这些模块编译为二进制代码，所以加载过程很快。</li>\n<li>文件模块: 一般为用户自己定义的一些模块，一个文件就是一个模块，模块标识符为<strong>文件路径</strong>。由于指明了文件加载路径，所以加载速度较快。</li>\n<li>自定义模块: 用户使用<code>npm</code>等包管理工具安装的模块，一般保存在<code>node_moudles</code>目录下，模块标识符为<strong>模块名称</strong>。由于需要按照<code>npm</code>的加载规则匹配模块，所以加载过程较慢。</li>\n</ul>\n<pre><code class=\"javascript\">//main.js\n\nvar http = require(&#39;http&#39;);  //引入核心模块\nvar math = require(&#39;./math&#39;);  //引入文件模块\nvar koa = require(&#39;koa&#39;);  //引入自定义模块\n\nconsole.log(math.add(1, 2));  //使用math模块，输出3</code></pre>\n<h5 id=\"模块定义\"><a href=\"#模块定义\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h5><p>对于文件模块，我们需要自己定义，一个文件就是一个模块。在CommonJS规范中<code>exports</code>对象是模块的唯一出口，定义导出的变量或方法。</p>\n<pre><code class=\"javascript\">//math.js\n\nexports.add = function (a, b) &#123;  //导出add方法\n  return a + b;\n&#125;\n\nexports.subtract = function (a, b) &#123;  //导出subtract方法\n  return a - b;\n&#125;</code></pre>\n<p>但是Node并不是完全按照CommonJS规范实现的，而是根据自身需要做了一些取舍，所以表现出一些特性。在Node中，我们更推荐使用<code>module.exports</code>来定义模块。</p>\n<pre><code class=\"javascript\">//math.js\n\nfunction add (a, b) &#123;\n  return a + b;\n&#125;\n\nfunction subtract (a, b) &#123;\n  return a - b;\n&#125;\n\nmodule.exports = &#123;\n  add: add,\n  subtract: subtract\n&#125;;</code></pre>\n<h5 id=\"module-exports-和-exports\"><a href=\"#module-exports-和-exports\" class=\"headerlink\" title=\"module.exports 和 exports\"></a>module.exports 和 exports</h5><p>在Node中，一个模块(文件)就是一个闭包，通过闭包机制实现了命名空间。</p>\n<pre><code class=\"javascript\">(function (exports, require, module, __filename, __dirname) &#123;\n  //code\n&#125;)();</code></pre>\n<p>每执行一个文件，就会自动创建一个<code>module</code>对象，而<code>module.exports</code>是其中的一个属性。所以<code>module.exports</code>才是真正的模块对象，<code>exports</code>只是对它的一个引用。</p>\n<p>因此，使用<code>module.exports</code>可以对该变量重新赋值，而使用<code>exports</code>不能进行重新赋值，只能对<code>exports</code>下的属性进行赋值，如<code>exports.add = add</code>。</p>\n<h3 id=\"ES6模块\"><a href=\"#ES6模块\" class=\"headerlink\" title=\"ES6模块\"></a>ES6模块</h3><p><code>ES6</code>标准在语法层面上实现了模块化，通过使用<code>import</code>和<code>export</code>实现<code>模块加载</code>和<code>模块定义</code>。由于是标准规范，使用在客户端和服务端都可以使用，一般是配合<code>webpack</code>等打包工具进行管理，因为现阶段<code>ES6</code>还需通过<code>babel</code>进行编码。</p>\n<p>不同于其他三种模块化方式，<code>ES6模块</code>是在<strong>编译过程中</strong>加载模块，而不是动态地引入一个对象。</p>\n<h5 id=\"模块定义-1\"><a href=\"#模块定义-1\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h5><p>使用<code>export</code>命令导出模块，也可以使用<code>export default</code>指定默认输出模块。</p>\n<pre><code class=\"javascript\">//math.js\n\nfunction add (a, b) &#123;\n  return a + b;\n&#125;\n\nfunction subtract (a, b) &#123;\n  return a - b;\n&#125;\n\nexport &#123;add, subtract&#125;  //输出函数</code></pre>\n<h5 id=\"模块引用-1\"><a href=\"#模块引用-1\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h5><p>使用<code>import</code>命令导入模块，可以使用<code>解构赋值</code>的方式导入。</p>\n<pre><code class=\"javascript\">import &#123;add, subtract&#125; from &#39;./math&#39;;  //引入add和subtract函数\n\nconsole.log(add(1, 2));  //使用add函数，输出3</code></pre>\n<h5 id=\"CommonJS-和-ES6模块\"><a href=\"#CommonJS-和-ES6模块\" class=\"headerlink\" title=\"CommonJS 和 ES6模块\"></a>CommonJS 和 ES6模块</h5><blockquote>\n<p>摘自 - 前端模块化：CommonJS,AMD,CMD,ES6</p>\n</blockquote>\n<h6 id=\"CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用\"><a href=\"#CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用\" class=\"headerlink\" title=\"CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用\"></a>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用</h6><ul>\n<li><code>CommonJS</code>模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li><code>ES6模块</code>的运行机制与<code>CommonJS</code>不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，<code>ES6</code>的<code>import</code>有点像<code>Unix</code>系统的<code>符号连接</code>，原始值变了，<code>import</code>加载的值也会跟着变。因此，<code>ES6模块</code>是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n<h6 id=\"CommonJS模块是运行时加载，ES6模块是编译时输出接口\"><a href=\"#CommonJS模块是运行时加载，ES6模块是编译时输出接口\" class=\"headerlink\" title=\"CommonJS模块是运行时加载，ES6模块是编译时输出接口\"></a>CommonJS模块是运行时加载，ES6模块是编译时输出接口</h6><ul>\n<li>运行时加载: <code>CommonJS</code>模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: <code>ES6模块</code>不是对象，而是通过<code>export</code>命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n<p><code>CommonJS</code>加载的是一个对象(即module.exports属性)，该对象只有在脚本运行完才会生成。而<code>ES6模块</code>不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p><code>require.js</code>是<code>AMD</code>规范的主要实践者，通过<code>define</code>定义模块、<code>require</code>引入模块。</p>\n<p>在客户端，一般是远程加载模块，受网络限制，使用异步方式更合理。</p>\n<p><code>AMD</code>以<strong>异步</strong>方式加载模块，推崇依赖前置，提前执行，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>\n<h5 id=\"模块引用-2\"><a href=\"#模块引用-2\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h5><p>首先需要在<code>HTML</code>中使用<code>&lt;script&gt;</code>引入<code>require.js</code>和主模块。</p>\n<pre><code class=\"html\">// HTML\n&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;  //引入require.js 和 main.js</code></pre>\n<p>使用<code>require.config()</code>引入模块文件，可以设置路径前缀、设置模块名称。再使用<code>require()</code>使用模块，如下方式设置别名。</p>\n<pre><code class=\"javascript\">//main.js\n\n//模块引入\nrequire.config(&#123;\n  baseUrl: &quot;js/lib&quot;,  //路径前缀\n  paths: &#123;\n    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js\n    &quot;underscore&quot;: &quot;underscore.min&quot;,\n    &quot;math&quot;: &quot;math&quot;\n  &#125;\n&#125;);\n\n//模块使用\nrequire([&quot;jquery&quot;, &quot;underscore&quot;, &quot;math&quot;], function($, _, math)&#123;  //使用别名\n  //code...\n  $(&quot;body&quot;).addClass(&quot;lock-screen&quot;);  //通过$别名使用jQuery\n  console.log(math.add(1, 2));  //通过math别名使用math模块，输出3\n&#125;);</code></pre>\n<h5 id=\"模块定义-2\"><a href=\"#模块定义-2\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h5><p>使用<code>define()</code>方法定义一个模块，模块内容放在<code>回调函数</code>中，并通过<code>return</code>抛出。</p>\n<pre><code class=\"javascript\">// math.js\n\n// 定义math模块\ndefine(function () &#123;\n  function add(x, y) &#123;\n    return x + y;\n  &#125;\n\n  function subtract (a, b) &#123;\n    return a - b;\n  &#125;\n\n  return &#123;\n    add: add,\n    subtract: subtract\n  &#125;;\n&#125;);\n\n// 定义一个依赖jQuery的模块\ndefine([&#39;jquery&#39;],function($)&#123;\n\n  function setClass() &#123;\n    $(&quot;body&quot;).addClass(&quot;lock-screen&quot;);\n  &#125;\n\n  return &#123;\n    setClass: setClass\n  &#125;;\n&#125;)</code></pre>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p><code>sea.js</code>是<code>CMD</code>规范的主要实践者，<code>CMD</code>吸收了<code>CommonJS</code>和<code>AMD</code>。</p>\n<p><code>CMD</code>以<strong>异步</strong>方式加载模块，推崇依赖就近，延迟执行，在代码中引入模块并运行。</p>\n<h5 id=\"模块引用-3\"><a href=\"#模块引用-3\" class=\"headerlink\" title=\"模块引用\"></a>模块引用</h5><p>首先需要在<code>HTML</code>中使用<code>&lt;script&gt;</code>引入<code>sea.js</code>和主模块。</p>\n<pre><code class=\"html\">// HTML\n&lt;script src=&quot;js/sea.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;  //引入sea.js 和 main.js</code></pre>\n<p>使用<code>define()</code>创建作用域，在<code>回调函数</code>(传入参数reuqire)中通过<code>require()</code>引入模块。</p>\n<pre><code class=\"javascript\">// main.js\n\ndefine(function (require) &#123;\n  var math = require(&#39;./math&#39;);\n  console.log(math.add(1, 2));  //使用math模块，输出3\n&#125;)</code></pre>\n<h5 id=\"模块定义-3\"><a href=\"#模块定义-3\" class=\"headerlink\" title=\"模块定义\"></a>模块定义</h5><pre><code class=\"javascript\">// math.js\n\ndefine(function (require, exports, module) &#123;\n  function add(x, y) &#123;\n    return x + y;\n  &#125;\n\n  function subtract (a, b) &#123;\n    return a - b;\n  &#125;\n\n  module.exports = &#123;\n    add: add,\n    subtract: subtract\n  &#125;\n&#125;)</code></pre>\n<h3 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h3><p>JS的全局变量其实是定义在一个window对象下的，例如<code>var history = 1;</code>其实是<code>var window.history = 1;</code>。然而，window对象又有许多的内置属性，如果我们自定义的属性刚好和内置属性重名的话，就会起冲突。</p>\n<p>因此，为了避免变量冲突，就有必要引入<code>命名空间</code>来隔离变量作用域，其实是用到<code>闭包</code>和<code>自触发函数</code>来模拟的。许多<code>模块化</code>的库都是基于这一原理。</p>\n<h5 id=\"自触发函数\"><a href=\"#自触发函数\" class=\"headerlink\" title=\"自触发函数\"></a>自触发函数</h5><p>先来看看<code>自触发函数</code>(IIFE)，在函数定义后立即触发。因为立即执行，后续一般不会再调用，所以可以使用匿名函数。</p>\n<pre><code class=\"javascript\">// Type 1, 没有匿名，但是立即触发\nstart();\nfunction start() &#123;\n  //...\n&#125;\n\n//Tpye 2\n(function () &#123;\n  //...\n&#125;)();\n\n//Type 3\n!function () &#123;\n  //...\n&#125;();\n\nTpye 4\n;(function() &#123;\n  //...\n&#125;)();</code></pre>\n<h5 id=\"命名空间-1\"><a href=\"#命名空间-1\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h5><p>结合<code>闭包</code>和<code>立即执行函数</code>，我们就可以很好的封装一个模块了。<code>闭包</code>用来限定作用域（命名空间），<code>立即执行函数</code>避免全局变量名字冲突。</p>\n<p><code>jQuery</code>就是用于以上两种机制，暴露出了一个<code>$</code>，来操作内部方法。</p>\n<p>以下例子，封住了<code>user</code>模块，解决变量冲突。</p>\n<pre><code class=\"javascript\">(function(window) &#123;\n  var name;\n\n  function getName() &#123;\n    return name;\n  &#125;\n\n  function setName(name) &#123;\n    name = name;\n  &#125;\n\n  window.user = &#123; getName, setName &#125;;\n&#125;)(window);\n\nuser.setName(&#39;zhaoo&#39;);\nconsole.log(user.getName()); // zhaoo</code></pre>\n<p>此外，ES6中的<code>let</code>和<code>const</code>可以产生一个块级作用域，其实也是用到了该原理。用<code>babel</code>编译后是如下ES5代码，是不是一目了然。</p>\n<pre><code class=\"javascript\">// ES6\n&#123;\n  let a = &quot;abc&quot;;\n&#125;;\nconsole.log(a);  // Error, a is not defind</code></pre>\n<pre><code class=\"javascript\">// ES5\n(function()&#123;\n  var a = &quot;abc&quot;;\n&#125;)();\nconsole.log(a);  // Error, a is not defind</code></pre>\n<p>命名空间模式也存在许多不足，一般在<code>ES5</code>年代比较多见。现在一般都是用<code>模块化</code>的方式直接引入文件模块了。</p>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><blockquote>\n<p><a href=\"https://juejin.im/post/5aaa37c8f265da23945f365c#heading-4\">前端模块化：CommonJS,AMD,CMD,ES6</a></p>\n</blockquote>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"js","path":"api/tags/js.json"}]}